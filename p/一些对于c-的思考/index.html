<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" static和extern区别？ 外部是可见性关键词，内部是所有实例共享static的变量，静态类成员变量属于全体实例，所以任意实例不能给静态变量分配内存，要用类使用变量，static让被修饰的语句具有唯一性，确定性\n">
<title>一些对于C&#43;&#43;的思考</title>

<link rel='canonical' href='https://Frederick2313072.github.io/p/%E4%B8%80%E4%BA%9B%E5%AF%B9%E4%BA%8Ec-%E7%9A%84%E6%80%9D%E8%80%83/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="一些对于C++的思考">
<meta property='og:description' content=" static和extern区别？ 外部是可见性关键词，内部是所有实例共享static的变量，静态类成员变量属于全体实例，所以任意实例不能给静态变量分配内存，要用类使用变量，static让被修饰的语句具有唯一性，确定性\n">
<meta property='og:url' content='https://Frederick2313072.github.io/p/%E4%B8%80%E4%BA%9B%E5%AF%B9%E4%BA%8Ec-%E7%9A%84%E6%80%9D%E8%80%83/'>
<meta property='og:site_name' content='Frederick'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-03-30T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-04-27T00:48:32&#43;08:00'/>
<meta name="twitter:title" content="一些对于C++的思考">
<meta name="twitter:description" content=" static和extern区别？ 外部是可见性关键词，内部是所有实例共享static的变量，静态类成员变量属于全体实例，所以任意实例不能给静态变量分配内存，要用类使用变量，static让被修饰的语句具有唯一性，确定性\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "dark");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_db8ca5b2d3391751.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🐋</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Frederick</a></h1>
            <h2 class="site-description">Welcome to my alter ego&#39;s site!</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/Frederick2313072'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/resources/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Resources</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#c程序基本要素">C++程序基本要素</a></li>
        <li><a href="#数据类型">数据类型</a></li>
        <li><a href="#数组">数组</a></li>
        <li><a href="#指针">指针</a></li>
        <li><a href="#字符串">字符串</a></li>
        <li><a href="#const">const</a></li>
        <li><a href="#结构体">结构体</a></li>
        <li><a href="#枚举">枚举</a></li>
        <li><a href="#控制语句">控制语句</a></li>
        <li><a href="#函数声明">函数声明</a></li>
        <li><a href="#内联函数">内联函数</a></li>
        <li><a href="#编译预处理指令">编译预处理指令</a></li>
        <li><a href="#作用域和生存期区别和关系">作用域和生存期区别和关系</a></li>
        <li><a href="#变量的内存分配方式">变量的内存分配方式</a></li>
        <li><a href="#变量的存储类型">变量的存储类型</a></li>
        <li><a href="#作用域">作用域</a></li>
        <li><a href="#函数的存储类型">函数的存储类型</a></li>
        <li><a href="#动态分配内存">动态分配内存</a></li>
        <li><a href="#内存的动态分配与释放">内存的动态分配与释放</a></li>
        <li><a href="#构造函数和析构函数">构造函数和析构函数</a></li>
        <li><a href="#重载">重载</a></li>
        <li><a href="#模板">模板</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E4%B8%80%E4%BA%9B%E5%AF%B9%E4%BA%8Ec-%E7%9A%84%E6%80%9D%E8%80%83/">一些对于C&#43;&#43;的思考</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-03-30</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <ul>
<li>static和extern区别？</li>
</ul>
<p>外部是可见性关键词，内部是所有实例共享static的变量，静态类成员变量属于全体实例，所以任意实例不能给静态变量分配内存，要用类使用变量，static让被修饰的语句具有唯一性，确定性</p>
<ul>
<li>为什么要在类内设置static？</li>
</ul>
<p>如果没有设定为static，连接器会跨编译单元进行连接（外部链接），尽可能让函数和变量变成静态（内部链接），除非需要跨编译单元进行连接。不能在静态方法中访问实例化对象里的非静态变量；static可以将被修饰的生存期延长到整个程序，静态成员只需要一个初始化，而没有静态的成员每次调用都会初始化</p>
<ul>
<li>构造对象时都会调用构造函数</li>
<li>为什么要写析构函数？</li>
</ul>
<p>在对象被销毁时被调用，想到于给一个反馈，比如~Entity(){std::cout&laquo;&ldquo;Destroyed Entity!&quot;&laquo;std::endl;}</p>
<ul>
<li>可见性</li>
</ul>
<p>private（只有这个类可以访问这些变量）,public,protected（在层次结构中的子类可以访问这些符号）</p>
<ul>
<li>为什么要用可见性，哪里要用到，为什么所有不用public？</li>
</ul>
<p>可见性或许和性能无关，不是CPU需要理解的，但是增加代码的维护性，例如private规定一些东西不能被破坏</p>
<ul>
<li>比较int example[5]和int* another = new int[5],为什么要动态的用new来分配，而不是在栈上创建？</li>
</ul>
<p>生存期。用new在堆上创建，将一直存在直到手动回收</p>
<ul>
<li>为什么使用mutable?</li>
</ul>
<p>在类中修改特定成员变量（const）</p>
<ul>
<li>什么时候用栈，什么时候用堆？</li>
</ul>
<p>栈：作用域结束，内存释放，栈内存回收，如果想让在作用域之外依然存在，就不能分配到栈上，如果类/对象太多，栈没有足够的空间，分配在堆上（例：Entity* entity=new Entity(&ldquo;Cherno&rdquo;)）,显式的控制对象的生存期，但是麻烦，需要手动delete，可能会导致内存泄露，而栈方便自动</p>
<ul>
<li>创建new的过程</li>
</ul>
<p>找到一个足够大的内存块，给一个指向那块内存块的指针（内存地址 ），调用构造函数，记得delete！</p>
<p>this是一个常量指针，但是可以修改this指向对象的内容</p>
<ul>
<li>智能指针的本质？为什么要用智能指针？</li>
</ul>
<p>原始指针的包装，调用new并分配内存，基于使用的智能指针，自动释放。好处，不会得到没有引用的悬空指针，从而造成内存泄露，在unique_ptr中不调用new是因为它安全，而shared_ptr需要分配另一块内存，叫做控制块，用来存储引用计数，当引用计数为0时shared_ptr不存在；有限使用unique_ptr,但在对象之间共享，不能使用unique_ptr时，就使用shared_ptr。</p>
<ul>
<li>为什么要重写C++中存在的数据结构？</li>
</ul>
<p>标准模板库的速度不是优先考虑的东西</p>
<ul>
<li>关于动态数组？</li>
</ul>
<p>std::vector<Vectex> vertices;&lt;&gt;内可以是int，与java不同，C++可以传递数据类型</p>
<ul>
<li>为什么存储vertor对象比存储指针在技术上更优？</li>
</ul>
<p>vertor内存分配时连续的数组，没有内部碎片，更方便读取，但是vector读取更慢，指针直接指向内存地址，更快</p>
<ul>
<li>vector如何重新分配多余的元素？</li>
</ul>
<p>从内存中的就位置复制到内存中的新位置，然后删除旧位置的内存，</p>
<ul>
<li>静态链接和动态链接的实际性能差异？</li>
</ul>
<p>静态链接允许更多优化发生，dll是动态链接库，lib文件其实就是指向ddl文件的指针，如果用不同的静态库，在运行时连接到ddl，会得到不匹配的函数</p>
<ul>
<li>
<p>C++中如何处理多返回值</p>
</li>
<li>
<p>C++模板,在哪里可以使用模板？在哪里不可以使用？</p>
</li>
</ul>
<p>模板允许用户定义一个可以根据用途进行编译的模板，就是让编译器基于一个规则为人写代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">void Print(T value){
</span></span><span class="line"><span class="cl">    std::count &lt;&lt; value &lt;&lt;std::endl;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">Print&lt;std::string&gt;(5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>T被string所替代</p>
<p>模板只有在它被调用时才会被创建，因为它只是代码，才会被创建,报错取决于编辑器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">T</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">Array</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">m_Array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">GetSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">N</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>日志系统，包含不同类型的统一缓冲区时，但是模板变复杂容易找不到错误在哪</p>
<ul>
<li>C++中的堆与栈是如何分配内存的？</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int a=5;
</span></span><span class="line"><span class="cl">int* b =new int;
</span></span><span class="line"><span class="cl">*b =5;
</span></span></code></pre></td></tr></table>
</div>
</div><p>shift，又是堆栈</p>
<p>应用程序启动后，操作系统要做的就是将整个程序加载到内存，并分配一大堆物理RAM，堆与栈是RAM中实际存在的两个区域，栈通常是一个预定义大小的内存区域，2M左右，堆也是预定义了默认值，但可以生长。我们的内存中有两个不同的区域，内存是用来实际存储数据的，需要另一个存储运行所需的数据，不管是局部变量还是从文件中读取的东西，当我们想要存储一个整数时，把栈指针移动4个字节，（就像一条CPU指令？）所以栈分配很快，而堆调用malloc的函数，浏览空闲列表，给一个指针，记录。</p>
<ul>
<li>auto自动推导类型，那么好用，为什么不全部用auto？</li>
</ul>
<p>迭代器声明可以用用，有些类型需要明确语义，如接口返回值，避免隐式转换</p>
<ul>
<li>静态数组std::array</li>
</ul>
<p>在栈上创建，有边界检查</p>
<ul>
<li>lambda</li>
</ul>
<p>在我们会设置函数指针指向函数的任何地方，都可以将它设置为lambda</p>
<ul>
<li>为什么需要结构体？</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="ne">Object</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="ne">int</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="ne">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">e</span><span class="p">[</span><span class="n">array_length</span><span class="p">];</span><span class="o">//</span><span class="err">一个类型为</span><span class="n">Object的数组</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">Object</span> <span class="n">a</span><span class="err">；</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>限制了成员元素的使用，避免混淆，有需要用到value[],Value[]，不同的结构体可以拥有相同名字的成员元素，同名的成员元素相互独立。访问/修改成员元素(*ptr).v=tmp,ptr-&gt;v=tmp修改结构体中的成员元素</p>
<ul>
<li>union和struct区别？</li>
</ul>
<p>union所有成员共享内存，而struct每个成员有独立内存，union大小=最大成员大小，struct大小&gt;=所有成员大小之和，union修改一个成员会影响其他成员，struct修改以一个成员不影响其他成员</p>
<ul>
<li>一些指针注意事项？</li>
</ul>
<p>指针变量的大小在不同环境下有差异。在 32 位机上，地址用 32 位二进制整数表示，因此一个指针的大小为 4 字节。而 64 位机上，地址用 64 位二进制整数表示，因此一个指针的大小就变成了 8 字节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int* pa = &amp;a；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">(*px).a=4;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">px-&gt;b =5;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="c程序基本要素">C++程序基本要素
</h3><p>程序由语句组成，包括声明语句和执行语句</p>
<p>语句由基本要素组成：标识符，关键字，常量（不占空间），变量，运算符，表达式</p>
<p>C++对C的扩充</p>
<ul>
<li>C++函数声明不可以省略</li>
<li>变量声明语句不要求放在函数和语句块的开始位置</li>
<li>强制类型转换，增加形式 int（a），类似函数调用</li>
<li>C++用new和delete运算符取代C中的malloc()和free()</li>
<li>C++提供字符串类string，替代C字符数组</li>
<li>C++用控制台输入输出流对象（iostream）替代C的stdio函数库，</li>
</ul>
<h3 id="数据类型">数据类型
</h3><ul>
<li>基本数据类型：</li>
</ul>
<p>从低级到高级是自动转换，高级转低级会有风险，因为会丢掉一部分</p>
<p>强制转换不安全，所以要指明，如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">float x=123.56;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int i =(int)x
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>为什么要有变量的类型？可以没有吗？</li>
</ul>
<p>变量类型确定长度，变量名确定起点，有了起点和长度，可以知道在内存中取的地址。如果一门语言设计的可以从其他地方知道终点，那就可以没有变量类型</p>
<h3 id="数组">数组
</h3><p>一组具有相同类型数据的有序集合</p>
<ul>
<li>如何处理不同类型数据？</li>
</ul>
<p>结构体</p>
<ul>
<li>数组的维数为什么是常量表达式？</li>
</ul>
<p>因为要分配给定的空间，不可变（和编译器有关），所以不可以是变量</p>
<p>！C++源程序编译时，为了保证编译和运行的效率，C++编译系统不对数组下标进行越界检查，程序运行时系统也不会提出越界警告，所以小心，以免破坏其他存储单元的数据</p>
<p>一些初始化的特殊情况</p>
<p>初始值的个数可以比数组元素个数少</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int a[2][3]={2,3,4};
</span></span></code></pre></td></tr></table>
</div>
</div><p>当提供全部初始值时，一维的长度可以省略</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">float grade[]={90.0,75.0,85.0}
</span></span><span class="line"><span class="cl">int a[][3]={{2,4,6},{8,10,12}}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指针">指针
</h3><p>任何变量都有一个内存地址，该地址称为指针，而指针变量是一种存放内存地址的变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int* pointer;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int a=10;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int* pa=&amp;a;
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>指针与数组</li>
</ul>
<p>指针代替下标引用数组元素，使数组的使用更加灵活有效，</p>
<p>数组名表示数组在内存中的首地址（见数据类型问题）</p>
<ul>
<li>程序循环中的pa可以换成a吗？</li>
</ul>
<p>不可以，数组名就是常指针，而常指针不可变</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int a[]={0};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int* pa=a;//a就是&amp;a[0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">result+=pa*;
</span></span><span class="line"><span class="cl">pa++;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字符串">字符串
</h3><p>C++语言没有提供字符串类类型，字符串变量作为以为字符串数组处理</p>
<p>C++编译程序自动在字符串的末尾加上字符’\0‘（字符串结束符），求字符串长度时不能将它计算在内</p>
<p>转义字符&rdquo;\&ldquo;&ldquo;表示双引号</p>
<p>两种初始化写法，比较不同</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">char</span> <span class="n">s</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;hello&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="n">s</span><span class="p">[]</span><span class="o">=</span><span class="s2">&#34;hello&#34;</span><span class="p">;</span><span class="o">//</span><span class="mi">6</span><span class="err">个元素</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span><span class="s2">&#34;hello&#34;</span><span class="p">;</span><span class="o">//</span><span class="n">C</span><span class="o">++</span> <span class="mi">11</span><span class="err">标准</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的常量是不占系统内存，拷贝一份到数组，但下面那个有指针指向它，占内存空间，只要有指针不被释放，就不能删内存空间。但是两者内存空间想用</p>
<h3 id="const">const
</h3><p>必须初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="n">size2</span> <span class="o">=</span><span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#define size1 20</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>符号常量和const常量一样吗？该选哪个？</li>
</ul>
<p>推荐第一种。宏定义在预编译时作文本替换，不做类型检查，而const在编译时会进行类型检查</p>
<ul>
<li>常指针和常值变量指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">p1</span><span class="o">=&amp;</span><span class="n">x</span><span class="p">;</span><span class="o">//</span><span class="err">常指针，地址不能变</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">double</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=&amp;</span><span class="n">x</span><span class="p">;</span><span class="o">//</span><span class="err">常值变量指针，值不能变</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>普通指针不能指向常值变量，常值变量不能指向普通指针</p>
<h3 id="结构体">结构体
</h3><p>结构属于构造类型，是由多种类型的数据组成</p>
<p>结构中的每个数据项位成员</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//定义结构体
</span></span><span class="line"><span class="cl">struct staffer{
</span></span><span class="line"><span class="cl">    int ID;
</span></span><span class="line"><span class="cl">    char name[20];
</span></span><span class="line"><span class="cl">    bool sex;
</span></span><span class="line"><span class="cl">    float salary;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>例子:两种访问形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void eg2_11_0{
</span></span><span class="line"><span class="cl">    staffer employee1={110,&#34;liming&#34;,1,23678.39};
</span></span><span class="line"><span class="cl">    staffer employee2= employee1;
</span></span><span class="line"><span class="cl">    employee2.ID=234543;
</span></span><span class="line"><span class="cl">    staffer* pstaff = &amp;employee2;
</span></span><span class="line"><span class="cl">    pstaff -&gt; salary =1000.00;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>数组名name即&amp;name[0]是个常值变量，所以不能写成employee2.name= &ldquo;WangPing&rdquo;;</p>
<p>要写成拷贝字符串 strcpy(employee2.name,&ldquo;Wangping&rdquo;)</p>
<h3 id="枚举">枚举
</h3><p>允许用符号常量代表数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">enum</span> <span class="ne">Color</span> <span class="p">{</span><span class="n">Red</span><span class="p">,</span><span class="n">Green</span><span class="p">,</span><span class="n">Blue</span><span class="p">};</span><span class="o">//</span><span class="n">Red对应0</span><span class="err">，</span><span class="n">Green对应1</span><span class="err">，</span><span class="n">Blue对应2</span><span class="err">，这是默认的</span>
</span></span><span class="line"><span class="cl"><span class="ne">Color</span> <span class="n">color1</span> <span class="o">=</span><span class="n">Red</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">color1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Weather</span> <span class="p">{</span><span class="n">windy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">rainy</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">cloudy</span><span class="p">,</span><span class="n">sunny</span><span class="o">=</span><span class="mi">3</span><span class="p">};</span><span class="o">//</span><span class="n">cloudy的常量是</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>枚举类型有什么用？为什么不直接用枚举常量对应的数值？</li>
</ul>
<p>增加程序的可读性</p>
<p>typedef</p>
<p>对原有的数据类型定义一个新的名称</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef int INT32;
</span></span><span class="line"><span class="cl">INT32 i=1;//就是int i=1
</span></span><span class="line"><span class="cl">typedef struct tagDate{
</span></span><span class="line"><span class="cl">    int year;
</span></span><span class="line"><span class="cl">    int month;
</span></span><span class="line"><span class="cl">    int day;
</span></span><span class="line"><span class="cl">} DATE;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">INT32 i = 0;
</span></span><span class="line"><span class="cl">DATE today = {2025,4,1}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>使用typedef类型定义有什么用？</li>
</ul>
<p>增加程序的可移植性（不用全局改，只用改一句就行），可读性，用户自定义</p>
<h3 id="控制语句">控制语句
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if...else if ....else....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">switch{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">case &#39;A&#39;:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cout &lt;&lt; &#34;优秀&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意加break！</p>
<p>switch语句单入口多出库，一通百通</p>
<p>如果没有break，几个case会一直执行下去</p>
<ul>
<li>for语句执行顺序？</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for(&lt;表达式1&gt;;&lt;表达式2&gt;;&lt;表达式3&gt;){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  &lt;语句&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>先对表达式1求值，然后对表达式2求值，如果表达式2为真，执行循环体，执行完循环体，对表达式3求值，完成一次循环，再对表达式2求值，决定是否进行下一次循环</p>
<p>do-while语句</p>
<p>至少循环一次，先循环再判断</p>
<ul>
<li>三种循环语句比较？</li>
</ul>
<p>for：循环次数条件明确</p>
<p>while：循环条件明确</p>
<p>do&hellip;while&hellip;.至少循环一次</p>
<h3 id="函数声明">函数声明
</h3><p>C++允许函数调用在前，定义在后</p>
<ul>
<li>此时要求在调用前必须进行函数声明，把函数名，函数类型，形参告诉编译系统，以便调用时进行语法检查，函数声明放*.h，函数定义放 *.cpp</li>
</ul>
<p>函数调用过程：中断当前函数的执行，将程序的执行流程转移到被调用函数，并将输参传递给形参，调用结束后返回主调函数</p>
<p>例子：地址，引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void swap1(int* x,int* y){
</span></span><span class="line"><span class="cl">    int temp = *x;
</span></span><span class="line"><span class="cl">    *x =*y;
</span></span><span class="line"><span class="cl">    *y=temp;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void swap2(int&amp; x,int&amp; y){
</span></span><span class="line"><span class="cl">    int temp =x;
</span></span><span class="line"><span class="cl">    x=y;
</span></span><span class="line"><span class="cl">    y=temp;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">swap1(&amp;a,&amp;b);
</span></span><span class="line"><span class="cl">swap2(a,b);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="内联函数">内联函数
</h3><p>调用函数时，系统要进行现场处理工作，需要占用附加的现场处理时间</p>
<ul>
<li>把函数体直接嵌入函数调用处，则可消除附加的现场处理的事件开销，提高程序的运行效率</li>
<li>调用内联函数时不发生控制转移，知识在编译时把函数体嵌入到调用出</li>
</ul>
<p>内联函数的定义：</p>
<ul>
<li>在函数头前加入关键字inline</li>
<li>当编译程序遇到内联函数调用语句时，会将内联函数的函数体替换调用语句</li>
</ul>
<p>优缺点</p>
<ul>
<li>加快代码调用速度</li>
<li>增加内存的空间开销</li>
</ul>
<p>函数默认参数</p>
<ul>
<li>
<p>有多个默认参数，应该放在参数表的右侧</p>
</li>
<li>
<p>调用时，若省略某实参，则该实参右边的所有实参都必须省略</p>
</li>
<li>
<p>若省略实参，则默认值传递给形参</p>
</li>
</ul>
<p>引用</p>
<p>另一个变量的别名</p>
<ul>
<li>声明引用时，必须对其进行初始化</li>
<li>编译器一般将引用实现为const指针，即指向位置不可变的指针，本质是同一个白能量并且占用相同的内存单元，只是名字不一样</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i=10;
</span></span><span class="line"><span class="cl">int&amp; r=i;
</span></span></code></pre></td></tr></table>
</div>
</div><p>r和i占用的是同一个内存空间，只是两个不同名字</p>
<p>引用一般作为函数参数，能让代码更好看</p>
<h3 id="编译预处理指令">编译预处理指令
</h3><ul>
<li>include文件包含</li>
<li>define宏定义：不进行类型检查，注意宏的安全，带括号</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define ((a)&gt;(b)?(a):(b))
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>条件编译</li>
</ul>
<p>决定哪些源程序段将被编译，哪些源程序段将不被编译</p>
<p>#if&hellip;&hellip;#else&hellip;&hellip;#endif&hellip;&hellip;</p>
<p>主要作用：管理测试与生产代码</p>
<h3 id="作用域和生存期区别和关系">作用域和生存期区别和关系
</h3><ul>
<li>作用域是变量在源程序中的一段静态区域</li>
<li>变量的生存期是指从创建到撤销（分配内存空间到释放）</li>
<li>有些变量没有生存期，但有作用域，有时变量虽然在生存期，但不在作用域</li>
</ul>
<h3 id="变量的内存分配方式">变量的内存分配方式
</h3><p>自动分配（运行），静态分配（编译时），动态分配（运行时）</p>
<h3 id="变量的存储类型">变量的存储类型
</h3><p>auto:内部变量，存储在栈上</p>
<p>register：内部变量，存储在寄存器中</p>
<p>extern：外部变量</p>
<p>static：内部或外部变量</p>
<p>未指定存储类型，内部默认为auto，外部默认为extern</p>
<h3 id="作用域">作用域
</h3><p>例：全局变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extern int b
</span></span></code></pre></td></tr></table>
</div>
</div><p>引用外部变量，不开辟内存空间</p>
<p>例：静态变量</p>
<p>并不会因为函数调用结束而释放内存</p>
<p>比较以下两种：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void fun(){
</span></span><span class="line"><span class="cl">    int a=0;
</span></span><span class="line"><span class="cl">    a++;
</span></span><span class="line"><span class="cl">    cout &lt;&lt; &#34;a=&#34; &lt;&lt; a &lt;&lt; endl;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">a=1,a=1
</span></span><span class="line"><span class="cl">void fun(){
</span></span><span class="line"><span class="cl">    static in a=0;
</span></span><span class="line"><span class="cl">    a++;
</span></span><span class="line"><span class="cl">    cout &lt;&lt; &#34;a=&#34; &lt;&lt; a &lt;&lt; endl;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">a=1,a=2
</span></span><span class="line"><span class="cl">void exp(){
</span></span><span class="line"><span class="cl">    for(int i=0;i&lt;2;i++){
</span></span><span class="line"><span class="cl">    fun();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>作用域限定符::</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int amout=123;//全局变量
</span></span><span class="line"><span class="cl">void sg2_33(){
</span></span><span class="line"><span class="cl">    int amount =456;//局部变量
</span></span><span class="line"><span class="cl">    cout&lt;&lt;::amout&lt;&lt;endl;//123
</span></span><span class="line"><span class="cl">    cout&lt;&lt;amout&lt;&lt;endl;//456
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>命名空间</p>
<p>命名空间可避免全局标识符同名引起冲突，是对一些成员进行声明的一个描述性区域</p>
<p>引入命名空间后，标准C++库都定义在std中（using namespace std）</p>
<h3 id="函数的存储类型">函数的存储类型
</h3><p>内部函数static：只能被以同一个源文件中的函数调用</p>
<p>外部函数extern：可以被其他源文件中的函数调用</p>
<h3 id="动态分配内存">动态分配内存
</h3><p>动态分配是指在程序运行时为程序中的变量分配内存空间，它完全由应用程序自己进行内存的分配和释放，在堆上分配</p>
<p>（一般来说，编译器在编译阶段就自动将管理这些空间的代码加入到目标文件中，程序运行后由系统自动为变量分配内存空间，在作用域结束后自动释放内存空间）</p>
<h3 id="内存的动态分配与释放">内存的动态分配与释放
</h3><p>C语言中，动态内存分配时通过调用标准库malloc()和free()实现</p>
<p>C++中，利用new和delete进行动态内存的分配释放</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;指针变量&gt; = new &lt;数据类型&gt;；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">delete &lt;指针变量&gt;；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">delete[]&lt;指针变量&gt;；//释放动态数组
</span></span></code></pre></td></tr></table>
</div>
</div><p>例子：编程输出斐波那契数列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void eg2_36(){
</span></span><span class="line"><span class="cl">     int *f,n;
</span></span><span class="line"><span class="cl">     cin &gt;&gt; n;
</span></span><span class="line"><span class="cl">     f=new int[n+1];
</span></span><span class="line"><span class="cl">     if(n==nullptr||n&lt;1){
</span></span><span class="line"><span class="cl">         cout &lt;&lt; &#34;Heap error&#34;
</span></span><span class="line"><span class="cl">         return;
</span></span><span class="line"><span class="cl">     }
</span></span><span class="line"><span class="cl">     f[0]=f[1]=1;
</span></span><span class="line"><span class="cl">     cout &lt;&lt; f[0] &lt;&lt; f[1] &lt;&lt;endl;
</span></span><span class="line"><span class="cl">     for(int i=2;i&lt;=n;i++){
</span></span><span class="line"><span class="cl">         f[i]=f[i-1]+f[i-2];
</span></span><span class="line"><span class="cl">         cout &lt;&lt; f[i] &lt;&lt;endl;
</span></span><span class="line"><span class="cl">     }
</span></span><span class="line"><span class="cl">     delete []f;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="构造函数和析构函数">构造函数和析构函数
</h3><ul>
<li>如何初始化成员变量？</li>
</ul>
<p>成员变量一般都为私有属性，也不能在声明对象后利用赋值运算对成员变量进行初始化，成员变量的初始化一般时利用构造函数来完成</p>
<ul>
<li>构造函数：创建对象是系统自动调用的成员函数</li>
<li>析构函数：对象生存期结束时系统自动调用的成员函数</li>
</ul>
<h3 id="重载">重载
</h3><p>函数重载，运算符重载，函数名相同函数参数的类型不同</p>
<p>例子：构造函数重载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Box{
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">Box();
</span></span><span class="line"><span class="cl">Box(double h);
</span></span><span class="line"><span class="cl">Box(double h,double w);
</span></span><span class="line"><span class="cl">Box(double h,double w,double d);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">//超级构造函数
</span></span><span class="line"><span class="cl">Box(double h=0,doubke w =0,double d=0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>重载规则</p>
<ul>
<li>
<p>以下非法</p>
</li>
<li>
<p>返回类型不能不同</p>
</li>
</ul>
<p>long fun(int);</p>
<p>float fun(int);</p>
<ul>
<li>不能利用引用重载</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void fun(int&amp;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void fun(int)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>const可用于重载</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">fun</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运算符重载</p>
<ul>
<li>输出流运算符函数原型</li>
</ul>
<p>ostream&amp; operator&laquo;(ostream&amp; os,&lt;操作对象&gt;)</p>
<ul>
<li>加法运算符函数原型</li>
</ul>
<p>&lt;返回类型&gt; operator+(&lt;操作对象&gt;，&lt;操作对象&gt;)</p>
<ul>
<li>自增运算符函数类型</li>
</ul>
<p>&lt;返回类型&gt; operator++(&lt;操作对象&gt;)</p>
<ul>
<li>下标运算符函数类型</li>
</ul>
<p>&lt;返回类型&gt;&amp; operator[&lt;操作对象&gt;，int i]</p>
<p>例子：加法运算符重载，复数相加(普通函数)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class CComplex{
</span></span><span class="line"><span class="cl">private:
</span></span><span class="line"><span class="cl">    double r,i;
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    CComplex(double r=0,double i=0);
</span></span><span class="line"><span class="cl">    virtual ~CComplex();
</span></span><span class="line"><span class="cl">    friend CComplex operator+(CComplex c1,CComplex c2);
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">CComplex operator+(CComplex c1,CComplex c2){
</span></span><span class="line"><span class="cl">    CComplex Ctemp;
</span></span><span class="line"><span class="cl">    CTemp.r = c1.r+c2.r;
</span></span><span class="line"><span class="cl">    CTemp.i = c1.i+c2.e;
</span></span><span class="line"><span class="cl">    return CTemp;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>例子：自增运算符重载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Counter{
</span></span><span class="line"><span class="cl">private:
</span></span><span class="line"><span class="cl">    int value;
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    Counter(){ value = 0;}
</span></span><span class="line"><span class="cl">    Counter operator++();//前缀运算符
</span></span><span class="line"><span class="cl">    Counter operator++(int);//后缀运算符
</span></span><span class="line"><span class="cl">    void display(){
</span></span><span class="line"><span class="cl">        cout &lt;&lt; &#34;value:&#34;&lt;&lt;value &lt;&lt; endl;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">Counter Counter::operator++(){
</span></span><span class="line"><span class="cl">    value++;
</span></span><span class="line"><span class="cl">    return *this;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">Counter Counter::operator++(int){
</span></span><span class="line"><span class="cl">    Counter temp;
</span></span><span class="line"><span class="cl">    temp.value=this-&gt;value++;
</span></span><span class="line"><span class="cl">    return temp;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>写成++i前缀运算符效率更高，不用创建临时变量</p>
<h3 id="模板">模板
</h3><p>函数模板</p>
<p>编译器根据函数实参的数据类型确定模板参数T，再自动生成对应的函数，即模板函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;class T&gt;;
</span></span><span class="line"><span class="cl">T my_abs(T val){
</span></span><span class="line"><span class="cl">return (val&lt;0)?-val : val;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void eg4_22(){
</span></span><span class="line"><span class="cl">    int i=100;
</span></span><span class="line"><span class="cl">    long l=-123456L;
</span></span><span class="line"><span class="cl">    float f=-12.78F;
</span></span><span class="line"><span class="cl">    cout&lt;&lt;my_abs(i)&lt;&lt; my_abs(l)&lt;&lt;my_abs(f)&lt;&lt;endl;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>类模板</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//内部定义成员函数
</span></span><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">class MyTemClass{
</span></span><span class="line"><span class="cl">private:
</span></span><span class="line"><span class="cl">    T x;
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    void setX(T a){ x=a;}
</span></span><span class="line"><span class="cl">    void getX(){ return x;}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">//外部定义成员函数
</span></span><span class="line"><span class="cl">template &lt;typename T1&gt;
</span></span><span class="line"><span class="cl">void MyTemClass&lt;T1&gt;::setX(T1 x)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    this-&gt;x=x;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">void MyTemClass&lt;T&gt;::getX(){
</span></span><span class="line"><span class="cl">    return this-&gt;x;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>含多个参数的类模板</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T1,int i,typename T2&gt;
</span></span><span class="line"><span class="cl">class MyClassM{};
</span></span><span class="line"><span class="cl">//实例化
</span></span><span class="line"><span class="cl">MyclassM&lt;int,100,float&gt; MyObject;
</span></span></code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Apr 27, 2025 00:48 &#43;0800
        </span>
    </section></footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="Frederick2313072/utterances-comments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2025 Frederick
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<style>
  body {
    background: url(https://Frederick2313072.github.io/background/background.jpg) no-repeat center top;
    background-size: cover;
    background-attachment: fixed;
  }
</style>

    </body>
</html>
